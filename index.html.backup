<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdn.tailwindcss.com https://unpkg.com https://cdnjs.cloudflare.com; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.tailwindcss.com https://unpkg.com https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://cdn.tailwindcss.com;">
    <title>Soundflakes</title>
    <link rel="icon" type="image/jpeg" href="/logo.jpg" id="favicon">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@300;400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        * { touch-action: manipulation; -webkit-user-select: none; user-select: none; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background: #000; -webkit-text-size-adjust: 100%; }
        .knob { width: 50px; height: 50px; cursor: pointer; touch-action: none; -webkit-tap-highlight-color: transparent; }
        canvas { display: block; }
        input[type=range]::-webkit-slider-thumb { appearance: none; width: 20px; height: 20px; background: #fff; border-radius: 50%; }
        .menu-slide { animation: slideInRight 0.3s ease-out; }
        @keyframes slideInRight {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }
        .apple-button {
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            background: rgba(255, 255, 255, 0.1);
            border: 0.5px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        .apple-button:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        .apple-button:active {
            transform: scale(0.95);
        }
        .button-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }
        .note-playing {
            animation: notePulse 1.2s ease-in-out infinite !important;
            z-index: 10;
            position: relative;
        }
        @keyframes notePulse {
            0%, 100% {
                box-shadow: 0 0 8px currentColor, 0 0 4px currentColor !important;
                opacity: 1 !important;
            }
            50% {
                box-shadow: 0 0 16px currentColor, 0 0 8px currentColor !important;
                opacity: 0.95 !important;
            }
        }
        .apple-input {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.08);
            border: 0.5px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
        }
        .apple-input:focus {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.3);
            outline: none;
        }
        .apple-button-secondary {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.08);
            border: 0.5px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            transition: all 0.2s;
        }
        .apple-button-secondary:hover {
            background: rgba(255, 255, 255, 0.12);
        }
        .apple-button-secondary:active {
            transform: scale(0.97);
        }
    </style>
</head>
<body>
    <div id="app" class="w-screen h-screen relative bg-black" style="width: 100vw; height: 100vh; position: fixed; top: 0; left: 0;">
        <canvas ref="canvas" class="absolute inset-0 w-full h-full" style="width: 100%; height: 100%; display: block;"></canvas>
        
        <!-- Play button moved to controls menu -->
        
        <!-- Sleep Prevention Tip for iOS Slaves -->
        <div v-if="isSlave && isIOSDevice && !showSleepPreventionTip" 
             class="fixed bottom-6 left-6 right-6 z-50 apple-input px-3 py-2 rounded-lg border border-yellow-500 border-opacity-50">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-2">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-yellow-400">
                        <circle cx="12" cy="12" r="10"/>
                        <path d="M12 16v-4M12 8h.01"/>
                    </svg>
                    <span class="text-white text-xs">Prevent sleep: Settings â†’ Display â†’ Auto-Lock â†’ Never</span>
                </div>
                <button @click.stop="showSleepPreventionTip = true" class="text-white opacity-60 text-xs">More</button>
            </div>
        </div>
        
        <!-- Expanded Sleep Prevention Tip for Slaves -->
        <div v-if="isSlave && isIOSDevice && showSleepPreventionTip" 
             class="fixed bottom-6 left-6 right-6 z-50 apple-input px-3 py-3 rounded-lg border border-yellow-500 border-opacity-50">
            <div class="flex items-start justify-between mb-2">
                <div class="flex items-center space-x-2">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-yellow-400">
                        <circle cx="12" cy="12" r="10"/>
                        <path d="M12 16v-4M12 8h.01"/>
                    </svg>
                    <span class="text-white text-xs font-medium">Prevent iPhone Sleep</span>
                </div>
                <button @click.stop="showSleepPreventionTip = false" class="text-white opacity-60">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M18 6L6 18M6 6l12 12"/>
                    </svg>
                </button>
            </div>
            <div class="text-white text-xs opacity-80 leading-relaxed space-y-1">
                <p>To prevent your iPhone from sleeping:</p>
                <ol class="list-decimal list-inside space-y-0.5 ml-2">
                    <li>Open <strong>Settings</strong> app</li>
                    <li>Go to <strong>Display & Brightness</strong></li>
                    <li>Tap <strong>Auto-Lock</strong></li>
                    <li>Select <strong>Never</strong></li>
                </ol>
                <button @click.stop="openIOSSettings" 
                        class="mt-2 w-full apple-button px-3 py-1.5 rounded-lg text-white text-xs font-medium flex items-center justify-center space-x-2">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                        <polyline points="17 21 17 13 7 13 7 21"/>
                        <polyline points="7 3 7 8 15 8"/>
                    </svg>
                    <span>Open Settings</span>
                </button>
                <p class="text-yellow-300 text-xs mt-1">ðŸ’¡ Change it back after your session!</p>
            </div>
        </div>
        
        <!-- Sound Flake status indicator -->
        <div v-if="isSlave" class="fixed top-6 right-6 z-50 apple-button px-4 py-2 rounded-lg flex flex-col items-center space-y-1 min-w-[120px]">
            <div class="flex items-center space-x-2">
                <div class="w-3 h-3 rounded-full" :class="wsConnected && wsReceivedWelcome && assignedNotes && assignedNotes.length > 0 ? 'bg-green-400' : 'bg-red-400'"></div>
                <span class="text-white text-xs font-medium">{{ slaveName ? 'Sound Flake ' + slaveName : 'Sound Flake' }}</span>
            </div>
            <div class="text-white text-xs opacity-70 text-center">
                <div v-if="!ws">Initializing...</div>
                <div v-else-if="wsConnected && wsReceivedWelcome && assignedNotes && assignedNotes.length > 0">
                    {{ assignedNotes.length }} note{{ assignedNotes.length !== 1 ? 's' : '' }}
                </div>
                <div v-else-if="wsConnected && wsReceivedWelcome && (!assignedNotes || assignedNotes.length === 0)">Waiting for notes...</div>
                <div v-else-if="wsConnected && !wsReceivedWelcome">Connected, registering...</div>
                <div v-else-if="ws && ws.readyState === 2">Closing...</div>
                <div v-else-if="ws && ws.readyState === 3">Disconnected</div>
                <div v-else-if="ws && ws.readyState === 0">Connecting...</div>
                <div v-else-if="ws && ws.readyState === 1 && wsConnected">Connected</div>
                <div v-else>Connecting...</div>
            </div>
            <!-- Assigned Notes Display for Sound Flake -->
            <div v-if="isSlave && assignedNotes && assignedNotes.length > 0" class="mt-2 px-2">
                <div class="text-white text-xs opacity-70 mb-1 text-center">Assigned notes:</div>
                <div class="flex flex-wrap gap-1 justify-center">
                    <span 
                        v-for="note in assignedNotes" 
                        :key="note.note"
                        class="px-1.5 py-0.5 rounded text-xs font-mono inline-block"
                        :style="getPlayingNoteStyle(note, slaveCurrentlyPlayingNote === note.note)"
                        :class="{ 'note-playing': slaveCurrentlyPlayingNote === note.note }"
                    >
                        {{ note.note }}
                    </span>
                </div>
            </div>
            <!-- Status message -->
            <div v-if="slaveStatus" class="text-white text-xs mt-1 opacity-60 text-center">
                {{ slaveStatus }}
            </div>
            <!-- Error/Info display -->
            <div v-if="wsError" class="text-yellow-300 text-xs mt-2 max-w-[200px] break-words text-center font-semibold animate-pulse">
                {{ wsError }}
            </div>
        </div>
        
        <!-- Full-screen tap prompt for iOS - Show immediately when slave connects, before notes assigned -->
        <div v-if="isSlave && (!audioUnlocked() || (audioContext() && audioContext().state === 'suspended'))" 
             class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-90"
             @touchstart.prevent.stop="handleTapToStart"
             @touchend.prevent.stop="handleTapToStart"
             @click.prevent.stop="handleTapToStart"
             style="touch-action: manipulation;">
            <div class="bg-white rounded-2xl p-10 mx-6 text-center shadow-2xl animate-pulse">
                <div class="text-5xl mb-6">ðŸŽµ</div>
                <div class="text-3xl font-bold text-black mb-4">Tap to Activate Audio</div>
                <div class="text-lg text-gray-700 mb-2">Tap anywhere on the screen</div>
                <div class="text-sm text-gray-500">to enable automatic playback</div>
                <div v-if="assignedNotes.length > 0" class="text-xs text-gray-400 mt-4">Ready to play {{ assignedNotes.length }} note{{ assignedNotes.length !== 1 ? 's' : '' }}</div>
                <div v-else class="text-xs text-gray-400 mt-4">Waiting for master connection...</div>
            </div>
        </div>
        
        <!-- Right-side menu (master only) - always visible -->
        <div v-if="!isSlave" 
             class="fixed inset-0 z-40"
             style="pointer-events: none;">
            <div v-show="!showQRCode" class="absolute top-0 left-1/2 -translate-x-1/2 h-full w-full max-w-md backdrop-filter backdrop-blur-xl bg-black bg-opacity-60 shadow-2xl overflow-hidden flex flex-col"
                 style="pointer-events: auto; transition: none;">
                <!-- Header -->
                <div class="flex items-center justify-center px-4 py-2 border-b border-white border-opacity-10">
                    <div class="flex items-center gap-2">
                        <img src="/logo.jpg" alt="Soundflakes" class="w-8 h-8 rounded-full flex-shrink-0" id="logo-img" onerror="this.style.display='none';" onload="this.style.display='block';">
                        <div class="flex flex-col items-center">
                            <span class="text-white text-xs opacity-70" style="font-family: 'Be Vietnam Pro', sans-serif; font-weight: 300;">Stonewhistle presents:</span>
                            <h2 class="text-white text-lg font-bold tracking-tight" style="font-family: 'Be Vietnam Pro', sans-serif; font-weight: 700;">Soundflakes</h2>
                        </div>
                    </div>
                </div>
                
                <!-- Content -->
                <div class="overflow-y-auto flex-1 px-4 py-3 space-y-2">
                
                <!-- Sleep Prevention Tip for iOS -->
                <div v-if="isIOSDevice" class="mb-4 px-3 py-3 apple-input rounded-lg border border-yellow-500 border-opacity-50">
                    <div class="flex items-start justify-between mb-2">
                        <div class="flex items-center space-x-2">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-yellow-400">
                                <circle cx="12" cy="12" r="10"/>
                                <path d="M12 16v-4M12 8h.01"/>
                            </svg>
                            <span class="text-white text-sm font-medium">Prevent iPhone Sleep</span>
                        </div>
                        <button @click.stop="showSleepPreventionTip = !showSleepPreventionTip" class="text-white opacity-60 hover:opacity-100">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M18 6L6 18M6 6l12 12"/>
                            </svg>
                        </button>
                    </div>
                    <div v-if="showSleepPreventionTip" class="text-white text-xs opacity-80 leading-relaxed space-y-2">
                        <p>To prevent your iPhone from sleeping during playback:</p>
                        <ol class="list-decimal list-inside space-y-1 ml-2">
                            <li>Open <strong>Settings</strong> app</li>
                            <li>Go to <strong>Display & Brightness</strong></li>
                            <li>Tap <strong>Auto-Lock</strong></li>
                            <li>Select <strong>Never</strong></li>
                        </ol>
                        <button @click.stop="openIOSSettings" 
                                class="mt-3 w-full apple-button px-3 py-2 rounded-lg text-white text-xs font-medium flex items-center justify-center space-x-2">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                                <polyline points="17 21 17 13 7 13 7 21"/>
                                <polyline points="7 3 7 8 15 8"/>
                            </svg>
                            <span>Open Settings App</span>
                        </button>
                        <p class="text-yellow-300 text-xs mt-2">ðŸ’¡ Remember to change it back after your session to save battery!</p>
                    </div>
                    <div v-else class="text-white text-xs opacity-60 cursor-pointer" @click="showSleepPreventionTip = true">
                        Tap to see instructions â†’
                    </div>
                </div>
                
                <div class="grid grid-cols-5 gap-1 mb-6">
                    <div class="text-center">
                        <label class="text-white text-xs font-medium block mb-0.5 opacity-70">Play</label>
                        <button @click="togglePlayback" 
                                class="apple-button w-12 h-12 rounded-full flex items-center justify-center text-white transition-all duration-200 mx-auto"
                                :class="isPlaying ? 'button-pulse' : ''"
                                style="touch-action: manipulation;">
                            <svg v-if="!isPlaying" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-left: 2px;">
                                <path d="M8 5v14l11-7z"/>
                            </svg>
                            <svg v-else width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
                            </svg>
                        </button>
                    </div>
                    <div class="text-center">
                        <label class="text-white text-xs font-medium block mb-0.5 opacity-70">Length</label>
                        <svg-knob v-model="settings.noteLength" :min="2" :max="15" :step="0.1" unit="s"></svg-knob>
                    </div>
                    <div class="text-center">
                        <label class="text-white text-xs font-medium block mb-0.5 opacity-70">Pause</label>
                        <svg-knob v-model="settings.pauseLength" :min="0" :max="10" :step="0.1" unit="s"></svg-knob>
                    </div>
                    <div class="text-center">
                        <label class="text-white text-xs font-medium block mb-0.5 opacity-70">Volume</label>
                        <svg-knob v-model="settings.masterVolume" :min="0" :max="100" :step="1" unit="%"></svg-knob>
                    </div>
                    <div class="text-center">
                        <label class="text-white text-xs font-medium block mb-0.5 opacity-70">QR Code</label>
                        <button @click="showQRCode = !showQRCode" 
                                class="w-12 h-12 rounded-full flex items-center justify-center transition-all duration-200 mx-auto apple-button"
                                :class="showQRCode ? 'bg-blue-600' : ''">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="3" y="3" width="5" height="5"/>
                                <rect x="16" y="3" width="5" height="5"/>
                                <rect x="3" y="16" width="5" height="5"/>
                                <path d="M21 16h-3a2 2 0 0 0-2 2v3"/>
                                <path d="M16 8h2"/>
                                <path d="M8 16v2"/>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <!-- Sound Flakes Volume Controls -->
                <div v-if="!isSlave && (connectedSlaves.length > 0 || settings.masterIncluded)" class="mb-4 px-2 py-2 apple-input rounded-lg">
                    <div class="text-white text-sm font-medium mb-3 flex items-center justify-between">
                        <span>Sound Flakes Volumes</span>
                        <span class="text-white text-xs opacity-60">{{ displaySlaves.length }} connected</span>
                    </div>
                    
                    <!-- Master Flake - rendered separately with stable key to prevent slider jumping -->
                    <div v-if="settings.masterIncluded" class="mb-3 last:mb-0" :key="'master-flake-' + settings.masterIncluded">
                        <div class="flex items-center justify-between mb-1">
                            <span class="text-white text-xs opacity-80 font-medium">Sound Flake Master</span>
                            <span class="text-white text-xs opacity-60">{{ Math.round(masterVolume ?? 100) }}%</span>
                            <button @click="updateSlaveVolume('master', 50)" class="text-xs text-yellow-400 px-2 py-1 rounded">
                                Test: 50%
                            </button>
                        </div>
                        <input 
                            ref="masterSliderRef"
                            type="range" 
                            v-model.number="masterVolume"
                            @input="updateSlaveVolume('master', masterVolume)"
                            @mousedown.stop
                            @touchstart.stop
                            min="0" 
                            max="100" 
                            step="1"
                            class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider"
                            style="touch-action: manipulation;">
                        
                        <!-- Assigned Notes Display - separate to avoid re-rendering slider -->
                        <div v-if="masterAssignedNotes && masterAssignedNotes.length > 0" class="mt-2 text-xs">
                            <div class="text-white opacity-70 mb-1">Assigned notes:</div>
                            <div class="flex flex-wrap gap-1">
                                <span 
                                    v-for="note in masterAssignedNotes" 
                                    :key="note.note"
                                    class="px-1.5 py-0.5 rounded text-xs font-mono inline-block"
                                    :style="getPlayingNoteStyle(note, masterCurrentlyPlayingNote === note.note)"
                                    :class="{ 'note-playing': masterCurrentlyPlayingNote === note.note }"
                                    :data-note-color="note.color"
                                >
                                    {{ note.note }}
                                </span>
                            </div>
                        </div>
                        <div v-else class="mt-2 text-xs text-white opacity-50">
                            No notes assigned
                        </div>
                    </div>
                    
                    <!-- Regular Slaves -->
                    <div v-for="(slave, index) in connectedSlaves" :key="slave.id" class="mb-3 last:mb-0">
                        <div class="flex items-center justify-between mb-1">
                            <span class="text-white text-xs opacity-80 font-medium">Sound Flake {{ slave.name || (index + 1) }}</span>
                            <span class="text-white text-xs opacity-60">{{ getSlaveDisplayVolume(slave) }}%</span>
                            <button @click="updateSlaveVolume(slave.id, 50)" class="text-xs text-yellow-400 px-2 py-1 rounded">
                                Test: 50%
                            </button>
                        </div>
                        <input 
                            type="range" 
                            :value="slave.volume"
                            @input="updateSlaveVolume(slave.id, parseFloat($event.target.value))"
                            @mousedown.stop
                            @touchstart.stop
                            min="0" 
                            max="100" 
                            step="1"
                            class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider"
                            style="touch-action: manipulation;">
                        
                        <!-- Assigned Notes Display -->
                        <div v-if="slave.assignedNotes && slave.assignedNotes.length > 0" class="mt-2 text-xs">
                            <div class="text-white opacity-70 mb-1">Assigned notes:</div>
                            <div class="flex flex-wrap gap-1">
                                <span 
                                    v-for="note in slave.assignedNotes" 
                                    :key="note.note"
                                    class="px-1.5 py-0.5 rounded text-xs font-mono inline-block"
                                    :style="getPlayingNoteStyle(note, slave.currentlyPlayingNote === note.note)"
                                    :class="{ 'note-playing': slave.currentlyPlayingNote === note.note }"
                                    :data-note-color="note.color"
                                >
                                    {{ note.note }}
                                </span>
                            </div>
                        </div>
                        <div v-else class="mt-2 text-xs text-white opacity-50">
                            No notes assigned
                        </div>
                    </div>
                </div>
                
                <!-- Master Included Toggle -->
                <div class="mb-4 px-2 py-2 apple-input rounded-lg">
                    <div class="flex items-center justify-between">
                        <div>
                            <label class="text-white text-sm font-medium block">Master Included</label>
                            <p class="text-white text-xs opacity-60 mt-0.5">Include master in note distribution</p>
                        </div>
                        <button @click.stop.prevent="() => { console.log('BUTTON CLICKED DIRECTLY'); toggleMasterIncluded(); }"
                                @mousedown.stop.prevent
                                @touchstart.stop.prevent
                                class="apple-button px-4 py-2 rounded-lg text-white text-sm font-medium transition-all"
                                :class="settings.masterIncluded ? 'bg-green-500' : 'bg-gray-600'"
                                style="touch-action: manipulation; -webkit-tap-highlight-color: transparent; z-index: 100;">
                            {{ settings.masterIncluded ? 'ON' : 'OFF' }}
                    </button>
                </div>
                </div>
                
                <div class="space-y-1">
                    <div v-for="(note, idx) in noteData" :key="idx" class="flex items-center space-x-2 px-2 py-1.5 apple-input" :style="{ borderLeft: '2px solid ' + note.color }">
                        <div class="w-2.5 h-2.5 rounded-full flex-shrink-0" :style="{ backgroundColor: note.color }"></div>
                        <span class="text-white text-xs font-medium w-10">{{ note.note }}</span>
                        <input type="range" v-model.number="note.volume" min="0" max="100" class="flex-1 h-1 rounded-lg appearance-none" :style="{ background: `linear-gradient(to right, ${note.color} 0%, ${note.color} ${note.volume}%, rgba(255,255,255,0.1) ${note.volume}%, rgba(255,255,255,0.1) 100%)` }">
                        <span class="text-white text-xs w-7 text-right">{{ note.volume }}%</span>
                        <button @click="note.enabled = !note.enabled" class="apple-button-secondary px-2 py-1 text-xs font-medium" :class="note.enabled ? 'text-white' : 'text-gray-400'">{{ note.enabled ? 'ON' : 'OFF' }}</button>
                    </div>
                </div>
                <div class="space-y-1.5 apple-input px-2.5 py-2">
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-white text-xs font-medium">{{ currentPaletteName }}</span>
                        <button @click="showPaletteEditor = !showPaletteEditor" class="apple-button-secondary px-2 py-0.5 text-white text-xs font-medium">
                            {{ showPaletteEditor ? 'Hide' : 'Edit' }}
                    </button>
                </div>
                    <div class="flex space-x-1.5">
                        <button @click="savePreset" class="flex-1 apple-button-secondary px-2 py-1.5 text-white text-xs font-medium">Save Preset</button>
                        <button @click="loadPreset" class="flex-1 apple-button-secondary px-2 py-1.5 text-white text-xs font-medium">Load</button>
                        <button @click="settings.referencePitch = 432" 
                                class="flex-1 px-2 py-1.5 rounded-lg text-xs font-medium transition-all"
                                :class="settings.referencePitch === 432 ? 'apple-button bg-blue-600 text-white' : 'apple-button-secondary text-white opacity-60'">
                            432 Hz
                        </button>
                        <button @click="settings.referencePitch = 440" 
                                class="flex-1 px-2 py-1.5 rounded-lg text-xs font-medium transition-all"
                                :class="settings.referencePitch === 440 ? 'apple-button bg-blue-600 text-white' : 'apple-button-secondary text-white opacity-60'">
                            440 Hz
                        </button>
                </div>
                    <div v-if="showPaletteEditor" class="space-y-1.5 pt-2 border-t border-white border-opacity-10 mt-2">
                        <div class="text-white text-xs font-medium mb-1 opacity-70">Notes ({{ noteData.length }})</div>
                        <div class="max-h-32 overflow-y-auto space-y-1 mb-2">
                            <div v-for="(note, idx) in noteData" :key="idx" class="flex items-center space-x-2 px-2 py-1.5 apple-input">
                                <div class="w-2.5 h-2.5 rounded-full flex-shrink-0" :style="{ backgroundColor: note.color }"></div>
                                <input v-model="note.note" @input="updateNoteFrequency(idx)" class="apple-input w-14 px-1.5 py-1 text-white text-xs" maxlength="4" placeholder="Note">
                                <input v-model.number="note.freq" type="number" @input="updateNoteFrequency(idx)" class="apple-input w-18 px-1.5 py-1 text-white text-xs" step="0.01" min="50" max="2000" placeholder="Hz">
                                <button @click="removeNote(idx)" class="ml-auto apple-button-secondary w-6 h-6 rounded-full flex items-center justify-center text-white text-xs leading-none">Ã—</button>
                </div>
                            <div v-if="noteData.length === 0" class="text-gray-400 text-xs text-center py-3 opacity-50">No notes</div>
            </div>
                        <div class="flex space-x-1">
                            <input v-model="newNoteName" @input="calculateFrequency" placeholder="E4" class="apple-input flex-1 px-2 py-1 text-white text-xs" maxlength="4">
                            <input v-model.number="newNoteFreq" type="number" placeholder="Hz" class="apple-input w-18 px-2 py-1 text-white text-xs" step="0.01" min="50" max="2000">
                            <button @click="addNote" class="apple-button-secondary px-2 py-1 text-white text-xs font-medium">Add</button>
                </div>
                        <div class="flex space-x-1">
                            <button @click="createNewPalette" class="flex-1 apple-button-secondary px-2 py-1 text-white text-xs font-medium">New</button>
                            <button @click="saveCurrentPalette" class="flex-1 apple-button-secondary px-2 py-1 text-white text-xs font-medium">Save</button>
                            <button @click="loadPalette" class="flex-1 apple-button-secondary px-2 py-1 text-white text-xs font-medium">Load</button>
                </div>
                    </div>
                </div>
                </div>
                <!-- QR Code section hidden by default -->
                <div v-if="showQRCode" class="px-4 pb-3 flex-1 flex flex-col min-h-0">
                    <div class="text-center px-3 py-2 apple-input border-dashed flex-1 flex flex-col items-center justify-center min-h-0">
                        <div class="text-white text-xs font-medium mb-2 opacity-70">QR Code for Slaves</div>
                        <div class="apple-input flex items-center justify-center flex-1 w-full max-w-full aspect-square p-2" style="min-height: 0;" ref="qrCanvas">
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Fullscreen QR Code Overlay -->
        <div v-if="showQRCode && !isSlave" 
             class="fixed inset-0 z-[100] bg-black bg-opacity-95 flex items-center justify-center"
             @click.self="showQRCode = false"
             style="touch-action: manipulation;">
            <div class="relative w-full h-full flex flex-col items-center justify-center p-8">
                <button @click.stop.prevent="showQRCode = false" 
                        class="absolute top-4 right-4 w-12 h-12 rounded-full flex items-center justify-center text-white bg-gray-800 hover:bg-gray-700 transition-all duration-200 z-20"
                        style="touch-action: manipulation; cursor: pointer;">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
                <div class="text-white text-lg font-medium mb-4">QR Code for Slaves</div>
                <div class="flex items-center justify-center w-full max-w-md aspect-square p-8 bg-white rounded-lg" ref="qrCanvasFullscreen">
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, reactive, computed, onMounted, onUnmounted, watch } = Vue;
        const SvgKnob = {
            props: ['modelValue', 'min', 'max', 'step', 'unit'],
            emits: ['update:modelValue'],
            template: `<div class="knob mx-auto" 
                @mousedown="onPointerStart" 
                @touchstart="onPointerStart"
                ref="knobElement">
                <svg viewBox="0 0 60 60" class="w-full h-full"><circle cx="30" cy="30" r="25" fill="none" stroke="#444" stroke-width="4"/>
                <line x1="30" y1="30" x2="30" y2="8" stroke="#fff" stroke-width="3" stroke-linecap="round" :transform="\`rotate(\${angle} 30 30)\`"/></svg>
                <div class="text-white text-xs text-center mt-1">{{ displayValue }}{{ unit }}</div>
            </div>`,
            setup(props, { emit }) {
                const knobElement = ref(null);
                
                const angle = computed(() => {
                    const normalized = (props.modelValue - props.min) / (props.max - props.min);
                    return normalized * 270 - 135;
                });
                const displayValue = computed(() => {
                    if (props.step < 1) return props.modelValue.toFixed(1);
                    return Math.round(props.modelValue);
                });
                
                let startY = 0;
                let startValue = 0;
                let isActive = false;
                
                const updateValue = (clientY) => {
                    const deltaY = startY - clientY;
                    const range = props.max - props.min;
                    const sensitivity = 100;
                    const newValue = startValue + (deltaY / sensitivity) * range;
                    const clamped = Math.max(props.min, Math.min(props.max, newValue));
                    const stepped = Math.round(clamped / props.step) * props.step;
                    
                    if (Math.abs(stepped - props.modelValue) > 0.001) {
                        emit('update:modelValue', stepped);
                    }
                };
                
                const onMove = (e) => {
                    if (!isActive) return;
                    e.preventDefault();
                    e.stopPropagation();
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    updateValue(clientY);
                };
                
                const onEnd = () => {
                    if (!isActive) return;
                    isActive = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                    document.removeEventListener('touchcancel', onEnd);
                };
                
                const onPointerStart = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    isActive = true;
                    
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    startY = clientY;
                    startValue = props.modelValue;
                    
                    if (e.touches) {
                        document.addEventListener('touchmove', onMove, { passive: false });
                        document.addEventListener('touchend', onEnd);
                        document.addEventListener('touchcancel', onEnd);
                    } else {
                        document.addEventListener('mousemove', onMove);
                        document.addEventListener('mouseup', onEnd);
                    }
                };
                
                return { angle, displayValue, onPointerStart, knobElement };
            }
        };

        createApp({
            components: { SvgKnob },
            setup() {
                const canvas = ref(null); const ctx = ref(null); const isPlaying = ref(false);
                // Check URL parameter to determine if slave (before isSlave is defined)
                const urlParamsCheck = new URLSearchParams(window.location.search);
                const isSlaveCheck = urlParamsCheck.get('slave') === 'true';
                const showControls = ref(!isSlaveCheck); // Always true for master (menu always visible)
                const qrCanvas = ref(null);
                const qrCanvasFullscreen = ref(null);
                const showQRCode = ref(false); // Show/hide QR code in fullscreen - always starts false
                const isFullscreen = ref(false); // Track fullscreen state
                const showSleepPreventionTip = ref(false); // Show sleep prevention tip
                
                // Detect iOS device
                const isIOSDevice = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                                   (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                
                // Function to show iOS Settings instructions
                // Note: Web apps cannot directly open iOS Settings due to security restrictions
                const openIOSSettings = () => {
                    // Show clear instructions since we can't open Settings directly
                    const instructions = `To prevent your iPhone from sleeping:

1. Press the Home button (or swipe up) to exit this app
2. Open the Settings app
3. Go to Display & Brightness
4. Tap Auto-Lock
5. Select Never
6. Return to this app

ðŸ’¡ Remember to change it back after your session to save battery!`;
                    
                    alert(instructions);
                };
                
                // Method to open menu
                const openMenu = (e) => {
                    console.log('openMenu called, event:', e);
                    console.log('current showControls:', showControls.value);
                    console.log('current isSlave:', isSlave);
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    showControls.value = true;
                    console.log('showControls set to:', showControls.value);
                };
                
                // Method to close menu
                const closeMenu = (e) => {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    console.log('closeMenu called, current showControls:', showControls.value);
                    showControls.value = false;
                    console.log('showControls set to:', showControls.value);
                };
                
                // Method to toggle menu (for backwards compatibility)
                const toggleMenu = (e) => {
                    if (showControls.value) {
                        closeMenu(e);
                    } else {
                        openMenu(e);
                    }
                };
                const settings = reactive({ noteLength: 5, pauseLength: 5, masterVolume: 70, vizMode: 'rotate', numGenerators: 3, masterMuted: false, masterIncluded: true, referencePitch: 440 });
                const masterAssignedNotes = ref([]); // Notes assigned to master
                const masterCurrentlyPlayingNote = ref(null); // Currently playing note on master
                const masterVolume = ref(100); // Master volume when included (separate from masterVolume setting)
                const masterSliderRef = ref(null); // Ref to master slider element
                const totalSlaves = ref(0); // Track total number of connected slaves (for master)
                const connectedSlaves = reactive([]); // Track individual slaves with their IDs, names, and volumes
                const slaveName = ref(null); // Slave's own name (for slave devices)
                const slaveVolume = ref(100); // Per-slave volume (for slave devices, default 100%)
                const slaveCurrentlyPlayingNote = ref(null); // Currently playing note on slave (for animation)
                
                // Computed property to display slaves including master when included
                // Note: We don't include masterVolume.value in the computed to avoid re-renders when slider moves
                const displaySlaves = computed(() => {
                    const slaves = [...connectedSlaves];
                    if (settings.masterIncluded) {
                        slaves.unshift({
                            id: 'master',
                            name: 'Master',
                            volume: 100, // Placeholder - actual value comes from masterVolume.value directly
                            assignedNotes: masterAssignedNotes.value,
                            currentlyPlayingNote: masterCurrentlyPlayingNote.value
                        });
                    }
                    return slaves;
                });
                
                // Debounce timers for slave volume updates (per slave)
                const slaveVolumeTimeouts = {};
                
                // Helper function to get display volume for a slave
                const getSlaveDisplayVolume = (slave) => {
                    if (slave.id === 'master') {
                        const vol = masterVolume.value;
                        return (vol !== null && vol !== undefined && !isNaN(vol)) ? Math.round(vol) : 100;
                    }
                    const vol = slave.volume;
                    return (vol !== null && vol !== undefined && !isNaN(vol)) ? Math.round(vol) : 100;
                };
                
                // Helper function to check if a color is dark
                const isDarkColor = (color) => {
                    const darkColors = ['#1e3a8a', '#4f46e5', '#9333ea'];
                    return darkColors.includes(color.toLowerCase());
                };
                
                // Helper function to get playing note style
                const getPlayingNoteStyle = (note, isPlaying) => {
                    if (!isPlaying) {
                        return {
                            backgroundColor: note.color + '40',
                            color: note.color,
                            border: '1px solid ' + note.color + '80',
                            boxSizing: 'border-box'
                        };
                    }
                    
                    // For playing notes, use white background with colored text for dark colors
                    // Keep border width the same (1px) to prevent size change, use box-shadow for emphasis
                    // Note: boxShadow glow is handled by CSS animation (.note-playing class)
                    if (isDarkColor(note.color)) {
                        return {
                            backgroundColor: '#ffffff',
                            color: note.color,
                            border: '1px solid ' + note.color,
                            boxSizing: 'border-box',
                            transition: 'all 0.2s ease-out'
                        };
                    } else {
                        return {
                            backgroundColor: note.color,
                            color: '#ffffff',
                            border: '1px solid ' + note.color,
                            boxSizing: 'border-box',
                            transition: 'all 0.2s ease-out'
                        };
                    }
                };
                
                // Track previous master volume for scaling calculations
                let previousMasterVolume = masterVolume.value;
                let masterVolumeLocked = false; // Lock to prevent resets
                
                // Watch masterVolume to detect unauthorized resets
                watch(masterVolume, (newVal, oldVal) => {
                    if (masterVolumeLocked && oldVal !== undefined && newVal === 100 && oldVal !== 100) {
                        console.warn(`âš ï¸ Master volume was reset to 100! Old value: ${oldVal}, preventing reset...`);
                        masterVolume.value = oldVal; // Restore old value
                        return;
                    }
                });
                
                // Function to update slave volume
                const updateSlaveVolume = (slaveId, volume) => {
                    // Handle master flake volume separately (when master is included as a flake)
                    if (slaveId === 'master') {
                        masterVolumeLocked = true; // Lock to prevent resets
                        
                        // Update volume immediately in the UI to prevent slider jumping (same pattern as slave sliders)
                        masterVolume.value = volume;
                        
                        const oldVolume = previousMasterVolume;
                        previousMasterVolume = volume; // Update tracked value
                        
                        console.log(`Master flake volume updated: ${oldVolume}% â†’ ${volume}%`);
                        
                        // Update volume of currently playing master notes in real-time
                        // Only do this if audio is actually playing and volume changed
                        if (!isSlave && settings.masterIncluded && audioContext && audioContext.state === 'running' && oldVolume !== volume && isPlaying.value) {
                            const now = audioContext.currentTime;
                            const scaleFactor = oldVolume > 0 ? volume / oldVolume : volume / 100; // Scale factor based on volume change
                            
                            // Update all active oscillators for master
                            activeOscillators.forEach(osc => {
                                if (osc._oscGain && osc._startTime && osc._duration) {
                                    // Calculate current time in note's timeline
                                    const elapsed = now - osc._startTime;
                                    const remaining = osc._duration - elapsed;
                                    
                                    if (remaining > 0 && elapsed >= 0) {
                                        // Get current gain value
                                        osc._oscGain.gain.cancelScheduledValues(now);
                                        const currentGain = osc._oscGain.gain.value;
                                        
                                        // Scale gain by the volume change factor
                                        const newGain = Math.max(0, Math.min(0.5, currentGain * scaleFactor));
                                        
                                        // Apply new gain smoothly
                                        osc._oscGain.gain.setTargetAtTime(newGain, now, 0.05);
                                        console.log(`Updated master oscillator gain: ${currentGain.toFixed(4)} â†’ ${newGain.toFixed(4)} (scale: ${scaleFactor.toFixed(2)})`);
                                    }
                                }
                            });
                        }
                        
                        // Note: This doesn't affect settings.masterVolume - it's a separate control
                        // The master flake volume is applied in playNote when master is included
                        return;
                    }
                    
                    if (!slaveId || !ws.value || ws.value.readyState !== WebSocket.OPEN) {
                        return;
                    }
                    
                    const slave = connectedSlaves.find(s => s.id === slaveId);
                    if (!slave) {
                        return;
                    }
                    
                    // Update volume immediately in the UI to prevent slider jumping
                    slave.volume = volume;
                    
                    // Clear any pending update
                    if (slaveVolumeTimeouts[slaveId]) {
                        clearTimeout(slaveVolumeTimeouts[slaveId]);
                    }
                    
                    // Debounce slider updates to prevent rapid sends
                    slaveVolumeTimeouts[slaveId] = setTimeout(() => {
                        try {
                            ws.value.send(JSON.stringify({
                                type: 'slave_volume',
                                slaveId: String(slaveId),
                                volume: parseInt(volume)
                            }));
                            
                            // DON'T call sendPresetToSlaves() here - it causes conflicts
                            // The volume update is immediate, preset update happens separately
                        } catch (e) {
                            console.error('Error sending volume update:', e);
                        }
                        
                        delete slaveVolumeTimeouts[slaveId];
                    }, 150);
                };
                const noteData = reactive([
                    { note: 'G3', freq: 196.00, color: '#1e3a8a', volume: 80, enabled: true },
                    { note: 'Bb3', freq: 233.08, color: '#4f46e5', volume: 75, enabled: true },
                    { note: 'C4', freq: 261.63, color: '#9333ea', volume: 75, enabled: true },
                    { note: 'Eb4', freq: 311.13, color: '#ec4899', volume: 70, enabled: true },
                    { note: 'F4', freq: 349.23, color: '#ef4444', volume: 70, enabled: true },
                    { note: 'G4', freq: 392.00, color: '#f97316', volume: 65, enabled: true },
                    { note: 'Bb4', freq: 466.16, color: '#f59e0b', volume: 65, enabled: true },
                    { note: 'C5', freq: 523.25, color: '#10b981', volume: 60, enabled: true },
                    { note: 'D5', freq: 587.33, color: '#06b6d4', volume: 60, enabled: true }
                ]);
                
                const currentPaletteName = ref('Default');
                const showPaletteEditor = ref(false);
                const newNoteName = ref('');
                const newNoteFreq = ref(null);
                
                const colors = ['#1e3a8a', '#4f46e5', '#9333ea', '#ec4899', '#ef4444', '#f97316', '#f59e0b', '#10b981', '#06b6d4', '#3b82f6', '#8b5cf6', '#ec4899'];
                
                let audioContext = null; let masterGain = null;
                const activeOscillators = new Set(); 
                const generatorTimeouts = reactive([]);
                const generatorNoteEndTimes = reactive([]); // Track when each generator's current note ends (for overlap prevention)
                const generatorOscillators = reactive([]); // Track oscillators per generator (array of Sets)
                let lastNoteEndTime = 0; // Track when the last note ended globally (for overlap prevention across all generators)
                let isNotePlaying = false; // Lock to prevent multiple notes from starting simultaneously when overlap is off
                const particles = reactive([]); let rotation = 0;
                let droneOscillator = null; // Continuous inaudible drone to keep audio context active
                let droneGain = null; // Gain node for the drone (for smooth fade-out)
                let wakeLock = null; // Screen wake lock to prevent device sleep
                let wakeLockRetryInterval = null; // Interval to retry wake lock if released
                
                // Function to request fullscreen mode (helps prevent sleep on some devices)
                // This requires user interaction, so we'll call it from a button click
                // iOS Safari has limited fullscreen support, but we'll try multiple methods
                const requestFullscreenMode = async () => {
                    try {
                        const element = document.documentElement;
                        let success = false;
                        
                        // Try standard fullscreen API first
                        if (element.requestFullscreen) {
                            try {
                                await element.requestFullscreen();
                                success = true;
                            } catch (e) {
                                console.log('Standard fullscreen failed:', e.message);
                            }
                        }
                        
                        // Try webkit fullscreen (iOS Safari)
                        if (!success && element.webkitRequestFullscreen) {
                            try {
                                await element.webkitRequestFullscreen();
                                success = true;
                            } catch (e) {
                                console.log('Webkit fullscreen failed:', e.message);
                            }
                        }
                        
                        // Try webkitEnterFullscreen (older iOS)
                        if (!success && element.webkitEnterFullscreen) {
                            try {
                                element.webkitEnterFullscreen();
                                success = true;
                            } catch (e) {
                                console.log('WebkitEnterFullscreen failed:', e.message);
                            }
                        }
                        
                        // iOS Safari doesn't support fullscreen API for web pages
                        // But we can still activate wake lock and keep-alive mechanisms
                        // Check if iOS (iPhone specifically)
                        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                                     (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                        const isIPhone = /iPhone/.test(navigator.userAgent);
                        
                        if (isIOS && !success) {
                            console.log('âš ï¸ iOS detected - fullscreen API not supported, but activating keep-alive mechanisms...');
                            
                            // On iOS, fullscreen doesn't work, but we can activate all keep-alive mechanisms:
                            // 1. Ensure wake lock is active
                            requestWakeLock();
                            
                            // 2. Ensure keep-alive video is playing (critical for iOS)
                            if (typeof createKeepAliveVideo === 'function') {
                                const video = createKeepAliveVideo();
                                if (video) {
                                    video.play().catch(() => {
                                        // If play fails, recreate video
                                        if (video.parentNode) {
                                            video.remove();
                                        }
                                        createKeepAliveVideo();
                                    });
                                } else {
                                    createKeepAliveVideo();
                                }
                            }
                            
                            // 3. Ensure drone note is running
                            if (audioContext && audioContext.state === 'running' && !droneOscillator) {
                                startDroneNote();
                                if (typeof enhanceDroneForIOS === 'function') {
                                    setTimeout(() => enhanceDroneForIOS(), 100);
                                }
                            }
                            
                            // 4. For iPhone specifically, show visual feedback that keep-alive is active
                            if (isIPhone) {
                                // Update button to show it's "active" even though not in fullscreen
                                // We'll use a different visual state
                                console.log('âœ“ iPhone keep-alive mechanisms activated (fullscreen not available on iOS Safari)');
                                // Show a brief visual feedback
                                const button = document.getElementById('fullscreen-button');
                                if (button) {
                                    button.classList.add('bg-green-500');
                                    setTimeout(() => {
                                        button.classList.remove('bg-green-500');
                                    }, 2000);
                                }
                            }
                            
                            // Note: We don't set success = true because fullscreen didn't actually activate
                            // But all keep-alive mechanisms are now active to help prevent sleep
                        }
                        
                        // Try moz/ms fallbacks
                        if (!success && element.mozRequestFullScreen) {
                            try {
                                await element.mozRequestFullScreen();
                                success = true;
                            } catch (e) {
                                console.log('Moz fullscreen failed:', e.message);
                            }
                        }
                        
                        if (!success && element.msRequestFullscreen) {
                            try {
                                await element.msRequestFullscreen();
                                success = true;
                            } catch (e) {
                                console.log('MS fullscreen failed:', e.message);
                            }
                        }
                        
                        if (success) {
                            console.log('âœ“ Fullscreen mode activated (helps prevent sleep)');
                        } else {
                            console.log('âš ï¸ Fullscreen not available on this device/browser');
                            // If fullscreen fails, at least try to keep wake lock active
                            requestWakeLock();
                        }
                        return success;
                    } catch (e) {
                        console.log('Fullscreen error:', e.message);
                        // If fullscreen fails, at least try to keep wake lock active
                        requestWakeLock();
                        return false;
                    }
                };
                
                // Function to exit fullscreen
                const exitFullscreenMode = async () => {
                    try {
                        let exited = false;
                        
                        // Check current fullscreen state
                        const isCurrentlyFullscreen = !!(
                            document.fullscreenElement || 
                            document.webkitFullscreenElement || 
                            document.mozFullScreenElement ||
                            document.msFullscreenElement
                        );
                        
                        if (!isCurrentlyFullscreen) {
                            console.log('Not in fullscreen mode');
                            // Update state anyway
                            isFullscreen.value = false;
                            return;
                        }
                        
                        // Try standard exitFullscreen
                        if (document.exitFullscreen) {
                            try {
                                await document.exitFullscreen();
                                exited = true;
                                console.log('âœ“ Exited fullscreen (standard API)');
                            } catch (e) {
                                console.log('Standard exitFullscreen failed:', e.message);
                            }
                        }
                        
                        // Try webkit exitFullscreen (iOS Safari)
                        if (!exited && document.webkitExitFullscreen) {
                            try {
                                await document.webkitExitFullscreen();
                                exited = true;
                                console.log('âœ“ Exited fullscreen (webkit API)');
                            } catch (e) {
                                console.log('Webkit exitFullscreen failed:', e.message);
                            }
                        }
                        
                        // Try webkit cancelFullScreen (alternative iOS method)
                        if (!exited && document.webkitCancelFullScreen) {
                            try {
                                await document.webkitCancelFullScreen();
                                exited = true;
                                console.log('âœ“ Exited fullscreen (webkitCancelFullScreen)');
                            } catch (e) {
                                console.log('Webkit cancelFullScreen failed:', e.message);
                            }
                        }
                        
                        // Try moz exitFullscreen
                        if (!exited && document.mozCancelFullScreen) {
                            try {
                                await document.mozCancelFullScreen();
                                exited = true;
                                console.log('âœ“ Exited fullscreen (moz API)');
                            } catch (e) {
                                console.log('Moz exitFullscreen failed:', e.message);
                            }
                        }
                        
                        // Try ms exitFullscreen
                        if (!exited && document.msExitFullscreen) {
                            try {
                                await document.msExitFullscreen();
                                exited = true;
                                console.log('âœ“ Exited fullscreen (ms API)');
                            } catch (e) {
                                console.log('MS exitFullscreen failed:', e.message);
                            }
                        }
                        
                        // For iOS video fullscreen, try to exit by removing video or calling exitFullscreen on video
                        if (!exited) {
                            const fullscreenVideo = document.querySelector('video[style*="z-index: 9999"]');
                            if (fullscreenVideo) {
                                try {
                                    // Try to exit video fullscreen
                                    if (fullscreenVideo.webkitExitFullscreen) {
                                        fullscreenVideo.webkitExitFullscreen();
                                    }
                                    fullscreenVideo.remove();
                                    exited = true;
                                    console.log('âœ“ Removed fullscreen video element');
                                } catch (e) {
                                    console.log('Video exit failed:', e.message);
                                }
                            }
                        }
                        
                        // Force update state
                        isFullscreen.value = false;
                        
                        if (exited) {
                            console.log('âœ“ Exited fullscreen mode');
                        } else {
                            console.log('âš ï¸ Could not exit fullscreen - user may need to use device controls');
                            // On iOS, sometimes user needs to use device controls
                            // But we'll still update our state
                            isFullscreen.value = false;
                        }
                    } catch (e) {
                        console.log('Exit fullscreen error:', e.message);
                        // Force update state even on error
                        isFullscreen.value = false;
                    }
                };
                
                // Track fullscreen state changes
                const updateFullscreenState = () => {
                    isFullscreen.value = !!(
                        document.fullscreenElement || 
                        document.webkitFullscreenElement || 
                        document.mozFullScreenElement ||
                        document.msFullscreenElement ||
                        document.querySelector('video[style*="z-index: 9999"]')
                    );
                };
                
                document.addEventListener('fullscreenchange', updateFullscreenState);
                document.addEventListener('webkitfullscreenchange', updateFullscreenState);
                document.addEventListener('webkitendfullscreen', updateFullscreenState); // iOS specific
                document.addEventListener('mozfullscreenchange', updateFullscreenState);
                document.addEventListener('MSFullscreenChange', updateFullscreenState);
                
                // Also check periodically for iOS (sometimes events don't fire)
                setInterval(() => {
                    if (isFullscreen.value) {
                        const actuallyFullscreen = !!(
                            document.fullscreenElement || 
                            document.webkitFullscreenElement || 
                            document.mozFullScreenElement ||
                            document.msFullscreenElement
                        );
                        if (!actuallyFullscreen) {
                            isFullscreen.value = false;
                        }
                    }
                }, 1000);
                
                // Function to request/re-request wake lock to prevent device sleep
                let wakeLockLogCount = 0; // Track wake lock log frequency
                let wakeLockReleaseHandler = null; // Store handler to avoid duplicates
                const requestWakeLock = async () => {
                    if ('wakeLock' in navigator) {
                        try {
                            // Release existing lock if any
                            if (wakeLock) {
                                // Remove old event listener if it exists
                                if (wakeLockReleaseHandler) {
                                    wakeLock.removeEventListener('release', wakeLockReleaseHandler);
                                    wakeLockReleaseHandler = null;
                                }
                                await wakeLock.release();
                                wakeLock = null;
                            }
                            
                            // Request new wake lock
                            wakeLock = await navigator.wakeLock.request('screen');
                            // Disable logging to reduce console spam - wake lock is working silently
                            wakeLockLogCount++;
                            
                            // Create release handler only once
                            if (!wakeLockReleaseHandler) {
                                wakeLockReleaseHandler = () => {
                                    // Disable logging - wake lock is working silently
                                    wakeLockLogCount++;
                                    // Re-request if still playing
                                    if (isPlaying.value) {
                                        setTimeout(() => requestWakeLock(), 100);
                                    }
                                };
                                wakeLock.addEventListener('release', wakeLockReleaseHandler);
                            }
                        } catch (e) {
                            // Only log errors, not every attempt
                            if (wakeLockLogCount === 0) {
                                console.log('Wake lock not available:', e.message);
                            }
                            wakeLockLogCount++;
                            // iOS doesn't support wake lock API, but we'll keep trying
                            // The drone note and audio playback help keep device awake
                        }
                    } else {
                        // Only log once
                        if (wakeLockLogCount === 0) {
                            console.log('Wake Lock API not supported (e.g., iOS Safari)');
                        }
                        wakeLockLogCount++;
                        // iOS doesn't support wake lock, but continuous audio helps
                    }
                };
                
                const initAudio = async () => {
                    console.log('initAudio called, audioContext exists:', !!audioContext);
                    if (!audioContext) {
                        try {
                            console.log('Creating new audio context...');
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        masterGain = audioContext.createGain();
                            masterGain.gain.value = settings.masterMuted ? 0 : settings.masterVolume / 100;
                        masterGain.connect(audioContext.destination);
                            console.log('Audio context created, state:', audioContext.state);
                        } catch (e) {
                            console.error('Failed to create audio context:', e);
                            throw e;
                        }
                    }
                    console.log('Audio context state before resume check:', audioContext.state);
                    if (audioContext.state === 'suspended') {
                        try {
                            console.log('Attempting to resume audio context...');
                            // Add timeout to prevent hanging on iOS
                            const resumePromise = audioContext.resume();
                            const timeoutPromise = new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('Resume timeout')), 1000)
                            );
                            await Promise.race([resumePromise, timeoutPromise]);
                            console.log('Audio context resumed, state:', audioContext.state);
                        } catch (e) {
                            // Resume failed or timed out - this is expected without user interaction
                            // Don't throw, just log and let the caller handle it
                            console.log('Audio context resume failed/timed out (user interaction required):', e.message);
                            // Return the context anyway - it's created but suspended
                        }
                    }
                    // Ensure master gain is set (respect mute setting)
                    if (masterGain) {
                        const effectiveVolume = settings.masterMuted ? 0 : settings.masterVolume / 100;
                        masterGain.gain.value = effectiveVolume;
                        console.log('Master gain set to:', effectiveVolume);
                    }
                    console.log('initAudio returning, audioContext state:', audioContext?.state);
                    return audioContext;
                };
                
                // Setup MediaSession API for better background audio support on mobile
                // This helps iOS/Android recognize the app as playing audio and may keep it alive longer
                const setupMediaSession = () => {
                    if ('mediaSession' in navigator) {
                        try {
                            navigator.mediaSession.metadata = new MediaMetadata({
                                title: 'Soundflakes',
                                artist: 'Generative Sound',
                                album: 'Live Performance'
                            });
                            
                            // Set up action handlers
                            navigator.mediaSession.setActionHandler('play', () => {
                                if (!isPlaying.value && audioContext) {
                                    audioContext.resume().then(() => {
                                        togglePlayback();
                                    });
                                }
                            });
                            
                            navigator.mediaSession.setActionHandler('pause', () => {
                                if (isPlaying.value) {
                                    togglePlayback();
                                }
                            });
                            
                            // Update playback state
                            navigator.mediaSession.playbackState = isPlaying.value ? 'playing' : 'paused';
                            
                            console.log('âœ“ MediaSession API configured for background audio support');
                        } catch (e) {
                            console.log('MediaSession API not fully supported:', e.message);
                        }
                    }
                };
                
                // Update MediaSession playback state
                const updateMediaSessionState = () => {
                    if ('mediaSession' in navigator) {
                        try {
                            navigator.mediaSession.playbackState = isPlaying.value ? 'playing' : 'paused';
                        } catch (e) {
                            // Ignore errors
                        }
                    }
                };
                
                // Start continuous inaudible drone note (4 Hz, very quiet) to keep audio context active
                // This prevents iOS Safari from suspending audio and keeps devices awake
                // Works for both master and slaves
                const startDroneNote = () => {
                    if (droneOscillator) {
                        console.log('Drone note already running');
                        return; // Already started
                    }
                    if (!audioContext || !masterGain) {
                        console.log('Cannot start drone note - audio context not ready');
                        return;
                    }
                    if (audioContext.state !== 'running') {
                        console.log('Cannot start drone note - audio context not running');
                        return;
                    }
                    
                    try {
                        console.log('ðŸŽµ Starting inaudible drone note (18 Hz) to keep audio context active...');
                        droneOscillator = audioContext.createOscillator();
                        droneGain = audioContext.createGain();
                        
                        // 18 Hz frequency (just below human hearing range of ~20 Hz)
                        // iOS respects this frequency more for keeping device awake
                        droneOscillator.frequency.value = 18;
                        droneOscillator.type = 'sine';
                        
                        // Reduced intensity - still inaudible but more "active" for iOS
                        // 0.00025 is half the previous value, still completely inaudible
                        droneGain.gain.value = 0.00025;
                        
                        // Connect: oscillator -> gain -> masterGain -> destination
                        droneOscillator.connect(droneGain);
                        droneGain.connect(masterGain);
                        
                        // Start and let it run continuously
                        droneOscillator.start();
                        console.log('âœ“ Drone note started - audio context will stay active');
                        
                        // Create visual particle for drone (small pulsing living entity)
                        const droneParticle = {
                            color: '#ffffff', // White for drone
                            radius: Math.max(window.innerWidth, window.innerHeight) * 0.08, // Small base size
                            maxRadius: Math.max(window.innerWidth, window.innerHeight) * 0.08,
                            alpha: 0.6, // Base alpha
                            rotation: 0,
                            frequency: 18, // Drone frequency for pattern calculation
                            isDrone: true, // Mark as drone particle
                            pulsePhase: 0 // Track pulse phase for breathing animation
                        };
                        particles.push(droneParticle);
                        
                        // Keep drone particle alive by updating it periodically
                        const updateDroneVisual = () => {
                            if (droneOscillator && particles.length > 0) {
                                const droneP = particles.find(p => p.isDrone);
                                if (droneP) {
                                    // Pulse phase is updated in the animate loop for smooth animation
                                    // Just ensure it exists
                                    if (!droneP.pulsePhase) droneP.pulsePhase = 0;
                                }
                            }
                        };
                        const droneVisualInterval = setInterval(() => {
                            if (!droneOscillator) {
                                clearInterval(droneVisualInterval);
                                // Remove drone particle
                                const index = particles.findIndex(p => p.isDrone);
                                if (index >= 0) {
                                    particles.splice(index, 1);
                                }
                            } else {
                                updateDroneVisual();
                            }
                        }, 50); // Update every 50ms
                        
                        // Monitor audio context state and restart drone if suspended
                        const monitorInterval = setInterval(() => {
                            if (!audioContext || !droneOscillator) {
                                clearInterval(monitorInterval);
                                return;
                            }
                            if (audioContext.state === 'suspended') {
                                console.log('âš ï¸ Audio context suspended, attempting to resume...');
                                audioContext.resume().then(() => {
                                    console.log('âœ“ Audio context resumed');
                                }).catch(e => {
                                    console.log('Could not resume audio context:', e.message);
                                });
                            }
                        }, 5000);
                    } catch (e) {
                        console.error('Failed to start drone note:', e);
                        droneOscillator = null;
                    }
                };
                
                // Stop drone note smoothly (if needed) - prevents audio clicks/pops
                const stopDroneNote = () => {
                    if (droneOscillator && droneGain && audioContext) {
                        try {
                            // Remove drone particle visual
                            const droneParticleIndex = particles.findIndex(p => p.isDrone);
                            if (droneParticleIndex >= 0) {
                                particles.splice(droneParticleIndex, 1);
                            }
                            
                            // Smoothly fade out the drone gain to prevent clicks
                            const now = audioContext.currentTime;
                            const fadeTime = 0.05; // 50ms fade out (very quick but smooth)
                            
                            // Fade out the gain node smoothly
                            droneGain.gain.cancelScheduledValues(now);
                            droneGain.gain.setValueAtTime(droneGain.gain.value, now);
                            droneGain.gain.linearRampToValueAtTime(0, now + fadeTime);
                            
                            // Stop oscillator after fade completes
                            droneOscillator.stop(now + fadeTime + 0.01);
                            
                            // Clean up after fade
                            setTimeout(() => {
                                try {
                                    if (droneOscillator) {
                                        droneOscillator.disconnect();
                                    }
                                    if (droneGain) {
                                        droneGain.disconnect();
                                    }
                                } catch (e) {
                                    // Ignore disconnect errors
                                }
                                droneOscillator = null;
                                droneGain = null;
                            }, (fadeTime + 0.01) * 1000);
                            
                            console.log('Drone note stopped smoothly');
                        } catch (e) {
                            console.error('Error stopping drone note:', e);
                            // Fallback: just stop it immediately
                            try {
                                if (droneOscillator) {
                                    droneOscillator.stop();
                                    droneOscillator.disconnect();
                                }
                                if (droneGain) {
                                    droneGain.disconnect();
                                }
                            } catch (e2) {
                                // Ignore
                            }
                            droneOscillator = null;
                            droneGain = null;
                        }
                    } else if (droneOscillator) {
                        // Fallback if audio context is gone
                        try {
                            droneOscillator.stop();
                            droneOscillator.disconnect();
                            if (droneGain) {
                                droneGain.disconnect();
                            }
                        } catch (e) {
                            // Ignore
                        }
                        droneOscillator = null;
                        droneGain = null;
                    }
                };
                
                const playNote = (freq, volume, color, durationOverride = null, noteName = null, generatorId = null) => {
                    console.log('playNote called:', { freq, volume, color, isSlave, durationOverride, noteName, generatorId });
                    
                    // Update currently playing note for master when included
                    if (!isSlave && settings.masterIncluded && noteName) {
                        masterCurrentlyPlayingNote.value = noteName;
                        // Clear after note duration
                        const duration = durationOverride !== null ? durationOverride : (settings.noteLength + (Math.random() * 2 - 1));
                        setTimeout(() => {
                            if (masterCurrentlyPlayingNote.value === noteName) {
                                masterCurrentlyPlayingNote.value = null;
                            }
                        }, duration * 1000 + 100);
                    }
                    
                    // Update currently playing note for slaves (for animation)
                    if (isSlave && noteName) {
                        slaveCurrentlyPlayingNote.value = noteName;
                        // Clear after note duration
                        const duration = durationOverride !== null ? durationOverride : (settings.noteLength + (Math.random() * 2 - 1));
                        setTimeout(() => {
                            if (slaveCurrentlyPlayingNote.value === noteName) {
                                slaveCurrentlyPlayingNote.value = null;
                            }
                        }, duration * 1000 + 100);
                    }
                    
                    // Master never shows visuals - only slaves do
                    if (!isSlave) {
                        // If master is not included, don't play sound
                        if (!settings.masterIncluded) {
                            console.log('Master not included - skipping sound');
                            return;
                        }
                        // Master is included but no visuals - continue to play sound only
                    } else {
                        // Slaves: Always create particles for visuals FIRST
                        // This ensures visuals work even if audio isn't ready
                        // Store frequency for cymatic mandala visualization
                        const duration = durationOverride !== null ? durationOverride : (settings.noteLength + (Math.random() * 2 - 1));
                        const particle = {
                            color,
                            radius: 0,
                            maxRadius: Math.max(window.innerWidth, window.innerHeight) * 0.6,
                            alpha: 1,
                            speed: 0.01,
                            rotation: Math.random() * Math.PI * 2,
                            frequency: freq, // Store frequency for cymatic patterns
                            noteName: noteName, // Store note name for reference
                            duration: duration, // Store note duration
                            startTime: Date.now() // Track when particle was created
                        };
                        particles.push(particle);
                        console.log('Particle created with frequency:', freq, 'Hz for note:', noteName, 'duration:', duration, 's');
                    }
                    
                    // Check if we should play sound
                    if (!masterGain || !audioContext) {
                        console.log('playNote: audio context or masterGain not ready, visuals only');
                        console.log('masterGain:', !!masterGain, 'audioContext:', !!audioContext);
                        return;
                    }
                    
                    // If master is muted, don't play sound (but visuals already created above)
                    if (!isSlave && settings.masterMuted) {
                        console.log('Master muted - visuals only, no sound');
                        return;
                    }
                    
                    const now = audioContext.currentTime;
                    // Use provided duration or calculate with randomness: Â±1 second variation from the set noteLength
                    const duration = durationOverride !== null ? durationOverride : (settings.noteLength + (Math.random() * 2 - 1)); // Random between noteLength-1 and noteLength+1
                    
                    // Ensure minimum duration of 0.5 seconds to prevent very short notes
                    const finalDuration = Math.max(0.5, duration);
                    
                    console.log('playNote: durationOverride=', durationOverride, 'calculated duration=', duration, 'finalDuration=', finalDuration);
                    
                    // Simple clean sine wave - no detuning, no filters
                    const osc = audioContext.createOscillator();
                    const oscGain = audioContext.createGain();
                    const noteGain = audioContext.createGain();
                    
                    // Pure sine wave
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    
                    // Simple smooth envelope - fade-out completes BEFORE oscillator stops to prevent clicks
                    const fadeOutTime = 0.15; // Fade out over 150ms for smooth stop
                    // Calculate when fade-out should start (ensuring minimum sustain time)
                    const fadeStartTime = Math.max(now + 0.2, now + finalDuration - fadeOutTime);
                    const fadeEndTime = now + finalDuration - 0.01; // Fade completes 10ms before stop
                    
                    // Apply master flake volume when master is included (separate from master volume knob)
                    let effectiveVolume = volume / 100;
                    if (!isSlave && settings.masterIncluded) {
                        // When master is included as a flake, multiply by master flake volume
                        effectiveVolume = effectiveVolume * (masterVolume.value / 100);
                    }
                    
                    oscGain.gain.setValueAtTime(0, now);
                    oscGain.gain.linearRampToValueAtTime(effectiveVolume * 0.5, now + 0.1);
                    // Hold full volume until fade starts
                    oscGain.gain.setValueAtTime(effectiveVolume * 0.5, fadeStartTime);
                    // Fade out smoothly
                    oscGain.gain.linearRampToValueAtTime(0, fadeEndTime);
                    
                    // For both slaves and master, noteGain should be 1.0
                    // Volume is controlled entirely by masterGain to prevent conflicts
                    noteGain.gain.value = 1.0;
                    
                    // Simple connection: oscillator -> gain -> master
                    osc.connect(oscGain);
                    oscGain.connect(noteGain);
                    noteGain.connect(masterGain);
                    
                    // Store gain nodes with oscillator for smooth fade-out on stop
                    osc._oscGain = oscGain;
                    osc._noteGain = noteGain;
                    osc._startTime = now;
                    osc._duration = finalDuration;
                    
                    // Track active oscillator globally
                    activeOscillators.add(osc);
                    // Track oscillator per generator (for per-generator overlap prevention)
                    if (generatorId !== null && generatorId !== undefined) {
                        if (!generatorOscillators[generatorId]) {
                            generatorOscillators[generatorId] = new Set();
                        }
                        // Remove placeholder if it exists
                        const placeholder = Array.from(generatorOscillators[generatorId]).find(item => item._isPlaceholder);
                        if (placeholder) {
                            generatorOscillators[generatorId].delete(placeholder);
                        }
                        // Add actual oscillator
                        generatorOscillators[generatorId].add(osc);
                        console.log('Generator', generatorId, ': added oscillator, total active:', generatorOscillators[generatorId].size);
                    }
                    osc.onended = () => {
                        // Clean up when oscillator finishes naturally
                        activeOscillators.delete(osc);
                        // Clean up per-generator tracking
                        if (generatorId !== null && generatorId !== undefined) {
                            if (generatorOscillators[generatorId]) {
                                generatorOscillators[generatorId].delete(osc);
                                const remaining = generatorOscillators[generatorId].size;
                                // Clear note end time when oscillator ends (only if no oscillators remain)
                                if (remaining === 0) {
                                    generatorNoteEndTimes[generatorId] = null;
                                    console.log('Generator', generatorId, ': oscillator ended, cleared note end time, remaining:', remaining);
                                } else {
                                    console.log('Generator', generatorId, ': oscillator ended, remaining:', remaining);
                                }
                            }
                        }
                        // Disconnect gain nodes after a small delay to ensure fade-out completes
                        setTimeout(() => {
                            try {
                                if (osc._oscGain) osc._oscGain.disconnect();
                                if (osc._noteGain) osc._noteGain.disconnect();
                            } catch (e) {
                                // Already disconnected, ignore
                            }
                        }, 50);
                    };
                    
                    osc.start(now);
                    const stopTime = now + finalDuration;
                    osc.stop(stopTime); // Oscillator stops after full duration
                    console.log('playNote:');
                    console.log('  Generator:', generatorId);
                    console.log('  Frequency:', freq, 'Hz');
                    console.log('  Started at:', now.toFixed(3), 's');
                    console.log('  Will stop at:', stopTime.toFixed(3), 's');
                    console.log('  Duration:', finalDuration.toFixed(3), 's');
                    console.log('  Fade starts at:', fadeStartTime.toFixed(3), 's');
                    console.log('  Fade ends at:', fadeEndTime.toFixed(3), 's');
                    
                    // Particles are already created earlier for slaves (line 1508)
                    // This duplicate creation has been removed to prevent multiple particles per note
                };
                
                const scheduleNextNote = (generatorId) => {
                    // If master is not included, don't schedule notes
                    if (!settings.masterIncluded) {
                        console.log('Master not included - skipping note scheduling');
                        return;
                    }
                    
                    if (!isPlaying.value) {
                        console.log('Not playing, stopping generator', generatorId);
                        return;
                    }
                    if (!audioContext || !masterGain) {
                        console.error('Audio context not ready in scheduleNextNote');
                        return;
                    }
                    
                    // Always prevent overlap - check if ANY note is still playing
                    const now = audioContext.currentTime;
                    
                    // First check if any oscillators are actively playing
                    if (activeOscillators.size > 0) {
                        // A note is definitely playing, wait
                        const timeout = setTimeout(() => scheduleNextNote(generatorId), 100);
                        generatorTimeouts[generatorId] = timeout;
                        return;
                    }
                    
                    // Check the lock - if a note is starting, wait
                    if (isNotePlaying) {
                        const timeout = setTimeout(() => scheduleNextNote(generatorId), 50);
                        generatorTimeouts[generatorId] = timeout;
                        return;
                    }
                    
                    // Find the latest note end time across all generators
                    let latestEndTime = lastNoteEndTime;
                    generatorNoteEndTimes.forEach(endTime => {
                        if (endTime && endTime > latestEndTime) {
                            latestEndTime = endTime;
                        }
                    });
                    
                    if (now < latestEndTime) {
                        // A note is still playing based on timing, wait until it finishes
                        const waitTime = Math.max(50, (latestEndTime - now) * 1000); // Minimum 50ms
                        const timeout = setTimeout(() => scheduleNextNote(generatorId), waitTime);
                        generatorTimeouts[generatorId] = timeout;
                        return;
                    }
                    
                    // Set lock to prevent other generators from starting simultaneously
                    isNotePlaying = true;
                    
                    // Use assigned notes if available (master mode), otherwise use all enabled notes
                    const notesToPlay = masterAssignedNotes.value.length > 0 
                        ? masterAssignedNotes.value 
                        : noteData.filter(n => n.enabled);
                    
                    if (notesToPlay.length === 0) {
                        const timeout = setTimeout(() => scheduleNextNote(generatorId), settings.pauseLength * 1000);
                        generatorTimeouts[generatorId] = timeout;
                        return;
                    }
                    const note = notesToPlay[Math.floor(Math.random() * notesToPlay.length)];
                    
                    // Calculate note duration FIRST (with randomness: Â±1 second)
                    // Random between noteLength-1 and noteLength+1, but ensure minimum 0.1 seconds
                    const baseDuration = settings.noteLength + (Math.random() * 2 - 1); // Random between noteLength-1 and noteLength+1
                    const noteDuration = Math.max(0.1, baseDuration); // Ensure minimum 0.1 seconds
                    
                    // CRITICAL: Get audio context time RIGHT BEFORE playing
                    // This ensures accurate timing calculation
                    const noteStartTime = audioContext.currentTime;
                    const noteEndTime = noteStartTime + noteDuration;
                    generatorNoteEndTimes[generatorId] = noteEndTime;
                    // Update global last note end time
                    if (noteEndTime > lastNoteEndTime) {
                        lastNoteEndTime = noteEndTime;
                    }
                    
                    console.log('Generator', generatorId, '(master): note starts at:', noteStartTime.toFixed(3), 's, will end at:', noteEndTime.toFixed(3), 's, duration:', noteDuration.toFixed(3), 's');
                    
                    // Release lock after a short delay to allow note to start
                    setTimeout(() => {
                        isNotePlaying = false;
                    }, 100);
                    
                    // Pass the calculated duration and generatorId to playNote so it uses the same value
                    playNote(note.freq, note.volume, note.color, noteDuration, note.note, generatorId);
                    
                    // Calculate pause delay (with randomness: Â±1 second, minimum 0)
                    const basePauseDuration = settings.pauseLength + (Math.random() * 2 - 1); // Random between pauseLength-1 and pauseLength+1 seconds
                    const pauseDuration = Math.max(0, basePauseDuration); // Ensure minimum 0 seconds
                    
                    // CRITICAL: The pause starts AFTER the note ends, not after it starts
                    // So the next note should start at: noteEndTime + pauseDuration
                    const nextNoteStartTime = noteEndTime + pauseDuration;
                    
                    // Get current audio context time RIGHT NOW for accurate delay calculation
                    const nowForScheduling = audioContext.currentTime;
                    
                    // Calculate delay in milliseconds from NOW until next note should start
                    const delayUntilNextNote = (nextNoteStartTime - nowForScheduling) * 1000;
                    
                    console.log('Generator', generatorId, '(master) scheduling next note:');
                    console.log('  Note duration:', noteDuration.toFixed(3), 's');
                    console.log('  Pause duration:', pauseDuration.toFixed(3), 's');
                    console.log('  Note started at:', noteStartTime.toFixed(3), 's');
                    console.log('  Note ends at:', noteEndTime.toFixed(3), 's');
                    console.log('  Pause ends at:', nextNoteStartTime.toFixed(3), 's (noteEnd + pause)');
                    console.log('  Current time (now):', nowForScheduling.toFixed(3), 's');
                    console.log('  Delay until next:', delayUntilNextNote.toFixed(0), 'ms');
                    console.log('  Time until note ends:', ((noteEndTime - nowForScheduling) * 1000).toFixed(0), 'ms');
                    console.log('  Time until pause ends:', ((nextNoteStartTime - nowForScheduling) * 1000).toFixed(0), 'ms');
                    
                    // Ensure delay is at least 50ms to prevent immediate scheduling
                    const finalDelay = Math.max(50, delayUntilNextNote);
                    if (finalDelay < delayUntilNextNote - 10) {
                        console.warn('Generator', generatorId, '(master): WARNING - delay was clamped from', delayUntilNextNote.toFixed(0), 'ms to', finalDelay, 'ms');
                    }
                    if (finalDelay < (pauseDuration * 1000) - 100) {
                        console.error('Generator', generatorId, '(master): ERROR - delay (', finalDelay, 'ms) is shorter than pause duration (', (pauseDuration * 1000).toFixed(0), 'ms)!');
                    }
                    const timeout = setTimeout(() => scheduleNextNote(generatorId), finalDelay);
                    generatorTimeouts[generatorId] = timeout;
                };
                
                const startAllGenerators = () => {
                    // If master is not included, don't start generators
                    if (!settings.masterIncluded) {
                        console.log('Master not included - skipping generator start');
                        return;
                    }
                    
                    if (!audioContext || !masterGain) {
                        console.error('Cannot start generators: audio context not ready');
                        return;
                    }
                    // Clear any existing timeouts
                    generatorTimeouts.forEach(timeout => {
                        if (timeout) clearTimeout(timeout);
                    });
                    generatorTimeouts.length = 0;
                    generatorNoteEndTimes.length = 0;
                    lastNoteEndTime = 0;
                    isNotePlaying = false;
                    
                    // Use assigned notes if available (master mode), otherwise use all enabled notes
                    const notesToPlay = masterAssignedNotes.value.length > 0 
                        ? masterAssignedNotes.value 
                        : noteData.filter(n => n.enabled);
                    
                    if (notesToPlay.length === 0) {
                        console.warn('No notes to play');
                        return;
                    }
                    
                    console.log('Master starting playback with', notesToPlay.length, 'assigned notes');
                    
                    // Start multiple generators
                    const numGenerators = Math.min(settings.numGenerators, notesToPlay.length);
                    for (let i = 0; i < numGenerators; i++) {
                        // Start all generators at the same time (they'll queue to prevent overlap)
                        const startDelay = 0;
                        const timeout = setTimeout(() => {
                            scheduleNextNote(i);
                        }, startDelay);
                        generatorTimeouts[i] = timeout;
                    }
                };
                
                const togglePlayback = async () => {
                    if (!isPlaying.value) {
                        try {
                            await initAudio();
                            console.log('Audio initialized, state:', audioContext ? audioContext.state : 'null');
                            if (!audioContext || !masterGain) {
                                console.error('Audio context or master gain not initialized');
                                alert('Audio initialization failed. Please check console.');
                                return;
                            }
                        isPlaying.value = true;
                            // Setup MediaSession for background audio support
                            setupMediaSession();
                            updateMediaSessionState();
                            
                            // Request wake lock when playback starts (to prevent device sleep)
                            requestWakeLock();
                            
                            // For iOS: Create and start keep-alive video immediately
                            // This must be done in the master context, so check if createKeepAliveVideo exists
                            setTimeout(() => {
                                // Try to access createKeepAliveVideo if it exists in slave context
                                if (typeof window.createKeepAliveVideo === 'function') {
                                    const video = window.createKeepAliveVideo();
                                    if (video) {
                                        video.play().catch(() => {});
                                    }
                                }
                            }, 100);
                            
                            // Start drone note for both master and slaves to keep audio context active
                            if (audioContext && audioContext.state === 'running') {
                                startDroneNote();
                            }
                            if (isSlave) {
                                startSlavePlayback();
                            } else {
                                // If master is included, treat it as a slave (use assigned notes with slave playback logic)
                                if (settings.masterIncluded && masterAssignedNotes.value.length > 0) {
                                    console.log('Master included: using slave playback logic with', masterAssignedNotes.value.length, 'assigned notes');
                                    // Temporarily set assignedNotes to masterAssignedNotes for slave playback
                                    const originalAssignedNotes = assignedNotes.value;
                                    assignedNotes.value = masterAssignedNotes.value.map(n => ({
                                        note: n.note,
                                        freq: n.freq,
                                        volume: n.volume,
                                        color: n.color
                                    }));
                                    startSlavePlayback();
                                    // Restore original assignedNotes (slave playback will use its own copy)
                                    assignedNotes.value = originalAssignedNotes;
                                } else if (settings.masterIncluded) {
                                    // Master is included but no assigned notes yet, use all enabled notes
                                    startAllGenerators();
                                } else {
                                    // Master not included - stop any running generators
                                    console.log('Master not included - stopping generators');
                                    generatorTimeouts.forEach(timeout => {
                                        if (timeout) clearTimeout(timeout);
                                    });
                                    generatorTimeouts.length = 0;
                                    generatorNoteEndTimes.length = 0;
                                    lastNoteEndTime = 0;
                                    isNotePlaying = false;
                                }
                                // Notify slaves to start - send preset first, then play command
                                if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                    console.log('Master: Sending preset to slaves...');
                                    sendPresetToSlaves();
                                    // Small delay to ensure preset is sent first
                                    setTimeout(() => {
                                        if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                            console.log('Master: Sending play command to slaves...');
                                            ws.value.send(JSON.stringify({ type: 'play' }));
                                        } else {
                                            console.warn('Master: WebSocket not open when trying to send play command');
                                        }
                                    }, 200);
                                } else {
                                    console.warn('WebSocket not connected, cannot notify slaves');
                                }
                            }
                        } catch (e) {
                            console.error('Error starting playback:', e);
                            alert('Error starting playback: ' + e.message);
                        }
                    } else {
                        // Graceful stop: smoothly fade out all active notes to prevent clicks
                        isPlaying.value = false;
                        
                        // Update MediaSession state
                        updateMediaSessionState();
                        
                        // Release wake lock when stopping (to save battery)
                        if (wakeLock) {
                            try {
                                wakeLock.release();
                                wakeLock = null;
                                console.log('Wake lock released (playback stopped)');
                            } catch (e) {
                                console.log('Error releasing wake lock:', e);
                            }
                        }
                        // Clear all scheduled timeouts to prevent new notes
                        generatorTimeouts.forEach(timeout => {
                            if (timeout) clearTimeout(timeout);
                        });
                        generatorTimeouts.length = 0;
                        generatorNoteEndTimes.length = 0;
                        
                        // Smoothly fade out all currently playing oscillators
                        if (audioContext && activeOscillators.size > 0) {
                            const now = audioContext.currentTime;
                            const fadeOutDuration = 0.2; // 200ms fade-out for smooth stop
                            
                            activeOscillators.forEach(osc => {
                                try {
                                    // Calculate when this oscillator was supposed to stop naturally
                                    const naturalStopTime = osc._startTime + osc._duration;
                                    const timeUntilNaturalStop = naturalStopTime - now;
                                    
                                    // Only fade out if it would stop later than our fade-out duration
                                    // If it's already almost done, let it finish naturally
                                    if (timeUntilNaturalStop > fadeOutDuration) {
                                        // Fade out the gain node smoothly
                                        if (osc._oscGain) {
                                            const currentGain = osc._oscGain.gain.value;
                                            osc._oscGain.gain.cancelScheduledValues(now);
                                            osc._oscGain.gain.setValueAtTime(currentGain, now);
                                            osc._oscGain.gain.linearRampToValueAtTime(0, now + fadeOutDuration);
                                        }
                                        
                                        // Stop oscillator after fade completes
                                        const stopTime = now + fadeOutDuration + 0.01;
                                        osc.stop(stopTime);
                                    } else {
                                        // Already almost done, just ensure smooth fade-out
                                        if (osc._oscGain && timeUntilNaturalStop > 0.01) {
                                            const currentGain = osc._oscGain.gain.value;
                                            osc._oscGain.gain.cancelScheduledValues(now);
                                            osc._oscGain.gain.setValueAtTime(currentGain, now);
                                            osc._oscGain.gain.linearRampToValueAtTime(0, naturalStopTime);
                                        }
                                    }
                                } catch (e) {
                                    console.error('Error fading out oscillator:', e);
                                    // Fallback: let it finish naturally
                                }
                            });
                        }
                        
                        // Clear the set after fade-out completes
                        setTimeout(() => {
                            activeOscillators.clear();
                        }, 300); // Wait for fade-out to complete
                        
                        // Keep drone note running even when stopped (for both master and slaves)
                        // This ensures audio context stays active
                        if (audioContext && audioContext.state === 'running' && !droneOscillator) {
                            startDroneNote();
                        }
                        
                        // Notify slaves to stop gracefully
                        if (!isSlave && ws.value && ws.value.readyState === WebSocket.OPEN) {
                            ws.value.send(JSON.stringify({ type: 'stop' }));
                        }
                    }
                };
                
                // Fractal drawing functions
                const drawFractalCircle = (ctx, x, y, radius, depth, maxDepth, color, alpha, rotation) => {
                    if (depth > maxDepth || radius < 2) return; // Increased min radius for performance
                    
                    const currentAlpha = alpha * (1 - depth / maxDepth) * 0.6;
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(rotation);
                    
                    // Draw circle with reduced center brightness
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                    gradient.addColorStop(0, color + Math.floor(currentAlpha * 150).toString(16).padStart(2, '0'));
                    gradient.addColorStop(0.5, color + Math.floor(currentAlpha * 80).toString(16).padStart(2, '0'));
                    gradient.addColorStop(0.7, color + Math.floor(currentAlpha * 50).toString(16).padStart(2, '0'));
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = color + Math.floor(currentAlpha * 120).toString(16).padStart(2, '0');
                    ctx.lineWidth = 2 * (1 - depth / maxDepth);
                    ctx.stroke();
                    
                    // Recursive circles - reduced count for performance
                    if (depth < maxDepth) {
                        const childCount = 4; // Reduced from 6
                        const childRadius = radius * 0.4;
                        const childDistance = radius * 0.6;
                        
                        for (let i = 0; i < childCount; i++) {
                            const angle = (i / childCount) * Math.PI * 2 + rotation * 0.5;
                            const childX = Math.cos(angle) * childDistance;
                            const childY = Math.sin(angle) * childDistance;
                            drawFractalCircle(ctx, childX, childY, childRadius, depth + 1, maxDepth, color, currentAlpha, rotation * 1.2);
                        }
                    }
                    
                    ctx.restore();
                };
                
                const drawFractalTree = (ctx, x, y, length, angle, depth, maxDepth, color, alpha) => {
                    if (depth > maxDepth || length < 3) return; // Increased min length for performance
                    
                    const currentAlpha = alpha * (1 - depth / maxDepth * 0.7);
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle);
                    
                    // Draw branch
                    ctx.strokeStyle = color + Math.floor(currentAlpha * 255).toString(16).padStart(2, '0');
                    ctx.lineWidth = (maxDepth - depth) * 2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -length);
                    ctx.stroke();
                    
                    // Recursive branches - reduced recursion for performance
                    if (depth < maxDepth - 1) { // Stop one level earlier
                        const newX = 0;
                        const newY = -length;
                        const newLength = length * 0.7;
                        const branchAngle = Math.PI / 6;
                        
                        drawFractalTree(ctx, newX, newY, newLength, -branchAngle, depth + 1, maxDepth, color, currentAlpha);
                        drawFractalTree(ctx, newX, newY, newLength, branchAngle, depth + 1, maxDepth, color, currentAlpha);
                    }
                    
                    ctx.restore();
                };
                
                const drawFractalSpiral = (ctx, x, y, radius, turns, depth, maxDepth, color, alpha, rotation) => {
                    if (depth > maxDepth || radius < 1) return;
                    
                    const currentAlpha = alpha * (1 - depth / maxDepth);
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(rotation);
                    
                    ctx.strokeStyle = color + Math.floor(currentAlpha * 255).toString(16).padStart(2, '0');
                    ctx.lineWidth = (maxDepth - depth + 1) * 1.5;
                    ctx.beginPath();
                    
                    for (let t = 0; t < turns * Math.PI * 2; t += 0.1) {
                        const r = radius * (t / (turns * Math.PI * 2));
                        const px = Math.cos(t) * r;
                        const py = Math.sin(t) * r;
                        if (t === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                    
                    // Recursive spirals
                    const childRadius = radius * 0.5;
                    const childTurns = turns * 0.8;
                    const childCount = 4;
                    
                    for (let i = 0; i < childCount; i++) {
                        const angle = (i / childCount) * Math.PI * 2;
                        const childX = Math.cos(angle) * radius * 0.7;
                        const childY = Math.sin(angle) * radius * 0.7;
                        drawFractalSpiral(ctx, childX, childY, childRadius, childTurns, depth + 1, maxDepth, color, currentAlpha, rotation * 1.3);
                    }
                    
                    ctx.restore();
                };
                
                const animate = () => {
                    const c = canvas.value; const context = ctx.value;
                    if (!c || !context) {
                        requestAnimationFrame(animate);
                        return;
                    }
                    // Use actual canvas dimensions, not bounding rect
                    const width = c.width / (window.devicePixelRatio || 1);
                    const height = c.height / (window.devicePixelRatio || 1);
                    const centerX = width / 2;
                    const centerY = height / 2;
                    const maxDim = Math.max(width, height);
                    
                    // Beautiful fade trail effect
                    context.fillStyle = 'rgba(0, 0, 0, 0.06)';
                    context.fillRect(0, 0, width, height);
                    
                    rotation += 0.008;
                    
                    // Only draw animations for slaves - master shows no visuals
                    if (!isSlave) {
                        // Master: Just clear the canvas, no animations
                        requestAnimationFrame(animate);
                        return;
                    }
                    
                    // Draw drone particle first (so it appears underneath other animations)
                    const droneParticle = particles.find(p => p && p.isDrone);
                    if (droneParticle) {
                        // Simple small glowing blurry orb that pulses with water ripples
                        context.save();
                        context.translate(centerX, centerY);
                        context.globalCompositeOperation = 'screen';
                        
                        // Update pulse phase for subtle pulsing
                        if (!droneParticle.pulsePhase) droneParticle.pulsePhase = 0;
                        droneParticle.pulsePhase += 0.02; // Slow pulse
                        
                        // Create subtle pulse
                        const pulse = Math.sin(droneParticle.pulsePhase) * 0.1 + 0.9; // Pulse between 0.9 and 1.0
                        
                        // Small orb size
                        const orbSize = Math.max(window.innerWidth, window.innerHeight) * 0.04 * pulse;
                        const baseAlpha = 0.4;
                        const pulseAlpha = baseAlpha * pulse;
                        
                        // Draw water ripples (contained within the orb)
                        const numRipples = 3;
                        for (let i = 0; i < numRipples; i++) {
                            const ripplePhase = droneParticle.pulsePhase * 0.5 + i * 0.8;
                            // Ripples stay within orb - start from center and expand inward from edge
                            const rippleRadius = orbSize * (0.3 + i * 0.2) + Math.sin(ripplePhase) * orbSize * 0.1;
                            const rippleAlpha = pulseAlpha * (0.2 - i * 0.05) * (0.5 + Math.sin(ripplePhase) * 0.5);
                            
                            if (rippleAlpha > 0 && rippleRadius < orbSize) {
                                context.globalAlpha = rippleAlpha;
                                context.strokeStyle = '#ffffff';
                                context.lineWidth = 1.5;
                                context.shadowBlur = 8;
                                context.shadowColor = '#ffffff';
                                context.filter = 'blur(3px)';
                                
                                context.beginPath();
                                context.arc(0, 0, rippleRadius, 0, Math.PI * 2);
                                context.stroke();
                            }
                        }
                        
                        // Create blurry glowing orb with radial gradient
                        const gradient = context.createRadialGradient(0, 0, 0, 0, 0, orbSize);
                        gradient.addColorStop(0, '#ffffff');
                        gradient.addColorStop(0.3, '#ffffff' + Math.floor(pulseAlpha * 200).toString(16).padStart(2, '0'));
                        gradient.addColorStop(0.6, '#ffffff' + Math.floor(pulseAlpha * 100).toString(16).padStart(2, '0'));
                        gradient.addColorStop(1, 'transparent');
                        
                        // Add blur effect
                        context.shadowBlur = 20;
                        context.shadowColor = '#ffffff';
                        context.filter = 'blur(8px)'; // Blurry effect
                        
                        context.globalAlpha = pulseAlpha;
                        context.fillStyle = gradient;
                        context.beginPath();
                        context.arc(0, 0, orbSize, 0, Math.PI * 2);
                        context.fill();
                        
                        // Reset effects
                        context.filter = 'none';
                        context.shadowBlur = 0;
                        context.restore();
                    }
                    
                    // Draw beautiful particle network (slaves only) - drawn on top of drone
                    for (let i = particles.length - 1; i >= 0; i--) {
                        const p = particles[i];
                        if (!p) {
                            particles.splice(i, 1);
                            continue;
                        }
                        
                        // Skip drone particle - already drawn above
                        if (p.isDrone) {
                            continue;
                        }
                        
                        const age = 1 - p.alpha;
                        const pulse = Math.sin(age * Math.PI * 4 + rotation * 2) * 0.5 + 0.5;
                        
                        if (settings.vizMode === 'pulse') {
                            // Psychedelic fractal pulse mode
                            context.save();
                            context.globalCompositeOperation = 'screen';
                            
                            // Draw fractal circles at center (reduced intensity)
                            const fractalDepth = 2; // Reduced from 3
                            const fractalRadius = p.radius * (0.3 + pulse * 0.7);
                            drawFractalCircle(context, centerX, centerY, fractalRadius, 0, fractalDepth, p.color, p.alpha * 0.4, p.rotation + rotation);
                            
                            // Add expanding rings with fractal patterns - reduced count
                            for (let ring = 0; ring < 3; ring++) { // Reduced from 4
                                const ringRadius = p.radius + (ring * 20 * pulse);
                                const ringAlpha = p.alpha * (1 - ring * 0.2) * (0.5 + pulse * 0.3); // Reduced intensity
                                
                                // Radial gradient with reduced brightness
                                const gradient = context.createRadialGradient(
                                    centerX, centerY, ringRadius * 0.7,
                                    centerX, centerY, ringRadius * 1.3
                                );
                                gradient.addColorStop(0, p.color + Math.floor(ringAlpha * 180).toString(16).padStart(2, '0')); // Reduced from 255
                                gradient.addColorStop(0.5, p.color + Math.floor(ringAlpha * 100).toString(16).padStart(2, '0')); // Reduced from 120
                                gradient.addColorStop(1, 'transparent');
                                
                                context.globalAlpha = ringAlpha;
                                context.strokeStyle = gradient;
                                context.lineWidth = (4 - ring * 0.7) * (1 + pulse * 0.3); // Slightly thinner
                            context.beginPath();
                                context.arc(centerX, centerY, ringRadius, 0, Math.PI * 2);
                            context.stroke();
                                
                                // Add smaller fractal circles around the ring (reduced intensity)
                                if (ring > 0 && ringRadius > 50) {
                                    const smallCircleCount = 4; // Reduced from 6
                                    for (let i = 0; i < smallCircleCount; i++) {
                                        const angle = (i / smallCircleCount) * Math.PI * 2 + p.rotation + rotation;
                                        const smallX = centerX + Math.cos(angle) * ringRadius;
                                        const smallY = centerY + Math.sin(angle) * ringRadius;
                                        const smallRadius = ringRadius * 0.12;
                                        drawFractalCircle(context, smallX, smallY, smallRadius, 0, 1, p.color, ringAlpha * 0.4, angle); // Reduced depth from 2 to 1
                                    }
                                }
                            }
                            
                            context.restore();
                            
                            // Connect particles with flowing lines - disabled for performance
                            // Removed O(nÂ²) connection algorithm to improve performance
                            
                        } else {
                            // Cymatic Mandala Mode - accurate Chladni plate style patterns
                            context.save();
                            context.translate(centerX, centerY);
                            context.globalCompositeOperation = 'screen';
                            
                            // Get frequency and calculate pattern parameters
                            const freq = p.frequency || 440;
                            const baseFreq = 220; // C3 as base reference
                            const freqRatio = freq / baseFreq;
                            
                            // Calculate number of lobes/petals based on frequency
                            // Lower frequencies = fewer lobes, higher = more lobes
                            // Common patterns: 3, 4, 5, 6, 8, 10, 12 lobes
                            const numLobes = Math.max(3, Math.min(16, Math.round(3 + Math.sqrt(freqRatio) * 5)));
                            
                            // Calculate number of concentric rings based on frequency
                            const numRings = Math.max(2, Math.min(8, Math.round(2 + Math.log(freqRatio + 1) * 2)));
                            
                            const maxR = p.radius;
                            const lobeAngle = (Math.PI * 2) / numLobes;
                            
                            context.globalAlpha = p.alpha;
                            
                            // Draw concentric rings with soundwave ripples
                            // Increase number of rings for more ripple effect
                            const rippleRings = numRings * 2; // Double the rings for more ripples
                            
                            for (let ring = 0; ring < rippleRings; ring++) {
                                const ringRadius = (maxR * (ring + 1)) / (rippleRings + 1);
                                const ringAlpha = p.alpha * (1 - ring / rippleRings * 0.4) * 0.5; // Half intensity
                                
                                // Create soundwave ripple effect - alternating bright/dim rings
                                const ripplePhase = Math.sin((ring / rippleRings) * Math.PI * 4 + rotation * freqRatio * 0.2) * 0.5 + 0.5;
                                const rippleAlpha = ringAlpha * (0.3 + ripplePhase * 0.7); // Pulsing ripple effect
                                
                                // Draw the ring with lobe modulation and wave patterns
                                context.beginPath();
                                context.strokeStyle = p.color + Math.floor(rippleAlpha * 180).toString(16).padStart(2, '0');
                                context.lineWidth = (rippleRings - ring + 1) * 1.2 * p.alpha * 0.5; // Half intensity
                                context.globalAlpha = rippleAlpha;
                                
                                const pointsPerLobe = 40; // Higher resolution for smoother waves
                                const totalPoints = numLobes * pointsPerLobe;
                                
                                for (let i = 0; i <= totalPoints; i++) {
                                    const angle = (i / totalPoints) * Math.PI * 2 + p.rotation;
                                    
                                    // Calculate lobe modulation - creates the petal shape
                                    const lobeIndex = (angle / lobeAngle) % numLobes;
                                    const lobeProgress = (lobeIndex % 1);
                                    
                                    // Create smooth lobe shape using cosine
                                    const lobeModulation = Math.cos(lobeProgress * Math.PI * 2) * 0.15 + 1;
                                    
                                    // Add soundwave ripple effect - multiple frequencies
                                    const wave1 = Math.sin(angle * numLobes + rotation * freqRatio * 0.3) * 0.08;
                                    const wave2 = Math.sin(angle * numLobes * 2 + rotation * freqRatio * 0.5) * 0.04;
                                    const wave3 = Math.sin((ring / rippleRings) * Math.PI * 8 + rotation * 2) * 0.03;
                                    const waveMod = wave1 + wave2 + wave3;
                                    
                                    const r = ringRadius * lobeModulation * (1 + waveMod);
                                    const x = Math.cos(angle) * r;
                                    const y = Math.sin(angle) * r;
                                    
                                    if (i === 0) context.moveTo(x, y);
                                    else context.lineTo(x, y);
                                }
                                
                                context.closePath();
                                context.stroke();
                                
                                // Fill with subtle gradient (half intensity) - only for every other ring for ripple effect
                                if (ring % 2 === 0) {
                                    const gradient = context.createRadialGradient(0, 0, 0, 0, 0, ringRadius);
                                    gradient.addColorStop(0, p.color + Math.floor(rippleAlpha * 25).toString(16).padStart(2, '0'));
                                    gradient.addColorStop(0.7, p.color + Math.floor(rippleAlpha * 12).toString(16).padStart(2, '0'));
                                    gradient.addColorStop(1, 'transparent');
                                    context.fillStyle = gradient;
                                    context.fill();
                                }
                            }
                            
                            // Draw radial lines (nodal lines) creating the divisions (half intensity)
                            context.strokeStyle = p.color + Math.floor(p.alpha * 75).toString(16).padStart(2, '0'); // Half
                            context.lineWidth = 2 * p.alpha * 0.5; // Half intensity
                            context.globalAlpha = p.alpha * 0.35; // Half intensity
                            
                            for (let lobe = 0; lobe < numLobes; lobe++) {
                                const angle = (lobe / numLobes) * Math.PI * 2 + p.rotation + rotation * 0.02;
                                
                                // Draw main radial line
                                context.beginPath();
                                context.moveTo(0, 0);
                                context.lineTo(
                                    Math.cos(angle) * maxR * 0.95,
                                    Math.sin(angle) * maxR * 0.95
                                );
                                context.stroke();
                            }
                            
                            // Draw intersection points (antinodes) at ring intersections (half intensity)
                            context.fillStyle = p.color + Math.floor(p.alpha * 100).toString(16).padStart(2, '0'); // Half
                            context.globalAlpha = p.alpha * 0.4; // Half intensity
                            
                            for (let ring = 1; ring < numRings; ring++) {
                                const ringRadius = (maxR * (ring + 1)) / (numRings + 1);
                                
                                for (let lobe = 0; lobe < numLobes; lobe++) {
                                    // Position between radial lines (antinode position)
                                    const angle1 = (lobe / numLobes) * Math.PI * 2 + p.rotation;
                                    const angle2 = ((lobe + 1) / numLobes) * Math.PI * 2 + p.rotation;
                                    const antinodeAngle = (angle1 + angle2) / 2 + rotation * 0.03;
                                    
                                    const pointSize = maxR * 0.02 * (1 + Math.sin(rotation * 2 + ring + lobe) * 0.3);
                                    
                                    context.beginPath();
                                    context.arc(
                                        Math.cos(antinodeAngle) * ringRadius,
                                        Math.sin(antinodeAngle) * ringRadius,
                                        pointSize,
                                        0,
                                        Math.PI * 2
                                    );
                                    context.fill();
                                }
                            }
                            
                            // Draw bright central core (half intensity)
                            const coreRadius = maxR * 0.1;
                            const coreGradient = context.createRadialGradient(0, 0, 0, 0, 0, coreRadius);
                            coreGradient.addColorStop(0, p.color + Math.floor(p.alpha * 127).toString(16).padStart(2, '0')); // Half
                            coreGradient.addColorStop(0.5, p.color + Math.floor(p.alpha * 100).toString(16).padStart(2, '0')); // Half
                            coreGradient.addColorStop(1, 'transparent');
                            
                            context.fillStyle = coreGradient;
                            context.globalAlpha = p.alpha * 0.5; // Half intensity
                            context.beginPath();
                            context.arc(0, 0, coreRadius, 0, Math.PI * 2);
                            context.fill();
                            
                            // Draw radial lines from center matching number of lobes (half intensity)
                            context.strokeStyle = p.color + Math.floor(p.alpha * 110).toString(16).padStart(2, '0'); // Half
                            context.lineWidth = 2.5 * p.alpha * 0.5; // Half intensity
                            for (let lobe = 0; lobe < numLobes; lobe++) {
                                const angle = (lobe / numLobes) * Math.PI * 2 + p.rotation + rotation * 0.05;
                                context.beginPath();
                                context.moveTo(0, 0);
                                context.lineTo(
                                    Math.cos(angle) * coreRadius * 2,
                                    Math.sin(angle) * coreRadius * 2
                                );
                                context.stroke();
                            }
                            
                            context.restore();
                        }
                        
                        // Update particle with smooth easing
                        // Keep particle visible for the full note duration, then fade out completely
                        
                        // Skip drone particles (they have their own update logic)
                        if (p.isDrone) {
                            // Drone particles are handled separately
                            p.radius += p.maxRadius * p.speed;
                            continue;
                        }
                        
                        // Only process particles with proper timing data
                        // Remove old particles that don't have timing data
                        if (!p.startTime || !p.duration) {
                            // Old particle without timing data - remove it immediately
                            particles.splice(i, 1);
                            continue;
                        }
                        
                        const startTime = p.startTime;
                        const elapsed = (Date.now() - startTime) / 1000; // seconds
                        const duration = p.duration;
                        const progress = elapsed / duration;
                        
                        if (progress >= 1) {
                            // Note finished - fade out slowly and completely
                            // Calculate fade-out progress (0 to 1 over 3 seconds)
                            const fadeOutDuration = 3; // Fade out over 3 seconds (slower)
                            const fadeOutProgress = Math.min(1, (elapsed - duration) / fadeOutDuration);
                            p.alpha = Math.max(0, 1 - fadeOutProgress); // Fade from 1 to 0
                            
                            if (p.alpha <= 0) {
                                particles.splice(i, 1);
                                continue;
                            }
                        } else {
                            // Note still playing - keep alpha high, only slight fade
                            p.alpha = Math.max(0.95, 1 - progress * 0.05); // Stay at 95-100% alpha during note
                        }
                        
                        // Expand radius smoothly
                        p.radius += p.maxRadius * p.speed * 1.2;
                        p.rotation += 0.015 + Math.sin(rotation) * 0.005;
                    }
                    
                    // Background interference pattern removed - was causing unwanted dark rotating lines
                    
                    requestAnimationFrame(animate);
                };
                
                const savePreset = () => {
                    const preset = { name: prompt('Preset name:') || 'Untitled', settings: { ...settings }, notes: noteData.map(n => ({ ...n })) };
                    const presets = JSON.parse(localStorage.getItem('soundmarbles-presets') || '[]');
                    presets.push(preset);
                    localStorage.setItem('soundmarbles-presets', JSON.stringify(presets));
                };
                
                const loadPreset = () => {
                    const presets = JSON.parse(localStorage.getItem('soundmarbles-presets') || '[]');
                    if (presets.length === 0) return;
                    const names = presets.map((p, i) => `${i}: ${p.name}`).join('\n');
                    const index = prompt(`Select preset:\n${names}\n\nEnter number:`);
                    if (index === null || !presets[index]) return;
                    const preset = presets[index];
                    Object.assign(settings, preset.settings);
                    preset.notes.forEach((n, i) => Object.assign(noteData[i], n));
                };
                
                
                const noteToFrequency = (noteName) => {
                    if (!noteName || noteName.length < 2) return null;
                    
                    // Parse note name (e.g., "E4", "C#5", "Bb3")
                    const match = noteName.match(/^([A-G])([#b]?)(\d+)$/i);
                    if (!match) return null;
                    
                    const [, note, accidental, octave] = match;
                    const octaveNum = parseInt(octave);
                    
                    // Just Intonation tuning - pure frequency ratios from C
                    // Reference pitch is A4 (440 Hz or 432 Hz)
                    // In just intonation, A is 5/3 relative to C
                    // So C4 = A4 / (5/3) = A4 * 3/5
                    const a4Freq = settings.referencePitch || 440;
                    const rootFreq = a4Freq * (3/5); // C4 frequency from A4 using just intonation ratio
                    const rootOctave = 4;
                    
                    // Just intonation ratios relative to C (in C major scale)
                    // Using pure intervals: 1/1, 9/8, 5/4, 4/3, 3/2, 5/3, 15/8
                    const justIntonationRatios = {
                        'C': 1/1,      // Unison: 1:1
                        'C#': 16/15,   // Minor second: 16:15
                        'Db': 16/15,   // Minor second: 16:15
                        'D': 9/8,      // Major second: 9:8
                        'D#': 6/5,     // Minor third: 6:5
                        'Eb': 6/5,     // Minor third: 6:5
                        'E': 5/4,      // Major third: 5:4
                        'F': 4/3,      // Perfect fourth: 4:3
                        'F#': 45/32,   // Augmented fourth: 45:32
                        'Gb': 45/32,   // Augmented fourth: 45:32
                        'G': 3/2,      // Perfect fifth: 3:2
                        'G#': 8/5,     // Minor sixth: 8:5
                        'Ab': 8/5,     // Minor sixth: 8:5
                        'A': 5/3,      // Major sixth: 5:3
                        'A#': 16/9,    // Minor seventh: 16:9
                        'Bb': 16/9,    // Minor seventh: 16:9
                        'B': 15/8      // Major seventh: 15:8
                    };
                    
                    const noteKey = accidental ? note.toUpperCase() + accidental : note.toUpperCase();
                    const ratio = justIntonationRatios[noteKey];
                    if (ratio === undefined) return null;
                    
                    // Calculate frequency: rootFreq * ratio * 2^(octave difference)
                    const octaveDiff = octaveNum - rootOctave;
                    const frequency = rootFreq * ratio * Math.pow(2, octaveDiff);
                    
                    return Math.round(frequency * 100) / 100; // Round to 2 decimal places
                };
                
                const calculateFrequency = () => {
                    if (newNoteName.value) {
                        const freq = noteToFrequency(newNoteName.value);
                        if (freq !== null) {
                            newNoteFreq.value = freq;
                        }
                    }
                };
                
                const updateNoteFrequency = (idx) => {
                    if (idx < 0 || idx >= noteData.length) return;
                    const note = noteData[idx];
                    // If note name is changed, try to recalculate frequency
                    if (note.note) {
                        const freq = noteToFrequency(note.note);
                        if (freq !== null) {
                            note.freq = freq;
                        }
                    }
                };
                
                const addNote = () => {
                    if (!newNoteName.value) return;
                    // Auto-calculate frequency if not set
                    if (!newNoteFreq.value) {
                        const freq = noteToFrequency(newNoteName.value);
                        if (freq === null) {
                            alert('Invalid note format. Use format like: E4, C#5, Bb3');
                            return;
                        }
                        newNoteFreq.value = freq;
                    }
                    
                    const color = colors[noteData.length % colors.length];
                    noteData.push({
                        note: newNoteName.value,
                        freq: newNoteFreq.value,
                        color: color,
                        volume: 70,
                        enabled: true
                    });
                    newNoteName.value = '';
                    newNoteFreq.value = null;
                };
                
                const removeNote = (idx) => {
                    noteData.splice(idx, 1);
                };
                
                const createNewPalette = () => {
                    const name = prompt('Enter palette name:') || 'Untitled';
                    currentPaletteName.value = name;
                    noteData.length = 0; // Clear current notes
                    newNoteName.value = '';
                    newNoteFreq.value = null;
                };
                
                const saveCurrentPalette = () => {
                    const name = prompt('Save palette as:', currentPaletteName.value) || currentPaletteName.value;
                    if (!name) return;
                    
                    const palette = {
                        name: name,
                        notes: noteData.map(n => ({
                            note: n.note,
                            freq: n.freq,
                            color: n.color,
                            volume: n.volume,
                            enabled: n.enabled
                        }))
                    };
                    
                    const palettes = JSON.parse(localStorage.getItem('soundmarbles-palettes') || '[]');
                    // Remove existing palette with same name if exists
                    const existingIndex = palettes.findIndex(p => p.name === name);
                    if (existingIndex >= 0) {
                        palettes[existingIndex] = palette;
                    } else {
                        palettes.push(palette);
                    }
                    localStorage.setItem('soundmarbles-palettes', JSON.stringify(palettes));
                    currentPaletteName.value = name;
                    alert(`Palette "${name}" saved!`);
                };
                
                const loadPalette = () => {
                    const palettes = JSON.parse(localStorage.getItem('soundmarbles-palettes') || '[]');
                    if (palettes.length === 0) {
                        alert('No saved palettes found. Create and save a palette first.');
                        return;
                    }
                    
                    const names = palettes.map((p, i) => `${i + 1}: ${p.name}`).join('\n');
                    const input = prompt(`Select palette:\n${names}\n\nEnter number:`);
                    if (input === null || !input.trim()) return;
                    
                    const index = parseInt(input) - 1;
                    if (isNaN(index) || index < 0 || index >= palettes.length) {
                        alert('Invalid selection');
                        return;
                    }
                    
                    const palette = palettes[index];
                    currentPaletteName.value = palette.name;
                    noteData.length = 0;
                    palette.notes.forEach(n => {
                        noteData.push({
                            note: n.note,
                            freq: n.freq,
                            color: n.color,
                            volume: n.volume,
                            enabled: n.enabled
                        });
                    });
                    
                    // Restart generators if playing
                    if (isPlaying.value) {
                        startAllGenerators();
                    }
                };
                
                // Watch for numGenerators changes and restart if playing
                watch(() => settings.numGenerators, () => {
                    if (isPlaying.value) {
                        startAllGenerators();
                    }
                });
                
                const resizeCanvas = () => {
                    const c = canvas.value;
                    if (!c) return;
                    const dpr = window.devicePixelRatio || 1;
                    // Use window dimensions directly for more reliable sizing
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    c.width = width * dpr;
                    c.height = height * dpr;
                    c.style.width = width + 'px';
                    c.style.height = height + 'px';
                    if (ctx.value) {
                        ctx.value.setTransform(1, 0, 0, 1, 0, 0);
                        ctx.value.scale(dpr, dpr);
                    }
                };
                
                // Detect if this is a slave device
                const urlParams = new URLSearchParams(window.location.search);
                const isSlave = urlParams.get('slave') === 'true';
                console.log('ðŸ” Device detection:', {
                    url: window.location.href,
                    search: window.location.search,
                    isSlave: isSlave,
                    slaveParam: urlParams.get('slave')
                });
                
                // WebSocket connection for master-slave communication
                const ws = ref(null);
                const wsConnected = ref(false); // Track if we've successfully connected
                const wsReceivedWelcome = ref(false); // Track if we've received welcome message
                const wsError = ref(null); // Track WebSocket errors for display
                const slaveStatus = ref(''); // Status message for slaves
                const slaveId = isSlave ? `slave-${Date.now()}-${Math.random().toString(36).substr(2, 9)}` : null;
                const assignedNotes = ref([]); // For slaves - when master is included, masterAssignedNotes is used instead
                const noteRotationIndex = ref(0); // Track which note to play next (for rotation)
                const shuffledNoteIndices = ref([]); // Shuffled array of note indices to ensure all notes are played
                
                const getServerUrl = () => {
                    const hostname = window.location.hostname;
                    const port = window.location.port || '3000';
                    
                    // If accessing via localhost, try to get the actual IP
                    if (hostname === 'localhost' || hostname === '127.0.0.1') {
                        // For mobile devices scanning, we need the actual IP
                        // The server is running on the Mac, so we'll use the IP we found earlier
                        // In a real scenario, you'd want to detect this dynamically
                        // For now, we'll construct it from the current connection
                        return `http://192.168.2.34:${port}`;
                    }
                    
                    // Otherwise use the current hostname
                    return `${window.location.protocol}//${hostname}${port ? ':' + port : ''}${window.location.pathname}`;
                };
                
                const getWebSocketUrl = () => {
                    // Use same port as HTTP (3000) - WebSocket is now on same port
                    const wsPort = 3000;
                    const hostname = window.location.hostname;
                    const port = window.location.port || wsPort;
                    
                    // Determine WebSocket URL to use
                    let wsHost;
                    
                    // For slaves accessing via QR code, they'll be on the IP address
                    // For external devices (like iPhone), always use the IP from the URL
                    if (hostname === 'localhost' || hostname === '127.0.0.1') {
                        // If accessing via localhost, use localhost for WebSocket too (for same-device connections)
                        wsHost = 'localhost';
                    } else if (hostname.match(/^\d+\.\d+\.\d+\.\d+$/)) {
                        // If accessing via IP address (like 192.168.2.34), use that same IP
                        wsHost = hostname;
                    } else {
                        // For any other hostname (like domain names), use as-is
                        wsHost = hostname;
                    }
                    
                    // Use ws:// protocol (wss:// only if page is loaded via https://)
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${wsHost}:${port}`;
                    
                    console.log('getWebSocketUrl() called - returning:', wsUrl);
                    console.log('Current window.location:', {
                        hostname: window.location.hostname,
                        port: window.location.port,
                        href: window.location.href,
                        protocol: window.location.protocol
                    });
                    console.log('Using WebSocket host:', wsHost);
                    console.log('Using WebSocket protocol:', protocol);
                    console.log('Is slave:', isSlave);
                    console.log('User-Agent:', navigator.userAgent);
                    
                    return wsUrl;
                };
                
                const connectWebSocket = () => {
                    console.log('=== connectWebSocket() called ===');
                    console.log('Is slave:', isSlave);
                    const wsUrl = getWebSocketUrl();
                    console.log('WebSocket URL from getWebSocketUrl():', wsUrl);
                    // Validate URL before creating WebSocket
                    if (!wsUrl || wsUrl.includes('undefined')) {
                        console.error('Invalid WebSocket URL:', wsUrl);
                        if (isSlave) {
                            alert('Error: Invalid WebSocket URL. Please refresh the page.');
                        }
                        return;
                    }
                    console.log('=== WebSocket Connection Debug ===');
                    console.log('Connecting to WebSocket:', wsUrl);
                    console.log('Current hostname:', window.location.hostname);
                    console.log('Current port:', window.location.port);
                    console.log('Current URL:', window.location.href);
                    console.log('Is slave:', isSlave);
                    console.log('WebSocket port should be: 3000 (same as HTTP)');
                    console.log('URL validation:', wsUrl.includes(':3000') ? 'âœ“ Correct port' : 'âœ— Wrong port!');
                    console.log('Full WebSocket URL:', wsUrl);
                    
                    // Double-check URL is correct
                    if (!wsUrl.startsWith('ws://') && !wsUrl.startsWith('wss://')) {
                        console.error('ERROR: WebSocket URL must start with ws:// or wss://');
                        alert('Error: Invalid WebSocket protocol. URL: ' + wsUrl);
                        return;
                    }
                    // Port validation - should be 3000, but allow for flexibility
                    const urlMatch = wsUrl.match(/ws:\/\/[^:]+:(\d+)/);
                    if (urlMatch && urlMatch[1] !== '3000') {
                        console.warn('Warning: WebSocket URL port is', urlMatch[1], 'expected 3000');
                    }
                    
                    try {
                        console.log('Creating WebSocket with URL:', wsUrl);
                        const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);
                        console.log('Is iOS device:', isIOS);
                        if (isIOS) {
                            console.log('iOS device detected - WebSocket connection may require retries');
                            console.log('User-Agent:', navigator.userAgent);
                        }
                        
                        const websocket = new WebSocket(wsUrl);
                        ws.value = websocket;
                        console.log('WebSocket object created, initial state:', websocket.readyState);
                        
                        // Add connection timeout - increased to 20 seconds for network issues
                        let connectionTimeout = setTimeout(() => {
                            // Only timeout if still connecting (not if already opened and closed)
                            if (websocket.readyState === WebSocket.CONNECTING || websocket.readyState === 0) {
                                console.error('âœ— WebSocket connection timeout after 20 seconds');
                                console.error('URL attempted:', wsUrl);
                                console.error('ReadyState:', websocket.readyState);
                                console.error('WebSocket state:', {
                                    CONNECTING: WebSocket.CONNECTING,
                                    OPEN: WebSocket.OPEN,
                                    CLOSING: WebSocket.CLOSING,
                                    CLOSED: WebSocket.CLOSED,
                                    current: websocket.readyState
                                });
                                websocket.close();
                                ws.value = null;
                                if (isSlave) {
                                    const currentUrl = window.location.href;
                                    const errorMsg = 'WebSocket connection timeout.\n\n' +
                                        'Trying to connect to: ' + wsUrl + '\n' +
                                        'Current page: ' + currentUrl + '\n\n' +
                                        'HTTP works but WebSocket times out.\n\n' +
                                        'Possible causes:\n' +
                                        '1. Router firewall blocking WebSocket\n' +
                                        '2. iOS Safari WebSocket restrictions\n' +
                                        '3. Wi-Fi AP isolation enabled\n' +
                                        '4. Devices on different networks\n\n' +
                                        'To diagnose:\n' +
                                        '1. Check if http://' + window.location.hostname + ':3000 loads\n' +
                                        '2. Check router settings for WebSocket/firewall\n' +
                                        '3. Try a different Wi-Fi network\n' +
                                        '4. Check server logs for connection attempts';
                                    alert(errorMsg);
                                    console.error(errorMsg);
                                    console.error('WebSocket URL:', wsUrl);
                                    console.error('Current hostname:', window.location.hostname);
                                    console.error('Current port:', window.location.port);
                                }
                            } else {
                                console.log('Connection timeout check skipped - WebSocket state:', websocket.readyState);
                            }
                        }, 20000);
                        
                        websocket.onopen = () => {
                            clearTimeout(connectionTimeout);
                            wsConnected.value = true;
                            wsError.value = null; // Clear any previous errors
                            ws.value = websocket; // Update ws ref immediately
                            console.log('âœ“ WebSocket connected successfully!');
                            console.log('WebSocket readyState:', websocket.readyState);
                            console.log('WebSocket protocol:', websocket.protocol);
                            console.log('WebSocket extensions:', websocket.extensions);
                            console.log('wsConnected set to:', wsConnected.value);
                            
                            // Send registration immediately - don't wait for anything
                            // iOS Safari can close connections quickly if idle
                            if (isSlave) {
                                // Register as slave immediately - iOS Safari can close connections quickly
                                console.log('Registering as slave:', slaveId);
                                try {
                                    // Send immediately without setTimeout - iOS Safari needs fast registration
                                    const registerMessage = JSON.stringify({
                                        type: 'slave',
                                        id: slaveId
                                    });
                                    console.log('Sending registration immediately:', registerMessage);
                                    websocket.send(registerMessage);
                                    console.log('Registration message sent successfully');
                                } catch (e) {
                                    console.error('Error sending registration:', e);
                                    wsError.value = 'Registration failed: ' + e.message;
                                    // Try again after a short delay if first attempt failed
                                    setTimeout(() => {
                                        try {
                                            if (websocket.readyState === WebSocket.OPEN) {
                                                const registerMessage = JSON.stringify({
                                                    type: 'slave',
                                                    id: slaveId
                                                });
                                                websocket.send(registerMessage);
                                                console.log('Registration retry successful');
                                            }
                                        } catch (e2) {
                                            console.error('Registration retry failed:', e2);
                                        }
                                    }, 100);
                                }
                                
                                // Initialize audio context immediately for slaves
                                initAudio().then(() => {
                                    console.log('Slave audio context initialized');
                                }).catch(e => {
                                    console.error('Error initializing audio:', e);
                                });
                            } else {
                                // Register as master
                                console.log('Registering as master');
                                setTimeout(() => {
                                    try {
                                        if (websocket.readyState === WebSocket.OPEN) {
                                            websocket.send(JSON.stringify({
                                                type: 'master'
                                            }));
                                            console.log('Master registration sent');
                                        }
                                    } catch (e) {
                                        console.error('Error sending master registration:', e);
                                    }
                                }, 0);
                            }
                        };
                    
                    websocket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            console.log('=== WebSocket message received ===');
                            console.log('Type:', data.type);
                            console.log('Is slave:', isSlave);
                            console.log('Full message:', JSON.stringify(data));
                            
                            // Special logging for volume_update messages
                            if (data.type === 'volume_update') {
                                console.log('ðŸ”ŠðŸ”ŠðŸ”Š VOLUME_UPDATE MESSAGE DETECTED!');
                                console.log('  Volume:', data.volume);
                                console.log('  Is slave:', isSlave);
                                console.log('  masterGain exists:', !!masterGain);
                            }
                            
                            if (isSlave) {
                                // Handle slave messages
                                console.log('Processing slave message:', data.type);
                                if (data.type === 'welcome') {
                                    wsReceivedWelcome.value = true;
                                    wsConnected.value = true; // Ensure connected flag is set
                                    ws.value = websocket; // Update ws ref
                                    // Store slave name - ensure it's a string, use totalSlaves as fallback
                                    if (data.slaveName !== undefined && data.slaveName !== null) {
                                        slaveName.value = String(data.slaveName);
                                    } else if (data.totalSlaves !== undefined) {
                                        // Fallback: use totalSlaves count as the number
                                        slaveName.value = String(data.totalSlaves);
                                    } else {
                                        slaveName.value = null;
                                    }
                                    console.log('âœ“ Slave registered:', data.slaveId, `(Name: ${data.slaveName || 'unnamed'})`);
                                    console.log('  slaveName.value set to:', slaveName.value, '(type:', typeof slaveName.value, ')');
                                    console.log('  data.slaveName:', data.slaveName, '(type:', typeof data.slaveName, ')');
                                    console.log('  Full welcome message:', JSON.stringify(data));
                                    console.log('Total slaves:', data.totalSlaves);
                                    console.log('Slave connection status updated - connected:', wsConnected.value, 'welcome:', wsReceivedWelcome.value, 'readyState:', ws.value?.readyState);
                                    
                                    // After receiving welcome, wait a moment for notes_assigned
                                    // If no notes arrive, request current state from master
                                    setTimeout(() => {
                                        if (assignedNotes.value.length === 0) {
                                            console.log('âš ï¸ No notes assigned after welcome message');
                                            console.log('Requesting current state from master...');
                                            // Request current preset from master
                                            if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                                ws.value.send(JSON.stringify({
                                                    type: 'request_preset'
                                                }));
                                                console.log('âœ“ Request preset message sent');
                                            } else {
                                                console.log('âœ— WebSocket not ready, cannot request preset');
                                            }
                                        } else {
                                            console.log('âœ“ Notes received after reconnect:', assignedNotes.value.length);
                                        }
                                    }, 1000); // Wait 1 second for notes to arrive
                                    
                                    // Force Vue to update by triggering a small delay
                                    setTimeout(() => {
                                        console.log('Status check - ws:', !!ws.value, 'wsConnected:', wsConnected.value, 'wsReceivedWelcome:', wsReceivedWelcome.value, 'assignedNotes:', assignedNotes.value.length);
                                    }, 100);
                                } else if (data.type === 'notes_assigned') {
                                    console.log('Notes assigned:', data.notes);
                                    console.log('Assigned notes count:', data.notes.length);
                                    assignedNotes.value = data.notes;
                                    // Reset note rotation when new notes are assigned
                                    noteRotationIndex.value = 0;
                                    shuffledNoteIndices.value = [];
                                    console.log('Reset note rotation for new assignment');
                                    
                                    // Notify master about assigned notes
                                    if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                        try {
                                            const message = {
                                                type: 'slave_notes_assigned',
                                                notes: data.notes
                                            };
                                            console.log('ðŸ“¤ Slave sending slave_notes_assigned to server:', JSON.stringify(message));
                                            ws.value.send(JSON.stringify(message));
                                            console.log('âœ“ Sent slave_notes_assigned message to server');
                                        } catch (e) {
                                            console.error('Error sending slave_notes_assigned message:', e);
                                        }
                                    } else {
                                        console.warn('âš ï¸ Cannot send slave_notes_assigned - WebSocket not ready:', ws.value?.readyState);
                                    }
                                    
                                    // Update slave name if provided
                                    if (data.slaveName !== undefined && data.slaveName !== null) {
                                        slaveName.value = String(data.slaveName);
                                        console.log('  âœ“ Slave name updated from notes_assigned:', data.slaveName);
                                    } else {
                                        console.log('  âš ï¸ notes_assigned message did not include slaveName');
                                        console.log('  Full notes_assigned message:', JSON.stringify(data));
                                        // Fallback: try to infer name from slaveId or use a default
                                        if (!slaveName.value && data.slaveId) {
                                            // This is a fallback - server should send slaveName
                                            console.log('  âš ï¸ Using fallback - slaveName not received from server');
                                        }
                                    }
                                    // Update settings from master
                                    if (data.preset) {
                                        settings.noteLength = data.preset.noteLength;
                                        settings.pauseLength = data.preset.pauseLength;
                                        settings.masterVolume = data.preset.masterVolume;
                                        // Slaves always use 1 generator - don't override numGenerators
                                        // settings.numGenerators should remain 1 for slaves
                                    }
                                    // Apply per-slave volume to masterGain if provided
                                    if (data.slaveVolume !== undefined && data.slaveVolume !== null && isSlave) {
                                        const slaveVolumePercent = parseInt(data.slaveVolume);
                                        if (!isNaN(slaveVolumePercent) && slaveVolumePercent >= 0 && slaveVolumePercent <= 100) {
                                            // Store the per-slave volume
                                            slaveVolume.value = slaveVolumePercent;
                                            
                                            console.log(`  ðŸ”Š Stored per-slave volume from notes_assigned: ${slaveVolumePercent}% (will be applied via volume_update to prevent conflicts)`);
                                            // Don't apply volume here - let volume_update message handle it to prevent conflicts
                                        }
                                    }
                                    
                                    // When master volume changes in preset, update settings but don't recalculate slave gain here
                                    // The volume_update message will handle the actual gain update
                                    if (data.preset?.masterVolume !== undefined && isSlave) {
                                        settings.masterVolume = data.preset.masterVolume;
                                        console.log(`  ðŸ“Š Master volume updated in settings: ${data.preset.masterVolume}% (will be applied via volume_update)`);
                                    }
                                    // Force Vue to update UI
                                    wsConnected.value = true;
                                    wsReceivedWelcome.value = true;
                                    ws.value = websocket;
                                    console.log('Status after notes assigned - wsConnected:', wsConnected.value, 'wsReceivedWelcome:', wsReceivedWelcome.value, 'notes:', assignedNotes.value.length);
                                    
                                    // Don't start automatically - wait for 'play' command from master
                                    console.log('Notes assigned, waiting for master play command...');
                                    
                                    // Prepare audio context and check if already unlocked
                                    initAudio().then(() => {
                                        const audioState = audioContext ? audioContext.state : 'unknown';
                                        console.log('Audio context prepared, state:', audioState);
                                        console.log('masterGain:', !!masterGain);
                                        
                                        if (audioContext && audioContext.state === 'running') {
                                            // Audio already unlocked from first interaction
                                            slaveStatus.value = 'Ready';
                                            console.log('âœ“ Audio already unlocked, ready to play');
                                            // Start drone note to keep audio context active
                                            startDroneNote();
                                        } else {
                                            // Audio not unlocked yet - will need first tap
                                            slaveStatus.value = 'Waiting for master...';
                                            console.log('Audio not unlocked yet, will need interaction');
                                            console.log('Audio context state:', audioContext?.state);
                                        }
                                    }).catch(e => {
                                        console.error('Error initializing audio:', e);
                                        slaveStatus.value = 'Waiting for master...';
                                    });
                                } else if (data.type === 'play') {
                                    console.log('âœ“âœ“âœ“ Master play command received by slave');
                                    console.log('Current state - isPlaying:', isPlaying.value, 'assignedNotes:', assignedNotes.value.length);
                                    
                                    if (assignedNotes.value.length === 0) {
                                        console.warn('No notes assigned yet, cannot start playback');
                                        return;
                                    }
                                    
                                    if (isPlaying.value) {
                                        console.log('Already playing, ignoring play command');
                                        return;
                                    }
                                    
                                    // Start playing when master sends play command
                                    console.log('Initializing audio and starting playback...');
                                    slaveStatus.value = 'Starting...';
                                    
                                    // Ensure audio context exists
                                    if (!audioContext) {
                                        console.log('Audio context not initialized, creating...');
                                    }
                                    
                                    console.log('About to call initAudio...');
                                    initAudio().then((ctx) => {
                                        console.log('initAudio promise resolved!');
                                        console.log('Returned ctx:', !!ctx);
                                        const audioState = ctx ? ctx.state : (audioContext ? audioContext.state : 'unknown');
                                        console.log('Audio context state after init:', audioState);
                                        console.log('Audio context exists:', !!audioContext);
                                        console.log('Master gain exists:', !!masterGain);
                                        
                                        // Check if audio context and master gain are ready
                                        if (!audioContext || !masterGain) {
                                            console.error('Audio context or master gain not ready!');
                                            console.error('audioContext:', !!audioContext, 'masterGain:', !!masterGain);
                                            slaveStatus.value = 'Audio not ready';
                                            wsError.value = 'Audio not ready';
                                            return;
                                        }
                                        
                                        if (audioContext.state === 'running') {
                                            // Audio is already unlocked, start immediately
                                            console.log('âœ“ Audio already unlocked, starting playback');
                                            isPlaying.value = true;
                                            slaveStatus.value = 'Playing';
                                            console.log('isPlaying set to:', isPlaying.value);
                                            startSlavePlayback();
                                        } else if (audioContext.state === 'suspended') {
                                            // Audio is suspended, try to resume automatically
                                            console.log('Audio suspended, attempting to resume automatically...');
                                            slaveStatus.value = 'Resuming audio...';
                                            
                                            // Try to resume - this should work if user has interacted with page
                                            // Use a small delay to ensure we're in a user gesture context
                                            setTimeout(() => {
                                                console.log('About to call audioContext.resume()...');
                                                const resumePromise = audioContext.resume();
                                                const timeoutPromise = new Promise((_, reject) => 
                                                    setTimeout(() => reject(new Error('Resume timeout')), 2000)
                                                );
                                                Promise.race([resumePromise, timeoutPromise]).then(() => {
                                                    console.log('âœ“âœ“âœ“ Audio context resumed automatically, state:', audioContext.state);
                                                    console.log('About to start playback...');
                                                    isPlaying.value = true;
                                                    slaveStatus.value = 'Playing';
                                                    console.log('isPlaying set to:', isPlaying.value);
                                                    console.log('Calling startSlavePlayback()...');
                                                    startSlavePlayback();
                                                    console.log('startSlavePlayback() called');
                                                }).catch(e => {
                                                    console.log('Resume failed/timed out, but audio might still work - starting playback anyway');
                                                    // Resume failed or timed out - try to start anyway (might work)
                                                    console.log('Audio resume failed/timed out, but trying to start playback anyway:', e.message);
                                                    isPlaying.value = true;
                                                    slaveStatus.value = 'Playing';
                                                    console.log('Calling startSlavePlayback() despite resume failure...');
                                                    startSlavePlayback();
                                                    
                                                    // Also show tap message as fallback
                                                    slaveStatus.value = 'Tap if no sound';
                                                    
                                                    // Add one-time handler to resume on next interaction
                                                    const resumeOnTap = () => {
                                                        slaveStatus.value = 'Starting...';
                                                        wsError.value = null;
                                                        audioContext.resume().then(() => {
                                                            isPlaying.value = true;
                                                            slaveStatus.value = 'Playing';
                                                            startSlavePlayback();
                                                        });
                                                        document.removeEventListener('touchstart', resumeOnTap, { capture: true });
                                                        document.removeEventListener('click', resumeOnTap, { capture: true });
                                                    };
                                                    document.addEventListener('touchstart', resumeOnTap, { capture: true, passive: true });
                                                    document.addEventListener('click', resumeOnTap, { capture: true, passive: true });
                                                });
                                            }, 100);
                                        } else {
                                            // Unknown state, try to start anyway
                                            console.log('Starting playback (unknown audio state:', audioContext.state, ')');
                                            isPlaying.value = true;
                                            slaveStatus.value = 'Playing';
                                            console.log('isPlaying set to:', isPlaying.value);
                                            startSlavePlayback();
                                        }
                                    }).catch(e => {
                                        console.error('âœ—âœ—âœ— Error initializing audio:', e);
                                        console.error('Error stack:', e.stack);
                                        // Try to start anyway - audio might still work
                                        console.log('Attempting to start playback despite error...');
                                        // Ensure audio context exists even if init failed
                                        if (!audioContext) {
                                            try {
                                                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                                                masterGain = audioContext.createGain();
                                                masterGain.gain.value = settings.masterMuted ? 0 : settings.masterVolume / 100;
                                                masterGain.connect(audioContext.destination);
                                                console.log('Created audio context in error handler');
                                            } catch (err) {
                                                console.error('Failed to create audio context in error handler:', err);
                                            }
                                        }
                                        isPlaying.value = true;
                                        slaveStatus.value = 'Playing';
                                        startSlavePlayback();
                                    });
                                } else if (data.type === 'volume_update') {
                                    // Master sent volume update for this slave
                                    console.log(`ðŸ”ŠðŸ”ŠðŸ”ŠðŸ”ŠðŸ”Š SLAVE RECEIVED VOLUME UPDATE: ${data.volume}%`);
                                    console.log(`  masterGain exists:`, !!masterGain);
                                    console.log(`  audioContext exists:`, !!audioContext);
                                    console.log(`  Current masterGain.value:`, masterGain?.gain?.value);
                                    console.log(`  audioContext.state:`, audioContext?.state);
                                    
                                    if (!masterGain) {
                                        console.error('  âœ—âœ—âœ— masterGain is null/undefined! Cannot apply volume update');
                                        return;
                                    }
                                    
                                    if (!audioContext) {
                                        console.error('  ERROR: audioContext is null/undefined! Cannot apply volume update');
                                        return;
                                    }
                                    
                                    // Store the per-slave volume
                                    slaveVolume.value = data.volume || 100;
                                    
                                    // Calculate target gain: slave volume * master volume
                                    // Both are percentages, so: (slaveVolume / 100) * (masterVolume / 100)
                                    const masterVolumePercent = settings.masterVolume || 70; // Default to 70% if not set
                                    const slaveVolumePercent = slaveVolume.value;
                                    const targetGain = (slaveVolumePercent / 100) * (masterVolumePercent / 100);
                                    const now = audioContext.currentTime;
                                    
                                    // Get current gain value, accounting for any scheduled changes
                                    let currentGain = masterGain.gain.value;
                                    // Cancel any scheduled changes and get the actual current value
                                    masterGain.gain.cancelScheduledValues(now);
                                    currentGain = masterGain.gain.value; // Re-read after cancellation
                                    
                                    console.log(`  ðŸ“Š Per-slave volume update:`);
                                    console.log(`    Slave volume: ${slaveVolumePercent}%`);
                                    console.log(`    Master volume: ${masterVolumePercent}%`);
                                    console.log(`    Combined gain: ${currentGain} â†’ ${targetGain}`);
                                    
                                    // Use setTargetAtTime for smoother transitions
                                    const epsilon = 0.0001;
                                    const targetGainSafe = Math.max(targetGain, epsilon);
                                    
                                    // Cancel scheduled changes and use setTargetAtTime for smooth transition
                                    masterGain.gain.cancelScheduledValues(now);
                                    masterGain.gain.setTargetAtTime(targetGainSafe, now, 0.15);
                                    
                                    console.log(`  âœ“ Applied per-slave volume update: ${slaveVolumePercent}% â†’ gain ${targetGain.toFixed(4)}`);
                                    
                                    // Note: setTargetAtTime uses exponential approach, so it asymptotically approaches the target
                                    // This is expected behavior - the gain will smoothly approach the target over time
                                } else if (data.type === 'stop') {
                                    console.log('Master stop command received - graceful stop with smooth fade-out');
                                    isPlaying.value = false;
                                    slaveStatus.value = 'Waiting for master...';
                                    // Clear all scheduled timeouts to prevent new notes
                                    generatorTimeouts.forEach(timeout => {
                                        if (timeout) clearTimeout(timeout);
                                    });
                                    generatorTimeouts.length = 0;
                                    
                                    // Smoothly fade out all currently playing oscillators
                                    if (audioContext && activeOscillators.size > 0) {
                                        // Define fade-out function
                                        const performSlaveFadeOut = () => {
                                            if (!audioContext || activeOscillators.size === 0) return;
                                            
                                            const now = audioContext.currentTime;
                                            const fadeOutDuration = 0.25; // 250ms fade-out for smooth stop (longer for iOS)
                                            
                                            console.log(`Slave: Fading out ${activeOscillators.size} oscillators over ${fadeOutDuration}s`);
                                            
                                            activeOscillators.forEach(osc => {
                                                try {
                                                    // Calculate when this oscillator was supposed to stop naturally
                                                    const naturalStopTime = osc._startTime ? (osc._startTime + osc._duration) : (now + 1);
                                                    const timeUntilNaturalStop = naturalStopTime - now;
                                                    
                                                    // Fade out the gain node smoothly
                                                    if (osc._oscGain) {
                                                        // Get current gain value - use scheduled value if available
                                                        let currentGain;
                                                        try {
                                                            currentGain = osc._oscGain.gain.value;
                                                            // If gain is already very low or zero, use a small value to ensure smooth fade
                                                            if (currentGain < 0.001) {
                                                                currentGain = 0.01; // Use small value to ensure fade is audible
                                                            }
                                                        } catch (e) {
                                                            currentGain = 0.01; // Fallback
                                                        }
                                                        
                                                        console.log(`Slave: Fading oscillator, current gain: ${currentGain}, natural stop in: ${timeUntilNaturalStop.toFixed(3)}s`);
                                                        
                                                        // Cancel any scheduled values and start fresh fade-out
                                                        osc._oscGain.gain.cancelScheduledValues(now);
                                                        osc._oscGain.gain.setValueAtTime(currentGain, now);
                                                        
                                                        // Use the shorter of: fade-out duration or time until natural stop
                                                        const actualFadeTime = Math.min(fadeOutDuration, Math.max(0.05, timeUntilNaturalStop));
                                                        osc._oscGain.gain.linearRampToValueAtTime(0, now + actualFadeTime);
                                                        
                                                        // Stop oscillator after fade completes
                                                        const stopTime = now + actualFadeTime + 0.01;
                                                        osc.stop(stopTime);
                                                        
                                                        console.log(`Slave: Scheduled fade-out over ${actualFadeTime.toFixed(3)}s, stop at ${stopTime.toFixed(3)}`);
                                                    } else {
                                                        // Oscillator doesn't have metadata - try to let it finish naturally
                                                        console.log('Slave: Oscillator missing metadata, letting it finish naturally');
                                                        if (timeUntilNaturalStop > 0 && timeUntilNaturalStop < 5) {
                                                            // Only if it's supposed to stop soon, let it finish
                                                            // Otherwise schedule a quick fade
                                                            osc.stop(Math.min(naturalStopTime, now + fadeOutDuration));
                                                        }
                                                    }
                                                } catch (e) {
                                                    console.error('Slave: Error fading out oscillator:', e);
                                                    // Fallback: schedule a gentle stop
                                                    try {
                                                        const gentleStop = now + fadeOutDuration;
                                                        osc.stop(gentleStop);
                                                    } catch (e2) {
                                                        console.error('Slave: Could not schedule gentle stop:', e2);
                                                    }
                                                }
                                            });
                                        };
                                        
                                        // Ensure audio context is running (especially important for iOS)
                                        if (audioContext.state === 'suspended') {
                                            console.log('Slave: Audio context suspended, attempting to resume before fade-out...');
                                            audioContext.resume().then(() => {
                                                console.log('Slave: Audio context resumed, proceeding with fade-out');
                                                performSlaveFadeOut();
                                            }).catch(e => {
                                                console.error('Slave: Could not resume audio context:', e);
                                                // Try fade-out anyway
                                                performSlaveFadeOut();
                                            });
                                        } else {
                                            performSlaveFadeOut();
                                        }
                                    } else {
                                        console.log('Slave: No active oscillators to fade out');
                                    }
                                    
                                    // Clear the set after fade-out completes
                                    setTimeout(() => {
                                        activeOscillators.clear();
                                    }, 300); // Wait for fade-out to complete
                                    
                                    // Keep drone note running even when stopped (for slaves)
                                    // This ensures audio context stays active
                                    if (audioContext && audioContext.state === 'running' && !droneOscillator) {
                                        startDroneNote();
                                    }
                                }
                            } else {
                                // Handle master messages
                                if (data.type === 'slaves') {
                                    // Initial message from server with current slave count
                                    console.log('ðŸ“¡ Master received initial slaves list');
                                    console.log('  Slave count:', data.count);
                                    console.log('  Slave IDs:', data.slaves);
                                    
                                    // Update total slaves count
                                    totalSlaves.value = data.count || 0;
                                    
                                    // Populate connectedSlaves array with initial slave list
                                    // This is the authoritative list from the server - always use it to sync
                                    if (data.slaves && Array.isArray(data.slaves)) {
                                        console.log(`  ðŸ“‹ Server sent ${data.slaves.length} slaves:`, data.slaves);
                                        
                                        // Preserve existing settings for slaves that are still connected
                                        const settingsMap = new Map();
                                        connectedSlaves.forEach(slave => {
                                            settingsMap.set(slave.id, {
                                                volume: slave.volume,
                                                assignedNotes: slave.assignedNotes || [],
                                                currentlyPlayingNote: slave.currentlyPlayingNote
                                            });
                                        });
                                        
                                        // Clear existing and repopulate from server's authoritative list
                                        connectedSlaves.length = 0;
                                        data.slaves.forEach(slaveInfo => {
                                            // Handle both old format (string IDs) and new format (objects with id and name)
                                            const slaveId = typeof slaveInfo === 'string' ? slaveInfo : slaveInfo.id;
                                            const slaveName = typeof slaveInfo === 'string' ? null : slaveInfo.name;
                                            const serverAssignedNotes = typeof slaveInfo === 'object' ? (slaveInfo.assignedNotes || []) : [];
                                            
                                            if (slaveId) { // Only add valid IDs
                                                const existingSettings = settingsMap.get(slaveId);
                                                
                                                // Priority: server's assignedNotes > existing > pending
                                                let assignedNotes = [];
                                                if (serverAssignedNotes.length > 0) {
                                                    assignedNotes = serverAssignedNotes;
                                                    console.log(`  âœ“ Using server's assigned notes for slave ${slaveId}:`, assignedNotes.map(n => n.note));
                                                } else if (existingSettings?.assignedNotes && existingSettings.assignedNotes.length > 0) {
                                                    assignedNotes = existingSettings.assignedNotes;
                                                    console.log(`  âœ“ Using existing assigned notes for slave ${slaveId}:`, assignedNotes.map(n => n.note));
                                                } else if (window.pendingSlaveNotes && window.pendingSlaveNotes[slaveId]) {
                                                    assignedNotes = window.pendingSlaveNotes[slaveId];
                                                    console.log(`  âœ“ Applied pending notes for slave ${slaveId}:`, assignedNotes.map(n => n.note));
                                                    delete window.pendingSlaveNotes[slaveId];
                                                }
                                                
                                                connectedSlaves.push({
                                                    id: slaveId,
                                                    name: slaveName || String(connectedSlaves.length + 1), // Use name if provided, otherwise use index
                                                    volume: existingSettings?.volume !== undefined ? existingSettings.volume : 100, // Preserve volume or default to 100
                                                    assignedNotes: assignedNotes, // Use server's notes, existing, or pending
                                                    currentlyPlayingNote: existingSettings?.currentlyPlayingNote || null // Preserve currently playing note
                                                });
                                            }
                                        });
                                        
                                        console.log(`  âœ“ Synced connectedSlaves with server: ${connectedSlaves.length} unique slaves`);
                                        console.log(`  Slaves:`, connectedSlaves.map(s => `${s.name} (${s.id})`));
                                        
                                        // Calculate assigned notes for all slaves (master knows the distribution logic)
                                        const enabledNotes = noteData.filter(n => n.enabled);
                                        if (enabledNotes.length > 0 && connectedSlaves.length > 0) {
                                            console.log(`  ðŸ“Š Calculating assigned notes for ${connectedSlaves.length} slaves...`);
                                            distributeNotesToSlaves(enabledNotes, settings.masterIncluded);
                                            console.log(`  âœ“ Assigned notes calculated for all slaves`);
                                        }
                                        
                                        // Also send preset to server to ensure slaves receive it
                                        const slavesWithoutNotes = connectedSlaves.filter(slave => !slave.assignedNotes || slave.assignedNotes.length === 0);
                                        if (slavesWithoutNotes.length > 0) {
                                            console.log(`  âš ï¸ ${slavesWithoutNotes.length} slaves still have no assigned notes after calculation`);
                                        }
                                        
                                        // Send preset to server to ensure slaves receive notes
                                        if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                            setTimeout(() => {
                                                sendPresetToSlaves();
                                                console.log(`  âœ“ Preset sent to server for slave distribution`);
                                            }, 100);
                                        } else {
                                            console.warn(`  âš ï¸ WebSocket not ready, notes calculated locally but not sent to server`);
                                        }
                                        
                                        // Verify count matches
                                        if (connectedSlaves.length !== data.count) {
                                            console.warn(`  âš ï¸ Count mismatch: connectedSlaves.length=${connectedSlaves.length}, data.count=${data.count}`);
                                        }
                                    }
                                    
                                    // Automatically update numGenerators to match number of slaves
                                    if (data.count !== undefined && data.count >= 0) {
                                        const newGeneratorCount = Math.max(1, data.count); // At least 1 generator
                                        if (settings.numGenerators !== newGeneratorCount) {
                                            console.log(`  ðŸ”„ Auto-updating generators: ${settings.numGenerators} â†’ ${newGeneratorCount} (matching ${data.count} slaves)`);
                                            settings.numGenerators = newGeneratorCount;
                                        }
                                    }
                                } else if (data.type === 'notes_assigned') {
                                    // Master received assigned notes from server
                                    console.log('âœ“âœ“âœ“ Master received assigned notes:', data.notes.length, 'notes');
                                    console.log('Notes:', data.notes.map(n => n.note));
                                    masterAssignedNotes.value = data.notes;
                                    console.log('masterAssignedNotes.value updated to:', masterAssignedNotes.value.length, 'notes');
                                    // Update settings from server
                                    if (data.preset) {
                                        settings.noteLength = data.preset.noteLength;
                                        settings.pauseLength = data.preset.pauseLength;
                                        settings.masterVolume = data.preset.masterVolume;
                                        // Don't override numGenerators - it's auto-managed based on slave count
                                        // settings.numGenerators is automatically set to match totalSlaves
                                    }
                                    // If already playing, restart generators with new notes
                                    if (isPlaying.value) {
                                        console.log('Master is playing, restarting generators with new notes...');
                                        startAllGenerators();
                                    } else {
                                        console.log('Master not playing, notes updated but not restarting');
                                    }
                                } else if (data.type === 'slave_notes_assigned') {
                                    // Slave reported its assigned notes
                                    console.log('ðŸ“¥ Master received slave_notes_assigned:', data);
                                    console.log('  Slave ID:', data.slaveId);
                                    console.log('  Notes count:', data.notes?.length);
                                    console.log('  All connected slaves:', connectedSlaves.map(s => `${s.name} (${s.id})`));
                                    
                                    if (!data.slaveId || !data.notes) {
                                        console.error(`  âœ— Invalid slave_notes_assigned message: missing slaveId or notes`);
                                        return;
                                    }
                                    
                                    // Try to find the slave by exact ID match
                                    let slave = connectedSlaves.find(s => s.id === data.slaveId);
                                    
                                    // If not found, try string comparison (in case of type mismatch)
                                    if (!slave) {
                                        console.log(`  Trying string comparison for slave ID...`);
                                        slave = connectedSlaves.find(s => String(s.id) === String(data.slaveId));
                                    }
                                    
                                    // If still not found, try partial match (in case IDs are truncated)
                                    if (!slave) {
                                        console.log(`  Trying partial match for slave ID...`);
                                        slave = connectedSlaves.find(s => 
                                            String(s.id).startsWith(String(data.slaveId)) || 
                                            String(data.slaveId).startsWith(String(s.id))
                                        );
                                    }
                                    
                                    if (slave) {
                                        if (data.notes && Array.isArray(data.notes)) {
                                            slave.assignedNotes = data.notes;
                                            console.log(`  âœ“âœ“âœ“ Updated assigned notes for slave ${slave.name} (${slave.id}):`, data.notes.map(n => n.note));
                                            console.log(`  Slave object after update:`, slave);
                                        } else {
                                            console.warn(`  âš ï¸ Invalid notes data for slave ${slave.name}:`, data.notes);
                                        }
                                    } else {
                                        console.warn(`  âš ï¸ Slave "${data.slaveId}" not found in connectedSlaves - storing notes for later`);
                                        console.warn(`  Available slave IDs:`, connectedSlaves.map(s => `"${s.id}"`));
                                        console.warn(`  Available slave names:`, connectedSlaves.map(s => `${s.name} (${s.id})`));
                                        
                                        // Store notes temporarily - they'll be matched when slave list syncs
                                        // Add a pending notes object that will be matched on next sync
                                        if (!window.pendingSlaveNotes) {
                                            window.pendingSlaveNotes = {};
                                        }
                                        window.pendingSlaveNotes[data.slaveId] = data.notes;
                                        console.log(`  âœ“ Stored pending notes for slave ${data.slaveId} (${data.notes.length} notes), will apply on next sync`);
                                        
                                        // Also try to match by checking if any slave ID contains this ID or vice versa
                                        const partialMatch = connectedSlaves.find(s => 
                                            String(s.id).includes(String(data.slaveId)) || 
                                            String(data.slaveId).includes(String(s.id))
                                        );
                                        if (partialMatch) {
                                            console.log(`  ðŸ” Found partial match! Applying notes to ${partialMatch.name} (${partialMatch.id})`);
                                            partialMatch.assignedNotes = data.notes;
                                            delete window.pendingSlaveNotes[data.slaveId];
                                        }
                                    }
                                } else if (data.type === 'note_playing') {
                                    // Slave reported currently playing note
                                    console.log('ðŸŽµ Master received note_playing:', data);
                                    console.log('  Slave ID:', data.slaveId);
                                    console.log('  Note:', data.note);
                                    
                                    if (!data.slaveId || !data.note) {
                                        console.error(`  âœ— Invalid note_playing message: missing slaveId or note`);
                                        return;
                                    }
                                    
                                    // Try to find the slave by exact ID match
                                    let slave = connectedSlaves.find(s => s.id === data.slaveId);
                                    
                                    // If not found, try string comparison (in case of type mismatch)
                                    if (!slave) {
                                        console.log(`  Trying string comparison for slave ID...`);
                                        slave = connectedSlaves.find(s => String(s.id) === String(data.slaveId));
                                    }
                                    
                                    // If still not found, try partial match (in case IDs are truncated)
                                    if (!slave) {
                                        console.log(`  Trying partial match for slave ID...`);
                                        slave = connectedSlaves.find(s => 
                                            String(s.id).startsWith(String(data.slaveId)) || 
                                            String(data.slaveId).startsWith(String(s.id)) ||
                                            String(s.id).includes(String(data.slaveId)) || 
                                            String(data.slaveId).includes(String(s.id))
                                        );
                                    }
                                    
                                    if (slave) {
                                        slave.currentlyPlayingNote = data.note;
                                        console.log(`  âœ“âœ“âœ“ Slave ${slave.name} (${slave.id}) is playing: ${data.note}`);
                                        
                                        // Clear currently playing note after note duration (for visual feedback)
                                        setTimeout(() => {
                                            if (slave.currentlyPlayingNote === data.note) {
                                                slave.currentlyPlayingNote = null;
                                                console.log(`  âœ“ Cleared playing note for slave ${slave.name}`);
                                            }
                                        }, (settings.noteLength * 1000) + 100); // Clear after note duration + small buffer
                                    } else {
                                        console.warn(`  âš ï¸ Slave "${data.slaveId}" not found in connectedSlaves for note_playing`);
                                        console.warn(`  Available slave IDs:`, connectedSlaves.map(s => `"${s.id}"`));
                                    }
                                } else if (data.type === 'slave_connected' || data.type === 'slave_disconnected') {
                                    // Always send preset to slaves when they connect/disconnect
                                    // This ensures new slaves get notes even if master isn't playing
                                    console.log('ðŸ“¡ Slave connected/disconnected event received');
                                    console.log('  Type:', data.type);
                                    console.log('  Slave ID:', data.slaveId);
                                    console.log('  Total slaves:', data.totalSlaves);
                                    
                                    // Update total slaves count
                                    totalSlaves.value = data.totalSlaves || 0;
                                    
                                    // Sync connectedSlaves array with server's actual count
                                    // If we have more slaves in our list than the server reports, request fresh list
                                    if (connectedSlaves.length > data.totalSlaves) {
                                        console.warn(`  âš ï¸ Mismatch: We have ${connectedSlaves.length} slaves but server reports ${data.totalSlaves}`);
                                        console.warn(`  Requesting fresh slave list from server...`);
                                        // Request fresh slave list by sending a dummy message that will trigger server to send slaves list
                                        // Actually, we'll just trim our list to match the count for now
                                        // The server will send a fresh 'slaves' message when master reconnects or we can request it
                                    }
                                    
                                    // Update connectedSlaves array
                                    if (data.type === 'slave_connected') {
                                        // Add new slave if not already in list
                                        if (!data.slaveId) {
                                            console.warn('  âš ï¸ slave_connected event missing slaveId');
                                            return;
                                        }
                                        const existingSlave = connectedSlaves.find(s => s.id === data.slaveId);
                                        if (!existingSlave) {
                                            // Always add new slaves - don't restrict by count to avoid race conditions
                                            connectedSlaves.push({
                                                id: data.slaveId,
                                                name: data.slaveName || String(connectedSlaves.length + 1), // Use name from server if provided
                                                volume: 100, // Default volume
                                                assignedNotes: [] // Initialize empty notes array
                                            });
                                            console.log(`  âœ“ Added slave ${data.slaveId} (${data.slaveName || 'unnamed'}) to connectedSlaves (total: ${connectedSlaves.length}, server reports: ${data.totalSlaves})`);
                                            
                                            // Immediately distribute notes to the new slave
                                            const enabledNotes = noteData.filter(n => n.enabled);
                                            if (enabledNotes.length > 0) {
                                                console.log(`  ðŸ“Š Distributing notes to newly connected slave...`);
                                                distributeNotesToSlaves(enabledNotes, settings.masterIncluded);
                                            }
                                            
                                            // Warn if count doesn't match (but don't prevent adding)
                                            if (connectedSlaves.length > data.totalSlaves && data.totalSlaves > 0) {
                                                console.warn(`  âš ï¸ Slave count mismatch: We have ${connectedSlaves.length}, server reports ${data.totalSlaves}`);
                                            }
                                        } else {
                                            // Update name if provided
                                            if (data.slaveName && existingSlave.name !== data.slaveName) {
                                                existingSlave.name = data.slaveName;
                                                console.log(`  â„¹ï¸ Updated slave ${data.slaveId} name to ${data.slaveName}`);
                                            } else {
                                                console.log(`  â„¹ï¸ Slave ${data.slaveId} already in list, skipping`);
                                            }
                                        }
                                    } else if (data.type === 'slave_disconnected') {
                                        // Remove disconnected slave
                                        if (!data.slaveId) {
                                            console.warn('  âš ï¸ slave_disconnected event missing slaveId');
                                            return;
                                        }
                                        const index = connectedSlaves.findIndex(s => s.id === data.slaveId);
                                        if (index !== -1) {
                                            connectedSlaves.splice(index, 1);
                                            console.log(`  âœ“ Removed slave ${data.slaveId} from connectedSlaves (remaining: ${connectedSlaves.length}, server reports: ${data.totalSlaves})`);
                                        } else {
                                            console.log(`  â„¹ï¸ Slave ${data.slaveId} not found in list, already removed`);
                                        }
                                    }
                                    
                                    // Final check: if our list doesn't match server's count, trim to match
                                    if (connectedSlaves.length !== data.totalSlaves && data.totalSlaves >= 0) {
                                        console.warn(`  âš ï¸ Slave count mismatch: We have ${connectedSlaves.length}, server has ${data.totalSlaves}`);
                                        if (connectedSlaves.length > data.totalSlaves) {
                                            // We have too many - remove excess (keep first N)
                                            console.warn(`  Trimming excess slaves, keeping first ${data.totalSlaves}`);
                                            connectedSlaves.splice(data.totalSlaves);
                                        } else {
                                            console.warn(`  We have fewer slaves than server reports - this should be corrected by slave_connected events`);
                                        }
                                    }
                                    
                                    // Automatically update numGenerators to match number of slaves
                                    if (data.totalSlaves !== undefined && data.totalSlaves >= 0) {
                                        const newGeneratorCount = Math.max(1, data.totalSlaves); // At least 1 generator
                                        if (settings.numGenerators !== newGeneratorCount) {
                                            console.log(`  ðŸ”„ Auto-updating generators: ${settings.numGenerators} â†’ ${newGeneratorCount} (matching ${data.totalSlaves} slaves)`);
                                            settings.numGenerators = newGeneratorCount;
                                        }
                                    }
                                    
                                    console.log('  WebSocket ready:', ws.value && ws.value.readyState === WebSocket.OPEN);
                                    console.log('  Current enabled notes:', noteData.filter(n => n.enabled).length);
                                    console.log('  Sending preset to slaves...');
                                    sendPresetToSlaves();
                                    console.log('  âœ“ Preset send initiated');
                                } else if (data.type === 'slave_requested_preset') {
                                    // A slave requested the current preset (e.g., after reconnection)
                                    console.log('ðŸ“¡ Slave requested preset');
                                    console.log('  Slave ID:', data.slaveId);
                                    console.log('  Sending current preset...');
                                    sendPresetToSlaves();
                                    console.log('  âœ“ Preset sent to requesting slave');
                                }
                            }
                        } catch (e) {
                            console.error('Error parsing WebSocket message:', e);
                        }
                    };
                    
                    websocket.onerror = (error) => {
                        const errorMsg = `WebSocket error: ${error.type || 'unknown'} - ${error.message || 'Connection failed'}`;
                        wsError.value = errorMsg;
                        console.error('=== WebSocket Error ===');
                        console.error('Error:', error);
                        console.error('WebSocket URL was:', wsUrl);
                        console.error('WebSocket readyState:', websocket.readyState);
                        console.error('Error type:', error.type);
                        console.error('Error message:', error.message || 'No message');
                        console.error('Error target:', error.target);
                        console.error('Error currentTarget:', error.currentTarget);
                        // Update connection status
                        ws.value = websocket;
                        // Show helpful error message
                        if (isSlave) {
                            console.error('Slave WebSocket connection failed. Check:');
                            console.error('1. URL:', wsUrl);
                            console.error('2. Server running on port 3000');
                            console.error('3. Both devices on same network');
                            console.error('4. Check Safari console for more details');
                        }
                        // Clear error after 10 seconds
                        setTimeout(() => {
                            wsError.value = null;
                        }, 10000);
                    };
                    
                    websocket.onclose = (event) => {
                        clearTimeout(connectionTimeout); // Clear timeout when connection closes
                        wsConnected.value = false;
                        wsReceivedWelcome.value = false;
                        console.log('WebSocket disconnected, code:', event.code, 'reason:', event.reason || 'none');
                        console.log('Was clean:', event.wasClean);
                        console.log('Close event details:', {
                            code: event.code,
                            reason: event.reason,
                            wasClean: event.wasClean,
                            url: wsUrl
                        });
                        
                        // Stop drone note smoothly before closing connection
                        if (isSlave) {
                            console.log('Stopping drone note due to connection close...');
                            stopDroneNote();
                        }
                        
                        ws.value = null;
                        
                        // Show error for common error codes
                        if (event.code === 1006) {
                            const errorMsg = `Connection closed abnormally (code ${event.code}). Check network connection.`;
                            wsError.value = errorMsg;
                            console.error('WebSocket closed abnormally (connection refused or network error)');
                            if (isSlave) {
                                // Don't show alert, just show error in UI
                                console.error('Cannot connect to WebSocket server. URL:', wsUrl);
                            }
                            // Clear error after 10 seconds
                            setTimeout(() => {
                                wsError.value = null;
                            }, 10000);
                        } else if (event.code === 1001 && isSlave) {
                            // Code 1001 = going away - connection closed unexpectedly (common on iOS Safari)
                            console.warn('WebSocket closed unexpectedly (code 1001) - this is common on iOS Safari');
                            console.log('Will attempt to reconnect immediately...');
                            // Reconnect immediately for iOS Safari (don't wait)
                            setTimeout(() => {
                                console.log('Reconnecting after iOS Safari close (code 1001)...');
                                ws.value = null;
                                connectWebSocket();
                            }, 500);
                            return; // Exit early, don't continue with normal reconnection
                        }
                        
                        // Reconnect after delay (only if not a clean close)
                        // For iOS Safari, code 1001 is common when app goes to background, so always try to reconnect
                        if (!event.wasClean || event.code !== 1000 || event.code === 1001) {
                            setTimeout(() => {
                                console.log('Attempting to reconnect WebSocket...');
                                connectWebSocket();
                            }, 2000);
                        }
                    };
                    } catch (e) {
                        console.error('Failed to create WebSocket:', e);
                        if (isSlave) {
                            alert('Failed to create WebSocket connection: ' + e.message + '\nURL: ' + wsUrl);
                        }
                        // Retry after delay
                        setTimeout(() => {
                            connectWebSocket();
                        }, 3000);
                    }
                };
                
                const startSlavePlayback = () => {
                    console.log('=== startSlavePlayback called ===');
                    console.log('assignedNotes:', assignedNotes.value.length);
                    console.log('isPlaying:', isPlaying.value);
                    console.log('audioContext:', !!audioContext, 'state:', audioContext?.state);
                    console.log('masterGain:', !!masterGain);
                    
                    // Ensure we're marked as playing
                    if (!isPlaying.value) {
                        console.log('Setting isPlaying to true');
                        isPlaying.value = true;
                    }
                    
                    // Clear any existing timeouts FIRST
                    generatorTimeouts.forEach(timeout => {
                        if (timeout) clearTimeout(timeout);
                    });
                    generatorTimeouts.length = 0;
                    
                    // Stop ALL active oscillators before clearing arrays
                    generatorOscillators.forEach((oscSet, idx) => {
                        if (oscSet) {
                            oscSet.forEach(osc => {
                                if (osc && !osc._isPlaceholder && typeof osc.stop === 'function') {
                                    try {
                                        osc.stop();
                                    } catch (e) {
                                        console.warn('Error stopping oscillator:', e);
                                    }
                                }
                            });
                            oscSet.clear();
                        }
                    });
                    
                    // Clear arrays
                    generatorNoteEndTimes.length = 0;
                    generatorOscillators.length = 0;
                    lastNoteEndTime = 0;
                    isNotePlaying = false;
                    
                    if (assignedNotes.value.length === 0) {
                        console.log('No assigned notes, cannot start playback');
                        slaveStatus.value = 'No notes assigned';
                        return;
                    }
                    
                    // Initialize note rotation: create a shuffled array of indices to ensure all notes are played
                    const indices = Array.from({ length: assignedNotes.value.length }, (_, i) => i);
                    // Fisher-Yates shuffle
                    for (let i = indices.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [indices[i], indices[j]] = [indices[j], indices[i]];
                    }
                    shuffledNoteIndices.value = indices;
                    noteRotationIndex.value = 0;
                    console.log('Initialized note rotation with', assignedNotes.value.length, 'notes, shuffled order:', shuffledNoteIndices.value);
                    
                    if (!audioContext || !masterGain) {
                        console.log('Audio context not ready');
                        slaveStatus.value = 'Audio not ready';
                        return;
                    }
                    
                    // Ensure audio context is running - but don't block if suspended
                    if (audioContext.state === 'suspended') {
                        console.log('Audio context suspended, attempting to resume...');
                        // Try to resume, but don't wait - start playback anyway
                        audioContext.resume().then(() => {
                            console.log('Audio context resumed successfully');
                        }).catch(e => {
                            console.log('Audio resume failed, but continuing playback:', e.message);
                        });
                        // Continue with playback even if resume fails - might still work
                    }
                    
                    // Slaves always use 1 generator to prevent overlap within a single flake
                    // Each flake should play one note at a time
                    const numGenerators = 1;
                    console.log('Starting', numGenerators, 'generator(s) with', assignedNotes.value.length, 'notes');
                    slaveStatus.value = 'Playing';
                    
                    // CRITICAL: Ensure arrays are exactly the right size (no extra generators)
                    // Initialize generator arrays for independent tracking
                    generatorOscillators.length = numGenerators;
                    generatorNoteEndTimes.length = numGenerators;
                    generatorTimeouts.length = numGenerators;
                    
                    for (let i = 0; i < numGenerators; i++) {
                        generatorOscillators[i] = new Set(); // Always create fresh Set
                        generatorNoteEndTimes[i] = null; // Always reset to null
                        generatorTimeouts[i] = null; // Always reset to null
                    }
                    
                    // Start ONLY the first generator (index 0)
                    const startDelay = 0;
                    const timeout = setTimeout(() => {
                        console.log('Generator 0 timeout fired, isPlaying:', isPlaying.value);
                        if (isPlaying.value) {
                            console.log('Calling scheduleSlaveNote for generator 0');
                            scheduleSlaveNote(0);
                        } else {
                            console.log('Not playing, skipping generator 0');
                        }
                    }, startDelay);
                    generatorTimeouts[0] = timeout;
                    console.log('Scheduled generator 0 to start in', startDelay, 'ms');
                    console.log('Total generators initialized:', numGenerators, '(should be 1)');
                    console.log('=== startSlavePlayback complete ===');
                    console.log('Total generator timeouts:', generatorTimeouts.length);
                };
                
                const scheduleSlaveNote = (generatorId) => {
                    // CRITICAL: Slaves should ONLY use generator 0
                    // If somehow generatorId is not 0, force it to 0 and log a warning
                    if (generatorId !== 0) {
                        console.error('âš ï¸âš ï¸âš ï¸ WARNING: scheduleSlaveNote called with generatorId', generatorId, 'but slaves should only use generator 0! Forcing to 0.');
                        generatorId = 0;
                    }
                    
                    // Check if still playing and have notes
                    if (!isPlaying.value) {
                        console.log('scheduleSlaveNote: stopped playing, generator:', generatorId);
                        return;
                    }
                    
                    if (!audioContext || !masterGain) {
                        console.error('Audio context not ready in scheduleSlaveNote');
                        return;
                    }
                    
                    // Prevent overlap - check if THIS SPECIFIC GENERATOR is still playing
                    const now = audioContext.currentTime;
                    
                    // Initialize generator arrays if needed (but ensure we only use index 0)
                    if (!generatorOscillators[0]) {
                        generatorOscillators[0] = new Set();
                    }
                    if (generatorNoteEndTimes[0] === undefined) {
                        generatorNoteEndTimes[0] = null;
                    }
                    
                    // Force use of generator 0
                    const actualGeneratorId = 0;
                    
                    // Check if THIS generator has any oscillators actively playing (including placeholders)
                    const thisGeneratorOscillators = generatorOscillators[actualGeneratorId];
                    if (thisGeneratorOscillators && thisGeneratorOscillators.size > 0) {
                        // Count actual oscillators vs placeholders
                        const items = Array.from(thisGeneratorOscillators);
                        const actualOscillators = items.filter(osc => !osc._isPlaceholder);
                        const placeholders = items.filter(osc => osc._isPlaceholder);
                        
                        // Block if there are any oscillators OR placeholders (placeholders mean a note is starting)
                        if (actualOscillators.length > 0 || placeholders.length > 0) {
                            console.log('Generator', actualGeneratorId, ': BLOCKED - oscillator still playing (', actualOscillators.length, 'oscillators,', placeholders.length, 'placeholders), waiting...');
                            const timeout = setTimeout(() => scheduleSlaveNote(actualGeneratorId), 100);
                            generatorTimeouts[actualGeneratorId] = timeout;
                            return;
                        }
                    }
                    
                    // Check if THIS generator's note end time has passed
                    const thisGeneratorEndTime = generatorNoteEndTimes[actualGeneratorId];
                    if (thisGeneratorEndTime !== null && thisGeneratorEndTime !== undefined && now < thisGeneratorEndTime) {
                        // This generator's note is still playing based on timing, wait until it finishes
                        const waitTime = Math.max(50, (thisGeneratorEndTime - now) * 1000); // Minimum 50ms
                        console.log('Generator', actualGeneratorId, ': BLOCKED - note still playing, waiting', waitTime.toFixed(0), 'ms (end time:', thisGeneratorEndTime.toFixed(3), 's, now:', now.toFixed(3), 's, remaining:', (thisGeneratorEndTime - now).toFixed(3), 's)');
                        const timeout = setTimeout(() => scheduleSlaveNote(actualGeneratorId), waitTime);
                        generatorTimeouts[actualGeneratorId] = timeout;
                        return;
                    }
                    
                    // Double-check: if note end time exists but is in the past, clear it
                    if (thisGeneratorEndTime !== null && thisGeneratorEndTime !== undefined && now >= thisGeneratorEndTime) {
                        console.log('Generator', actualGeneratorId, ': clearing expired note end time (', thisGeneratorEndTime.toFixed(3), 's < now:', now.toFixed(3), 's)');
                        generatorNoteEndTimes[actualGeneratorId] = null;
                    }
                    
                    console.log('Generator', actualGeneratorId, ': âœ“ Overlap check PASSED - no active oscillators, proceeding to play note');
                    
                    // CRITICAL: Reserve this generator slot IMMEDIATELY after passing overlap check
                    // This prevents race conditions where multiple calls pass the check simultaneously
                    const placeholder = { _isPlaceholder: true, generatorId: actualGeneratorId, timestamp: now };
                    thisGeneratorOscillators.add(placeholder);
                    console.log('Generator', actualGeneratorId, ': reserved slot with placeholder, total active:', thisGeneratorOscillators.size);
                    
                    if (assignedNotes.value.length === 0) {
                        console.log('scheduleSlaveNote: no notes assigned, generator:', actualGeneratorId);
                        const timeout = setTimeout(() => scheduleSlaveNote(actualGeneratorId), settings.pauseLength * 1000);
                        generatorTimeouts[actualGeneratorId] = timeout;
                        return;
                    }
                    
                    // Check audio context state - resume if suspended
                    if (audioContext && audioContext.state === 'suspended') {
                        console.log('Audio context suspended during playback, resuming...');
                        audioContext.resume().then(() => {
                            console.log('Audio context resumed, continuing playback');
                        }).catch(e => {
                            console.error('Failed to resume audio context:', e);
                        });
                    }
                    
                    // Pick next note from rotation to ensure all notes are played
                    // Initialize shuffle if empty, or reshuffle if we've played all notes
                    if (shuffledNoteIndices.value.length === 0 || noteRotationIndex.value >= shuffledNoteIndices.value.length) {
                        if (shuffledNoteIndices.value.length === 0) {
                            console.log('Initializing note rotation...');
                        } else {
                            console.log('All notes played, reshuffling...');
                        }
                        const indices = Array.from({ length: assignedNotes.value.length }, (_, i) => i);
                        // Fisher-Yates shuffle
                        for (let i = indices.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [indices[i], indices[j]] = [indices[j], indices[i]];
                        }
                        shuffledNoteIndices.value = indices;
                        noteRotationIndex.value = 0;
                        console.log('Note order:', shuffledNoteIndices.value);
                    }
                    
                    const noteIndex = shuffledNoteIndices.value[noteRotationIndex.value];
                    const note = assignedNotes.value[noteIndex];
                    const currentNoteNumber = noteRotationIndex.value + 1;
                    noteRotationIndex.value++;
                    console.log('Playing note', currentNoteNumber, 'of', assignedNotes.value.length, ':', note.note, '(index', noteIndex, 'in assigned notes)');
                    
                    // Calculate note duration FIRST (with randomness: Â±1 second)
                    // Random between noteLength-1 and noteLength+1, but ensure minimum 0.1 seconds
                    const baseDuration = settings.noteLength + (Math.random() * 2 - 1); // Random between noteLength-1 and noteLength+1
                    const noteDuration = Math.max(0.1, baseDuration); // Ensure minimum 0.1 seconds (allows very short notes if noteLength is small)
                    console.log('Duration calculation: noteLength=', settings.noteLength, 'baseDuration=', baseDuration.toFixed(2), 'finalDuration=', noteDuration.toFixed(2));
                    // Note: 'now' is already declared above in the overlap prevention check
                    
                    console.log('=== Slave playing note ===');
                    console.log('Note:', note.note, note.freq, 'Hz, generator:', generatorId);
                    console.log('Base note length:', settings.noteLength, 's');
                    console.log('Calculated duration:', baseDuration.toFixed(2), 's');
                    console.log('Final note duration:', noteDuration.toFixed(2), 's');
                    console.log('Audio context state:', audioContext?.state);
                    console.log('Master gain:', !!masterGain);
                    console.log('isPlaying:', isPlaying.value);
                    console.log('Particles before:', particles.length);
                    
                    // CRITICAL: Get audio context time RIGHT BEFORE playing
                    // This ensures accurate timing calculation
                    const noteStartTime = audioContext.currentTime;
                    const noteEndTime = noteStartTime + noteDuration;
                    generatorNoteEndTimes[actualGeneratorId] = noteEndTime;
                    console.log('Generator', actualGeneratorId, ': note starts at:', noteStartTime.toFixed(3), 's, will end at:', noteEndTime.toFixed(3), 's, duration:', noteDuration.toFixed(3), 's');
                    // Placeholder was already added above after overlap check passed
                    
                    // Notify master about currently playing note
                    if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                        try {
                            ws.value.send(JSON.stringify({
                                type: 'note_playing',
                                slaveId: slaveId, // Include slave ID so master knows which slave is playing
                                note: note.note,
                                freq: note.freq,
                                color: note.color
                            }));
                        } catch (e) {
                            console.error('Error sending note_playing message:', e);
                        }
                    }
                    
                    // Pass the calculated duration and actualGeneratorId to playNote so it uses the same value
                    // playNote will replace the placeholder with the actual oscillator
                    playNote(note.freq, note.volume, note.color, noteDuration, note.note, actualGeneratorId);
                    console.log('Particles after:', particles.length);
                    console.log('========================');
                    
                    // Calculate pause delay (with randomness: Â±1 second, minimum 0)
                    const basePauseDuration = settings.pauseLength + (Math.random() * 2 - 1); // Random between pauseLength-1 and pauseLength+1 seconds
                    const pauseDuration = Math.max(0, basePauseDuration); // Ensure minimum 0 seconds
                    
                    // CRITICAL: The pause starts AFTER the note ends, not after it starts
                    // So the next note should start at: noteEndTime + pauseDuration
                    const nextNoteStartTime = noteEndTime + pauseDuration;
                    
                    // Get current audio context time RIGHT NOW for accurate delay calculation
                    const nowForScheduling = audioContext.currentTime;
                    
                    // Calculate delay in milliseconds from NOW until next note should start
                    const delayUntilNextNote = (nextNoteStartTime - nowForScheduling) * 1000;
                    
                    console.log('Generator', actualGeneratorId, 'scheduling next note:');
                    console.log('  Note duration:', noteDuration.toFixed(3), 's');
                    console.log('  Pause duration:', pauseDuration.toFixed(3), 's');
                    console.log('  Note started at:', noteStartTime.toFixed(3), 's');
                    console.log('  Note ends at:', noteEndTime.toFixed(3), 's');
                    console.log('  Pause ends at:', nextNoteStartTime.toFixed(3), 's (noteEnd + pause)');
                    console.log('  Current time (now):', nowForScheduling.toFixed(3), 's');
                    console.log('  Delay until next:', delayUntilNextNote.toFixed(0), 'ms');
                    console.log('  Time until note ends:', ((noteEndTime - nowForScheduling) * 1000).toFixed(0), 'ms');
                    console.log('  Time until pause ends:', ((nextNoteStartTime - nowForScheduling) * 1000).toFixed(0), 'ms');
                    
                    // Ensure delay is at least 50ms to prevent immediate scheduling
                    const finalDelay = Math.max(50, delayUntilNextNote);
                    if (finalDelay < delayUntilNextNote - 10) {
                        console.warn('Generator', actualGeneratorId, ': WARNING - delay was clamped from', delayUntilNextNote.toFixed(0), 'ms to', finalDelay, 'ms');
                    }
                    if (finalDelay < (pauseDuration * 1000) - 100) {
                        console.error('Generator', actualGeneratorId, ': ERROR - delay (', finalDelay, 'ms) is shorter than pause duration (', (pauseDuration * 1000).toFixed(0), 'ms)!');
                    }
                    const timeout = setTimeout(() => scheduleSlaveNote(actualGeneratorId), finalDelay);
                    generatorTimeouts[actualGeneratorId] = timeout;
                };
                
                // Handle tap to start audio (for iOS Safari autoplay policy)
                // This only unlocks audio - playback starts when master sends 'play' command
                const handleTapToStart = (e) => {
                    console.log('âœ“âœ“âœ“ handleTapToStart called', e.type);
                    e.preventDefault();
                    e.stopPropagation();
                    wsError.value = null;
                    
                    initAudio().then(() => {
                        console.log('Audio initialized in handleTapToStart, state:', audioContext?.state);
                        
                        // Always try to resume if suspended
                        if (audioContext && audioContext.state === 'suspended') {
                            console.log('Resuming suspended audio context...');
                            const resumePromise = audioContext.resume();
                            const timeoutPromise = new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('Resume timeout')), 2000)
                            );
                            Promise.race([resumePromise, timeoutPromise]).then(() => {
                                console.log('âœ“âœ“âœ“ Audio context unlocked via tap, state:', audioContext.state);
                                slaveStatus.value = 'Ready';
                                // Don't start playback here - wait for master 'play' command
                                // Audio is now unlocked, so future play commands will work automatically
                                // Start drone note to keep audio context active
                                startDroneNote();
                            }).catch(e => {
                                console.log('Audio resume timed out, but audio might still work:', e.message);
                                slaveStatus.value = 'Ready';
                                startDroneNote();
                            });
                        } else {
                            console.log('âœ“ Audio context already ready, state:', audioContext?.state);
                            slaveStatus.value = 'Ready';
                            startDroneNote();
                        }
                    }).catch(e => {
                        console.error('âœ— Error initializing audio on tap:', e);
                        slaveStatus.value = 'Ready';
                    });
                };
                
                const toggleMasterIncluded = () => {
                    const oldValue = settings.masterIncluded;
                    settings.masterIncluded = !settings.masterIncluded;
                    console.log('âœ“âœ“âœ“âœ“âœ“ TOGGLE BUTTON CLICKED âœ“âœ“âœ“âœ“âœ“');
                    console.log('Master included toggled from', oldValue, 'to', settings.masterIncluded);
                    console.log('WebSocket exists:', !!ws.value);
                    console.log('WebSocket state:', ws.value ? ws.value.readyState : 'null');
                    console.log('WebSocket OPEN state:', ws.value?.readyState === WebSocket.OPEN);
                    
                    // Force immediate send - don't rely on watch
                    if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                        console.log('âœ“âœ“âœ“ WebSocket ready, immediately calling sendPresetToSlaves()...');
                        sendPresetToSlaves();
                        console.log('âœ“âœ“âœ“ sendPresetToSlaves() called');
                    } else {
                        console.error('âœ—âœ—âœ— WebSocket not ready! State:', ws.value?.readyState);
                        console.error('âœ—âœ—âœ— Cannot send preset update - WebSocket not connected');
                        console.error('ws.value:', ws.value);
                        console.error('readyState:', ws.value?.readyState);
                        console.error('WebSocket.OPEN:', WebSocket.OPEN);
                    }
                };
                
                // Function to distribute notes to slaves (same logic as server)
                const distributeNotesToSlaves = (enabledNotes, includeMaster) => {
                    const totalDevices = includeMaster ? connectedSlaves.length + 1 : connectedSlaves.length;
                    
                    if (totalDevices === 0 || enabledNotes.length === 0) {
                        console.log('No devices or notes to distribute');
                        if (includeMaster) {
                            masterAssignedNotes.value = [];
                        }
                        return;
                    }
                    
                    const notesPerDevice = Math.ceil(enabledNotes.length / totalDevices);
                    
                    // Assign notes to master first if included
                    if (includeMaster) {
                        const masterStartIndex = 0;
                        const masterEndIndex = Math.min(masterStartIndex + notesPerDevice, enabledNotes.length);
                        const masterNotes = enabledNotes.slice(masterStartIndex, masterEndIndex);
                        
                        // If we've run out of notes, wrap around
                        if (masterNotes.length === 0) {
                            masterNotes.push(enabledNotes[0 % enabledNotes.length]);
                        }
                        
                        masterAssignedNotes.value = masterNotes;
                        console.log(`âœ“ Master assigned notes:`, masterNotes.map(n => n.note));
                    } else {
                        masterAssignedNotes.value = [];
                    }
                    
                    // Distribute notes to each slave
                    connectedSlaves.forEach((slave, index) => {
                        const deviceIndex = includeMaster ? index + 1 : index;
                        const startIndex = deviceIndex * notesPerDevice;
                        const endIndex = Math.min(startIndex + notesPerDevice, enabledNotes.length);
                        const assignedNotes = enabledNotes.slice(startIndex, endIndex);
                        
                        // If we've run out of notes, wrap around
                        if (assignedNotes.length === 0) {
                            assignedNotes.push(enabledNotes[deviceIndex % enabledNotes.length]);
                        }
                        
                        // Update slave's assigned notes
                        slave.assignedNotes = assignedNotes;
                        console.log(`âœ“ Master calculated notes for slave ${slave.name} (${slave.id}):`, assignedNotes.map(n => n.note));
                    });
                };
                
                const sendPresetToSlaves = () => {
                    if (!ws.value || ws.value.readyState !== WebSocket.OPEN) {
                        console.log('Cannot send preset: WebSocket not ready');
                        return;
                    }
                    
                    const enabledNotes = noteData.filter(n => n.enabled);
                    
                    // Calculate and update assigned notes for each slave
                    distributeNotesToSlaves(enabledNotes, settings.masterIncluded);
                    
                    // Build per-slave volume map
                    const slaveVolumes = {};
                    connectedSlaves.forEach(slave => {
                        slaveVolumes[slave.id] = slave.volume;
                    });
                    
                    const presetData = {
                        type: 'preset_update',
                        preset: {
                            noteLength: settings.noteLength,
                            pauseLength: settings.pauseLength,
                            masterVolume: settings.masterVolume,
                            numGenerators: settings.numGenerators,
                            masterIncluded: settings.masterIncluded
                        },
                        noteData: enabledNotes.map(n => ({
                            note: n.note,
                            freq: n.freq,
                            color: n.color,
                            volume: n.volume,
                            enabled: n.enabled
                        })),
                        slaveVolumes: slaveVolumes // Include per-slave volume multipliers
                    };
                    console.log('ðŸ“¤ Sending preset_update with masterIncluded:', presetData.preset.masterIncluded);
                    console.log('ðŸ“¤ Per-slave volumes:', slaveVolumes);
                    console.log('ðŸ“¤ Full preset data:', JSON.stringify(presetData.preset));
                    const messageStr = JSON.stringify(presetData);
                    console.log('ðŸ“¤ Message length:', messageStr.length);
                    ws.value.send(messageStr);
                    console.log('ðŸ“¤ Message sent successfully');
                };
                
                const generateQRCode = (targetCanvas = null) => {
                    // Determine which canvas to use: fullscreen if shown, otherwise regular
                    const canvasToUse = targetCanvas || (showQRCode.value && qrCanvasFullscreen.value ? qrCanvasFullscreen.value : qrCanvas.value);
                    
                    if (!canvasToUse) {
                        setTimeout(() => generateQRCode(targetCanvas), 100);
                        return;
                    }
                    
                    // Check if QRCode library is loaded
                    if (typeof QRCode === 'undefined') {
                        setTimeout(() => generateQRCode(targetCanvas), 200);
                        return;
                    }
                    
            // Get server URL (with IP address for network access)
            // For QR code: always use IP address and port 3000 with ?slave=true
            // WebSocket is now on the same port (3000), so slaves can connect
            // Slaves will use the IP from the URL they access, so this should be the server's IP
            const qrBaseUrl = 'http://192.168.2.34:3000';
                    const serverUrl = isSlave ? qrBaseUrl : `${qrBaseUrl}?slave=true`;
                    console.log('QR Code URL generated:', serverUrl);
                    
                    // Get container dimensions
                    const container = canvasToUse;
                    if (!container) {
                        setTimeout(() => generateQRCode(targetCanvas), 100);
                        return;
                    }
                    
                    const containerWidth = container.clientWidth || 200;
                    const containerHeight = container.clientHeight || 200;
                    // Use larger size for fullscreen
                    const maxSize = showQRCode.value && qrCanvasFullscreen.value ? 600 : 300;
                    const size = Math.min(containerWidth - 16, containerHeight - 16, maxSize);
                    const finalSize = Math.max(150, size);
                    
                    // Clear container and create new QR code
                    container.innerHTML = '';
                    
                    // Generate QR code directly in the container
                    try {
                        new QRCode(container, {
                            text: serverUrl,
                            width: finalSize,
                            height: finalSize,
                            colorDark: showQRCode.value && qrCanvasFullscreen.value ? '#000000' : '#FFFFFF',
                            colorLight: '#00000000',
                            correctLevel: QRCode.CorrectLevel.M
                        });
                    } catch (e) {
                        console.error('QR Code generation exception:', e);
                    }
                };
                
                // Unlock audio context on first user interaction (for autoplay policy)
                let audioUnlocked = false;
                const unlockAudio = (e) => {
                    try {
                        if (audioUnlocked) {
                            console.log('Audio already unlocked, skipping');
                            return;
                        }
                        audioUnlocked = true;
                        console.log('âœ“âœ“âœ“ Unlocking audio context on first user interaction...', e.type);
                        console.log('Event details:', { type: e.type, target: e.target?.tagName });
                        
                        // Don't prevent default - let the event propagate normally
                        // e.preventDefault() might block audio unlock on iOS
                        
                        // Add timeout to prevent hanging
                        const initAudioWithTimeout = Promise.race([
                            initAudio(),
                            new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('initAudio timeout')), 2000)
                            )
                        ]);
                        
                        initAudioWithTimeout.then(() => {
                            console.log('initAudio completed, audioContext state:', audioContext?.state);
                            console.log('masterGain:', !!masterGain);
                            
                            if (audioContext && audioContext.state === 'suspended') {
                                // Try to resume - this will work if user has interacted
                                console.log('Attempting to resume suspended audio context...');
                                const resumeWithTimeout = Promise.race([
                                    audioContext.resume(),
                                    new Promise((_, reject) => 
                                        setTimeout(() => reject(new Error('Resume timeout')), 1000)
                                    )
                                ]);
                                resumeWithTimeout.then(() => {
                                    console.log('âœ“âœ“âœ“ Audio context unlocked and resumed successfully!');
                                    console.log('New state:', audioContext.state);
                                    if (isSlave) {
                                        slaveStatus.value = 'Ready';
                                        console.log('Slave status set to Ready');
                                    }
                                    
                                    // Start continuous inaudible drone note to keep audio context active
                                    // This prevents iOS Safari from suspending it and keeps device awake
                                    // Works for both master and slaves
                                    startDroneNote();
                                }).catch(err => {
                                    console.error('âœ— Audio context resume failed:', err);
                                    console.log('Audio context unlock attempted, will need interaction later');
                                });
                            } else {
                                console.log('âœ“ Audio context already unlocked, state:', audioContext?.state);
                                if (isSlave && audioContext?.state === 'running') {
                                    slaveStatus.value = 'Ready';
                                    console.log('Slave status set to Ready');
                                }
                            }
                        }).catch(err => {
                            console.error('âœ— initAudio failed/timed out:', err);
                            console.log('Audio unlock attempted, will need interaction later');
                            // Still try to create audio context if it doesn't exist
                            if (!audioContext) {
                                try {
                                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                                    masterGain = audioContext.createGain();
                                    masterGain.gain.value = settings.masterMuted ? 0 : settings.masterVolume / 100;
                                    masterGain.connect(audioContext.destination);
                                    console.log('Created audio context in unlockAudio error handler');
                                } catch (e) {
                                    console.error('Failed to create audio context:', e);
                                }
                            }
                        });
                    } catch (error) {
                        console.error('âœ— unlockAudio error:', error);
                    }
                };
                
                // Add one-time listeners to unlock audio on first interaction
                // Use capture phase and non-passive for better iOS support
                const unlockEvents = ['touchstart', 'touchend', 'click', 'mousedown'];
                unlockEvents.forEach(eventType => {
                    document.addEventListener(eventType, unlockAudio, { once: true, capture: true, passive: false });
                });
                
                // Also add to canvas for better coverage
                if (canvas.value) {
                    unlockEvents.forEach(eventType => {
                        canvas.value.addEventListener(eventType, unlockAudio, { once: true, capture: true, passive: false });
                    });
                }
                
                onMounted(() => {
                    // Ensure menu is visible on master when app opens
                    if (!isSlave) {
                        showControls.value = true;
                    }
                    // Ensure QR code overlay is hidden on load
                    showQRCode.value = false;
                    
                    if (canvas.value) {
                        // Ensure canvas is properly sized before getting context
                    resizeCanvas();
                    ctx.value = canvas.value.getContext('2d');
                        // Resize again after context is set to ensure proper scaling
                        resizeCanvas();
                        // Small delay to ensure DOM is fully ready
                        setTimeout(() => {
                            resizeCanvas();
                    animate();
                        }, 10);
                        
                        // Add unlock listeners to canvas after it's ready
                        const unlockEvents = ['touchstart', 'touchend', 'click', 'mousedown'];
                        unlockEvents.forEach(eventType => {
                            canvas.value.addEventListener(eventType, unlockAudio, { once: true, capture: true, passive: false });
                        });
                    }
                    window.addEventListener('resize', resizeCanvas);
                    
                    // Connect WebSocket
                    console.log('onMounted: Connecting WebSocket...');
                    console.log('Is slave:', isSlave);
                    console.log('Current URL:', window.location.href);
                    connectWebSocket();
                    
                    // For slaves, also try connecting again after a short delay (iOS Safari sometimes needs this)
                    if (isSlave) {
                        setTimeout(() => {
                            if (!wsConnected.value || !ws.value || ws.value.readyState !== WebSocket.OPEN) {
                                console.log('Slave: Retrying WebSocket connection after delay...');
                                connectWebSocket();
                            }
                        }, 1000);
                        
                        // Request wake lock initially (if not already requested)
                        requestWakeLock();
                        
                        // For iOS: Enhanced drone note with higher frequency and volume
                        // iOS respects higher frequency audio more for keeping device awake
                        // We'll modify the drone note to be more effective on iOS
                        const enhanceDroneForIOS = () => {
                            if (!droneOscillator || !droneGain || !audioContext) return;
                            
                            try {
                                // Increase frequency slightly (still inaudible but iOS respects it more)
                                droneOscillator.frequency.value = 18; // Just below human hearing threshold
                                // Increase gain slightly (still inaudible but more "active")
                                droneGain.gain.value = 0.0005; // Slightly louder but still inaudible
                                console.log('âœ“ Enhanced drone note for iOS keep-alive');
                            } catch (e) {
                                console.log('Could not enhance drone:', e);
                            }
                        };
                        
                        // For iOS: Create hidden video element for keep-alive
                        // iOS Safari respects video playback more than audio for preventing sleep
                        // Using technique similar to NoSleep.js library
                        let keepAliveVideo = null;
                        const createKeepAliveVideo = () => {
                            if (keepAliveVideo) return keepAliveVideo;
                            
                            try {
                                keepAliveVideo = document.createElement('video');
                                keepAliveVideo.style.position = 'fixed';
                                keepAliveVideo.style.top = '-9999px';
                                keepAliveVideo.style.left = '-9999px';
                                keepAliveVideo.style.width = '1px';
                                keepAliveVideo.style.height = '1px';
                                keepAliveVideo.style.opacity = '0';
                                keepAliveVideo.style.pointerEvents = 'none';
                                keepAliveVideo.muted = true;
                                keepAliveVideo.playsInline = true;
                                keepAliveVideo.loop = true;
                                keepAliveVideo.autoplay = true;
                                keepAliveVideo.setAttribute('playsinline', 'true');
                                keepAliveVideo.setAttribute('webkit-playsinline', 'true');
                                
                                // Create a minimal video blob (1 frame, silent)
                                // Using a slightly larger canvas for better compatibility
                                const canvas = document.createElement('canvas');
                                canvas.width = 16;
                                canvas.height = 16;
                                const ctx = canvas.getContext('2d');
                                ctx.fillStyle = '#000';
                                ctx.fillRect(0, 0, 16, 16);
                                
                                // Convert to blob and create object URL
                                canvas.toBlob((blob) => {
                                    if (blob) {
                                        const url = URL.createObjectURL(blob);
                                        keepAliveVideo.src = url;
                                        document.body.appendChild(keepAliveVideo);
                                        
                                        // Play the video with multiple attempts
                                        const playVideo = () => {
                                            const playPromise = keepAliveVideo.play();
                                            if (playPromise !== undefined) {
                                                playPromise.catch(e => {
                                                    console.log('Keep-alive video play failed:', e);
                                                    // Retry after a short delay
                                                    setTimeout(() => {
                                                        if (keepAliveVideo && isPlaying.value) {
                                                            playVideo();
                                                        }
                                                    }, 1000);
                                                });
                                            }
                                        };
                                        playVideo();
                                        
                                        // Ensure video stays playing
                                        keepAliveVideo.addEventListener('ended', () => {
                                            if (isPlaying.value) {
                                                keepAliveVideo.play().catch(() => {});
                                            }
                                        });
                                        
                                        keepAliveVideo.addEventListener('pause', () => {
                                            if (isPlaying.value) {
                                                keepAliveVideo.play().catch(() => {});
                                            }
                                        });
                                        
                                        console.log('âœ“ iOS keep-alive video created');
                                    }
                                }, 'image/png');
                            } catch (e) {
                                console.log('Could not create keep-alive video:', e);
                            }
                            
                            return keepAliveVideo;
                        };
                        
                        // For iOS: Very aggressive periodic activity to prevent sleep
                        // iOS doesn't support Wake Lock API, so we need continuous activity
                        const iosKeepAliveInterval = setInterval(() => {
                            if (isPlaying.value) {
                                // Multiple strategies to keep device awake:
                                // 1. Canvas activity (triggers repaint) - even if not visible
                                if (canvas.value) {
                                    const _ = canvas.value.width;
                                    const _2 = canvas.value.height;
                                    // Force repaint by reading context
                                    if (ctx.value) {
                                        const _3 = ctx.value.canvas.width;
                                    }
                                }
                                // 2. Request wake lock again (in case it was released)
                                requestWakeLock();
                                // 3. Ensure audio context is running (critical for iOS)
                                if (audioContext) {
                                    if (audioContext.state === 'suspended') {
                                        console.log('âš ï¸ iOS: Audio context suspended, resuming...');
                                        audioContext.resume().catch(() => {});
                                    }
                                    // Touch the audio context to keep it active
                                    const _ = audioContext.currentTime;
                                    // Create a tiny buffer to keep context active
                                    try {
                                        const buffer = audioContext.createBuffer(1, 1, 22050);
                                        const source = audioContext.createBufferSource();
                                        source.buffer = buffer;
                                        source.connect(audioContext.destination);
                                        source.start();
                                        source.stop(audioContext.currentTime + 0.001);
                                    } catch (e) {
                                        // Ignore errors
                                    }
                                }
                                // 4. Ensure drone note is running and enhanced for iOS (CRITICAL)
                                if (!droneOscillator && audioContext && audioContext.state === 'running') {
                                    console.log('âš ï¸ iOS: Drone note stopped, restarting...');
                                    startDroneNote();
                                    setTimeout(() => enhanceDroneForIOS(), 100);
                                } else if (droneOscillator && droneGain) {
                                    // Continuously reinforce drone settings
                                    enhanceDroneForIOS();
                                    // Ensure it's still connected
                                    try {
                                        const _ = droneOscillator.frequency.value;
                                        // Slightly modulate frequency to keep it "active"
                                        droneOscillator.frequency.value = 18 + Math.sin(Date.now() / 1000) * 0.1;
                                    } catch (e) {
                                        console.log('âš ï¸ iOS: Drone oscillator disconnected, restarting...');
                                        startDroneNote();
                                    }
                                }
                                // 5. Force audio context to stay active by touching masterGain
                                if (masterGain) {
                                    const currentGain = masterGain.gain.value;
                                    masterGain.gain.value = currentGain; // Trigger update
                                }
                                // 6. Ensure at least one oscillator is active
                                if (activeOscillators.size === 0 && audioContext && audioContext.state === 'running') {
                                    if (!droneOscillator) {
                                        startDroneNote();
                                    }
                                }
                                // 7. Keep video playing (iOS respects video playback)
                                if (!keepAliveVideo || keepAliveVideo.paused) {
                                    createKeepAliveVideo();
                                    if (keepAliveVideo) {
                                        keepAliveVideo.play().catch(() => {});
                                    }
                                }
                                // 8. Trigger visibility API to keep page "active"
                                if (document.visibilityState === 'visible') {
                                    // Trigger a tiny DOM update
                                    document.title = document.title === 'Soundflakes' ? 'Soundflakes ' : 'Soundflakes';
                                }
                            }
                        }, 2000); // Every 2 seconds (extremely aggressive for iOS)
                        
                        // Clean up interval and video on unmount
                        onUnmounted(() => {
                            if (iosKeepAliveInterval) {
                                clearInterval(iosKeepAliveInterval);
                            }
                            if (keepAliveVideo) {
                                keepAliveVideo.pause();
                                keepAliveVideo.remove();
                                keepAliveVideo = null;
                            }
                        });
                        
                        // Comprehensive auto-resume function
                        const performAutoResume = async () => {
                            console.log('ðŸ”„ Performing auto-resume after device wake...');
                            
                            // 1. Re-request wake lock immediately
                            requestWakeLock();
                            
                            // 2. Restart keep-alive video
                            if (typeof createKeepAliveVideo === 'function') {
                                const video = createKeepAliveVideo();
                                if (video) {
                                    if (video.paused || video.ended) {
                                        video.play().catch(() => {
                                            // If play fails, recreate video
                                            if (video.parentNode) {
                                                video.remove();
                                            }
                                            createKeepAliveVideo();
                                        });
                                    }
                                } else {
                                    createKeepAliveVideo();
                                }
                            }
                            
                            // 3. Check and reconnect WebSocket if needed
                            if (!ws.value || ws.value.readyState !== WebSocket.OPEN) {
                                console.log('âš ï¸ WebSocket disconnected after wake, reconnecting...');
                                connectWebSocket();
                                // Wait for connection, then request preset if needed
                                setTimeout(() => {
                                    if (isSlave && assignedNotes.value.length === 0 && ws.value && ws.value.readyState === WebSocket.OPEN) {
                                        console.log('âš ï¸ No notes after reconnection, requesting preset...');
                                        ws.value.send(JSON.stringify({
                                            type: 'request_preset'
                                        }));
                                    }
                                }, 2000);
                            } else {
                                // WebSocket still connected
                                if (isSlave && assignedNotes.value.length === 0) {
                                    console.log('âš ï¸ No notes assigned, requesting current preset...');
                                    ws.value.send(JSON.stringify({
                                        type: 'request_preset'
                                    }));
                                }
                            }
                            
                            // 4. Resume audio context and restart playback
                            if (!audioContext) {
                                console.log('âš ï¸ Audio context missing, initializing...');
                                try {
                                    await initAudio();
                                } catch (e) {
                                    console.error('Failed to initialize audio:', e);
                                    return;
                                }
                            }
                            
                            if (audioContext) {
                                // Try to resume audio context
                                if (audioContext.state === 'suspended' || audioContext.state === 'interrupted') {
                                    console.log('âš ï¸ Audio context suspended/interrupted, attempting to resume...');
                                    try {
                                        const resumePromise = audioContext.resume();
                                        const timeoutPromise = new Promise((_, reject) => 
                                            setTimeout(() => reject(new Error('Resume timeout')), 3000)
                                        );
                                        await Promise.race([resumePromise, timeoutPromise]);
                                        console.log('âœ“ Audio context resumed, state:', audioContext.state);
                                    } catch (e) {
                                        console.log('âš ï¸ Audio resume failed:', e.message);
                                        // Try again after a short delay
                                        setTimeout(async () => {
                                            try {
                                                await audioContext.resume();
                                                console.log('âœ“ Audio context resumed on retry');
                                            } catch (e2) {
                                                console.log('âš ï¸ Audio resume retry also failed:', e2.message);
                                            }
                                        }, 500);
                                    }
                                }
                                
                                // Wait a moment for audio context to stabilize
                                await new Promise(resolve => setTimeout(resolve, 200));
                                
                                // Ensure drone note is running
                                if (!droneOscillator && audioContext.state === 'running') {
                                    console.log('ðŸ”„ Restarting drone note...');
                                    startDroneNote();
                                    if (typeof enhanceDroneForIOS === 'function') {
                                        setTimeout(() => enhanceDroneForIOS(), 100);
                                    }
                                }
                                
                                // Restart playback if we were playing
                                if (isPlaying.value) {
                                    // Small delay to ensure everything is ready
                                    setTimeout(() => {
                                        if (isSlave) {
                                            if (assignedNotes.value.length > 0) {
                                                console.log('ðŸ”„ Restarting slave playback after device wake...');
                                                startSlavePlayback();
                                            } else {
                                                console.log('âš ï¸ Slave: No notes assigned, waiting for preset...');
                                            }
                                        } else {
                                            // Master: restart generators
                                            if (masterAssignedNotes.value.length > 0) {
                                                console.log('ðŸ”„ Restarting master generators after device wake...');
                                                startAllGenerators();
                                            } else {
                                                // If no assigned notes, use all enabled notes
                                                const enabledNotes = noteData.filter(n => n.enabled);
                                                if (enabledNotes.length > 0) {
                                                    console.log('ðŸ”„ Master: Restarting with all enabled notes...');
                                                    startAllGenerators();
                                                }
                                            }
                                        }
                                    }, 300);
                                }
                            }
                        };
                        
                        // Listen for visibility changes (device wake/sleep)
                        document.addEventListener('visibilitychange', () => {
                            if (document.visibilityState === 'visible') {
                                console.log('ðŸ“± Device woke up - starting auto-resume...');
                                // Perform comprehensive auto-resume
                                performAutoResume().catch(e => {
                                    console.error('Auto-resume error:', e);
                                    // Retry after a delay
                                    setTimeout(() => {
                                        performAutoResume().catch(e2 => {
                                            console.error('Auto-resume retry error:', e2);
                                        });
                                    }, 1000);
                                });
                            } else {
                                console.log('ðŸ“± Device went to sleep/standby');
                                // When going to sleep, ensure we preserve state
                                // The keep-alive interval will try to keep things active
                            }
                        });
                        
                        // Also listen for page focus (additional wake detection)
                        window.addEventListener('focus', () => {
                            if (document.visibilityState === 'visible' && isPlaying.value) {
                                console.log('ðŸ“± Page focused - checking if resume needed...');
                                // Small delay to avoid duplicate calls
                                setTimeout(() => {
                                    if (audioContext && (audioContext.state === 'suspended' || audioContext.state === 'interrupted')) {
                                        performAutoResume().catch(e => {
                                            console.error('Focus-based auto-resume error:', e);
                                        });
                                    }
                                }, 500);
                            }
                        });
                        
                        // Clean up wake lock on page unload
                        window.addEventListener('beforeunload', () => {
                            if (wakeLock) {
                                wakeLock.release();
                            }
                        });
                    }
                    
                    if (!isSlave) {
                        // Master-only: Wait for QRCode library to load, then generate QR code
                        const waitForQRCode = () => {
                            if (typeof QRCode !== 'undefined' || typeof window.QRCode !== 'undefined') {
                                setTimeout(() => {
                                    generateQRCode();
                                }, 300);
                            } else {
                                setTimeout(waitForQRCode, 100);
                            }
                        };
                        waitForQRCode();
                        
                        // Regenerate QR code on window resize
                        const resizeHandler = () => {
                            setTimeout(generateQRCode, 200);
                        };
                        window.addEventListener('resize', resizeHandler);
                        
                        // Watch for controls menu opening to regenerate QR code
                        watch(showControls, (newVal) => {
                            if (newVal) {
                                // Wait for menu animation to complete, then try multiple times
                                setTimeout(() => {
                                    generateQRCode();
                                }, 100);
                                setTimeout(() => {
                                    generateQRCode();
                                }, 400);
                                setTimeout(() => {
                                    generateQRCode();
                                }, 800);
                            }
                        });
                        
                        // Watch for QR code visibility to generate in fullscreen
                        watch(showQRCode, (newVal) => {
                            if (newVal) {
                                // Wait for fullscreen overlay to render, then generate QR code
                                setTimeout(() => {
                                    if (qrCanvasFullscreen.value && showQRCode.value) {
                                        generateQRCode(qrCanvasFullscreen.value);
                                    }
                                }, 100);
                                setTimeout(() => {
                                    if (qrCanvasFullscreen.value && showQRCode.value) {
                                        generateQRCode(qrCanvasFullscreen.value);
                                    }
                                }, 300);
                                setTimeout(() => {
                                    if (qrCanvasFullscreen.value && showQRCode.value) {
                                        generateQRCode(qrCanvasFullscreen.value);
                                    }
                                }, 600);
                            } else {
                                // Clear QR code when closed
                                if (qrCanvasFullscreen.value) {
                                    qrCanvasFullscreen.value.innerHTML = '';
                                }
                            }
                        });
                        
                        // Watch for note changes and send to slaves
                        watch(() => noteData.map(n => ({ enabled: n.enabled, freq: n.freq, volume: n.volume })), () => {
                            if (isPlaying.value && ws.value && ws.value.readyState === WebSocket.OPEN) {
                                sendPresetToSlaves();
                            }
                        }, { deep: true });
                        
                        // Watch for reference pitch changes and update all note frequencies
                        watch(() => settings.referencePitch, (newPitch, oldPitch) => {
                            if (oldPitch !== undefined && newPitch !== oldPitch) {
                                console.log(`Reference pitch changed from ${oldPitch} Hz to ${newPitch} Hz - updating all note frequencies`);
                                
                                // Recalculate frequencies for all notes
                                noteData.forEach((note, idx) => {
                                    if (note.note) {
                                        const newFreq = noteToFrequency(note.note);
                                        if (newFreq !== null) {
                                            note.freq = newFreq;
                                            console.log(`  Updated ${note.note}: ${newFreq} Hz`);
                                        }
                                    }
                                });
                                
                                // Update master assigned notes frequencies if master is included
                                if (settings.masterIncluded && masterAssignedNotes.value.length > 0) {
                                    masterAssignedNotes.value.forEach(note => {
                                        if (note.note) {
                                            const newFreq = noteToFrequency(note.note);
                                            if (newFreq !== null) {
                                                note.freq = newFreq;
                                            }
                                        }
                                    });
                                }
                                
                                // Update all slave assigned notes
                                connectedSlaves.forEach(slave => {
                                    if (slave.assignedNotes && slave.assignedNotes.length > 0) {
                                        slave.assignedNotes.forEach(note => {
                                            if (note.note) {
                                                const newFreq = noteToFrequency(note.note);
                                                if (newFreq !== null) {
                                                    note.freq = newFreq;
                                                }
                                            }
                                        });
                                    }
                                });
                                
                                // Send updated preset to slaves
                                if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                    console.log('Sending updated frequencies to slaves...');
                                    sendPresetToSlaves();
                                }
                                
                                // Restart playback if currently playing
                                if (isPlaying.value) {
                                    setTimeout(() => {
                                        if (isPlaying.value) {
                                            console.log('Restarting generators with new reference pitch...');
                                            startAllGenerators();
                                        }
                                    }, 100);
                                }
                            }
                        });
                        
                        // Watch for preset changes (excluding masterVolume to prevent conflicts)
                        // Master volume is handled separately with debouncing
                        let presetUpdateTimeout = null;
                        watch(() => [settings.noteLength, settings.pauseLength, settings.numGenerators, settings.masterIncluded], (newVal, oldVal) => {
                            // Debounce preset updates to prevent rapid changes
                            if (presetUpdateTimeout) {
                                clearTimeout(presetUpdateTimeout);
                            }
                            
                            presetUpdateTimeout = setTimeout(() => {
                                console.log('Settings changed, masterIncluded:', settings.masterIncluded);
                                if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                    console.log('Sending preset update to server...');
                                    sendPresetToSlaves();
                                    // If master inclusion changed and we're playing, restart
                                    if (isPlaying.value) {
                                        setTimeout(() => {
                                            if (isPlaying.value) {
                                                console.log('Restarting generators due to setting change...');
                                                startAllGenerators();
                                            }
                                        }, 100);
                                    }
                                } else {
                                    console.log('WebSocket not ready, cannot send preset update');
                                }
                            }, 200); // 200ms debounce for preset updates
                        });
                        
                        // Separate debounced watcher for master volume preset updates
                        let masterVolumePresetTimeout = null;
                        watch(() => settings.masterVolume, (volume) => {
                            // Debounce preset updates for volume separately
                            if (masterVolumePresetTimeout) {
                                clearTimeout(masterVolumePresetTimeout);
                            }
                            
                            masterVolumePresetTimeout = setTimeout(() => {
                                if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                    console.log('Sending master volume preset update to server...');
                                    sendPresetToSlaves();
                                }
                            }, 500); // Longer debounce for volume preset updates (500ms)
                        });
                        
                        // Watch for mute changes and update master gain with smooth ramping
                        if (!isSlave) {
                            watch(() => settings.masterMuted, (muted) => {
                                if (masterGain && audioContext) {
                                    const now = audioContext.currentTime;
                                    const targetVolume = muted ? 0 : settings.masterVolume / 100;
                                    
                                    // Get current gain, cancel scheduled changes, then re-read
                                    let currentGain = masterGain.gain.value;
                                    masterGain.gain.cancelScheduledValues(now);
                                    currentGain = masterGain.gain.value; // Re-read after cancellation
                                    
                                    // Use setTargetAtTime for smoother transitions
                                    // Time constant of 0.15 seconds matches volume knob and slave sliders for consistent feel
                                    const epsilon = 0.0001;
                                    const targetGainSafe = Math.max(targetVolume, epsilon);
                                    
                                    // Cancel scheduled changes and use setTargetAtTime for smooth transition
                                    masterGain.gain.cancelScheduledValues(now);
                                    masterGain.gain.setTargetAtTime(targetGainSafe, now, 0.15);
                                }
                            });
                            
                            // Update volume immediately while turning, but use setTargetAtTime for smooth transitions
                            watch(() => settings.masterVolume, (volume) => {
                                if (masterGain && audioContext && !settings.masterMuted) {
                                    const now = audioContext.currentTime;
                                    const targetVolume = volume / 100;
                                    
                                    // Cancel any scheduled changes to prevent conflicts
                                    masterGain.gain.cancelScheduledValues(now);
                                    
                                    // Use setTargetAtTime for smooth exponential approach
                                    // Time constant of 0.15 seconds matches slave volume sliders for consistent feel
                                    const epsilon = 0.0001;
                                    const targetGainSafe = Math.max(targetVolume, epsilon);
                                    
                                    masterGain.gain.setTargetAtTime(targetGainSafe, now, 0.15);
                                }
                            });
                        }
                        
                        // For slaves: monitor audio context state and keep it running
                        if (isSlave) {
                            setInterval(() => {
                                if (isPlaying.value && audioContext && audioContext.state === 'suspended') {
                                    console.log('âš ï¸ Audio context suspended during playback, attempting to resume...');
                                    console.log('isPlaying:', isPlaying.value, 'assignedNotes:', assignedNotes.value.length);
                                    // Try to resume with timeout
                                    const resumePromise = audioContext.resume();
                                    const timeoutPromise = new Promise((_, reject) => 
                                        setTimeout(() => reject(new Error('Resume timeout')), 1000)
                                    );
                                    Promise.race([resumePromise, timeoutPromise]).then(() => {
                                        console.log('âœ“ Audio context resumed successfully during playback');
                                    }).catch(e => {
                                        console.error('âœ— Failed to resume audio context during playback:', e.message);
                                        // If resume fails, try to restart playback
                                        console.log('Attempting to restart playback...');
                                        if (assignedNotes.value.length > 0) {
                                            startSlavePlayback();
                                        }
                                    });
                                }
                                // Also check if we're supposed to be playing but aren't
                                if (isPlaying.value && assignedNotes.value.length > 0 && generatorTimeouts.length === 0) {
                                    console.log('âš ï¸ Should be playing but no generators active, restarting...');
                                    startSlavePlayback();
                                }
                            }, 2000); // Check every 2 seconds
                        }
                        
                        // Save default palette on first load if it doesn't exist
                        const palettes = JSON.parse(localStorage.getItem('soundmarbles-palettes') || '[]');
                        const hasDefault = palettes.some(p => p.name === 'Default');
                        if (!hasDefault) {
                            const defaultPalette = {
                                name: 'Default',
                                notes: noteData.map(n => ({
                                    note: n.note,
                                    freq: n.freq,
                                    color: n.color,
                                    volume: n.volume,
                                    enabled: n.enabled
                                }))
                            };
                            palettes.push(defaultPalette);
                            localStorage.setItem('soundmarbles-palettes', JSON.stringify(palettes));
                        }
                    }
                });
                
                return {
                    canvas, qrCanvas, qrCanvasFullscreen, showQRCode, isPlaying, showControls, settings, noteData,
                    togglePlayback, openMenu, closeMenu, toggleMenu, savePreset, loadPreset,
                    currentPaletteName, showPaletteEditor, newNoteName, newNoteFreq,
                    addNote, removeNote, createNewPalette, saveCurrentPalette, loadPalette,
                    calculateFrequency, updateNoteFrequency,
                    // WebSocket and slave-related reactive variables
                    ws, wsConnected, wsReceivedWelcome, wsError, assignedNotes, isSlave, slaveStatus,
                    connectedSlaves, totalSlaves, masterAssignedNotes, masterCurrentlyPlayingNote, masterVolume, displaySlaves, updateSlaveVolume, getSlaveDisplayVolume, slaveName, slaveVolume, slaveCurrentlyPlayingNote, getPlayingNoteStyle, sendPresetToSlaves, distributeNotesToSlaves,
                    // Tap handler for iOS
                    handleTapToStart,
                    // Master included toggle
                    toggleMasterIncluded,
                    // Fullscreen control
                    isFullscreen, requestFullscreenMode, exitFullscreenMode,
                    // Sleep prevention tip
                    showSleepPreventionTip, isIOSDevice, openIOSSettings,
                    // Audio state for overlay
                    audioUnlocked: () => audioUnlocked,
                    audioContext: () => audioContext
                };
            }
        }).mount('#app');
    </script>
</body>
</html>