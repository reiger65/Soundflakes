<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdn.tailwindcss.com https://unpkg.com https://cdnjs.cloudflare.com; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.tailwindcss.com https://unpkg.com https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://cdn.tailwindcss.com;">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Soundflakes</title>
    <link rel="icon" type="image/jpeg" href="/logo.jpg" id="favicon">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@300;400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.js"></script>
    <style>
        * { touch-action: manipulation; -webkit-user-select: none; user-select: none; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background: #000; -webkit-text-size-adjust: 100%; }
        .knob { width: 50px; height: 50px; cursor: pointer; touch-action: none; -webkit-tap-highlight-color: transparent; }
        canvas { display: block; }
        input[type=range]::-webkit-slider-thumb { 
            appearance: none; 
            width: 20px; 
            height: 20px; 
            background: #374151; 
            border: 2px solid var(--slider-color, #6b7280); 
            border-radius: 50%; 
            cursor: pointer;
        }
        input[type=range]::-moz-range-thumb { 
            width: 20px; 
            height: 20px; 
            background: #374151; 
            border: 2px solid var(--slider-color, #6b7280); 
            border-radius: 50%; 
            cursor: pointer;
        }
        .menu-slide { animation: slideInRight 0.3s ease-out; }
        @keyframes slideInRight {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }
        .apple-button {
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            background: rgba(255, 255, 255, 0.1);
            border: 0.5px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        .apple-button:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        .apple-button:active {
            transform: scale(0.95);
        }
        .button-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }
        .note-playing {
            animation: notePulse 1.2s ease-in-out infinite !important;
            z-index: 10;
            position: relative;
        }
        @keyframes notePulse {
            0%, 100% {
                box-shadow: 0 0 8px currentColor, 0 0 4px currentColor !important;
                opacity: 1 !important;
            }
            50% {
                box-shadow: 0 0 16px currentColor, 0 0 8px currentColor !important;
                opacity: 0.95 !important;
            }
        }
        .apple-input {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.08);
            border: 0.5px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
        }
        .apple-input:focus {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.3);
            outline: none;
        }
        /* Tutorial content styling */
        .tutorial-content {
            font-size: 14px;
        }
        .tutorial-content h2 {
            font-size: 18px !important;
        }
        .tutorial-content h3 {
            font-size: 16px !important;
        }
        .tutorial-content p, .tutorial-content li, .tutorial-content code {
            font-size: 14px !important;
        }
        .apple-button-secondary {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.08);
            border: 0.5px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            transition: all 0.2s;
        }
        .apple-button-secondary:hover {
            background: rgba(255, 255, 255, 0.12);
        }
        .apple-button-secondary:active {
            transform: scale(0.97);
        }
    </style>
</head>
<body>
    <!-- Intro Overlay -->
    <div id="intro-overlay" class="fixed inset-0 z-[100] bg-black flex flex-col items-center justify-center" style="transition: opacity 0.8s ease-out;">
        <!-- Intro Canvas for Visualization -->
        <canvas id="intro-canvas" class="absolute inset-0 w-full h-full"></canvas>
        
        <!-- Intro Text Container -->
        <div class="relative z-10 flex flex-col items-center justify-center text-center px-6" style="pointer-events: none;">
            <!-- Backdrop for better readability -->
            <div class="absolute inset-0 backdrop-blur-md bg-black bg-opacity-40 rounded-2xl" style="margin: -20px;"></div>
            
            <!-- Stonewhistle presents -->
            <div id="intro-text-1" class="relative text-white text-lg md:text-xl opacity-0 mb-4" style="font-family: 'Be Vietnam Pro', sans-serif; font-weight: 300; transition: opacity 0.6s ease-in, transform 0.6s ease-out; transform: translateY(20px); text-shadow: 0 2px 8px rgba(0,0,0,0.8), 0 0 20px rgba(0,0,0,0.6);">
                Stonewhistle presents
            </div>
            
            <!-- Soundflakes -->
            <div id="intro-text-2" class="relative text-white text-4xl md:text-5xl font-bold opacity-0 mb-8" style="font-family: 'Be Vietnam Pro', sans-serif; font-weight: 700; transition: opacity 0.8s ease-in, transform 0.8s ease-out; transform: translateY(20px); text-shadow: 0 4px 12px rgba(0,0,0,0.9), 0 0 30px rgba(0,0,0,0.7), 0 0 40px rgba(0,0,0,0.5);">
                Soundflakes
            </div>
            
            <!-- Subtitle -->
            <div id="intro-text-3" class="relative text-white text-sm md:text-base opacity-0 max-w-md" style="font-family: 'Be Vietnam Pro', sans-serif; font-weight: 300; transition: opacity 0.6s ease-in, transform 0.6s ease-out; transform: translateY(20px); text-shadow: 0 2px 8px rgba(0,0,0,0.8), 0 0 20px rgba(0,0,0,0.6);">
                An interactive Soundexperience for multiple mobile devices
            </div>
        </div>
    </div>
    
    <div id="app" class="w-screen h-screen relative bg-black opacity-0" style="width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; transition: opacity 0.8s ease-in;">
        <canvas ref="canvas" class="absolute inset-0 w-full h-full" style="width: 100%; height: 100%; display: block;"></canvas>
        
        <!-- Play button moved to controls menu -->
        
        <!-- Sleep Prevention Tip for iOS Slaves -->
        <div v-if="isSlave && isIOSDevice && !showSleepPreventionTip" 
             class="fixed bottom-6 left-6 right-6 z-50 apple-input px-3 py-2 rounded-lg border border-yellow-500 border-opacity-50">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-2">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-yellow-400">
                        <circle cx="12" cy="12" r="10"/>
                        <path d="M12 16v-4M12 8h.01"/>
                    </svg>
                    <span class="text-white text-xs">Prevent sleep: Settings â†’ Display â†’ Auto-Lock â†’ Never</span>
                </div>
                <button @click.stop="showSleepPreventionTip = true" class="text-white opacity-60 text-xs">More</button>
            </div>
        </div>
        
        <!-- Expanded Sleep Prevention Tip for Slaves -->
        <div v-if="isSlave && isIOSDevice && showSleepPreventionTip" 
             class="fixed bottom-6 left-6 right-6 z-50 apple-input px-3 py-3 rounded-lg border border-yellow-500 border-opacity-50">
            <div class="flex items-start justify-between mb-2">
                <div class="flex items-center space-x-2">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-yellow-400">
                        <circle cx="12" cy="12" r="10"/>
                        <path d="M12 16v-4M12 8h.01"/>
                    </svg>
                    <span class="text-white text-xs font-medium">Prevent iPhone Sleep</span>
                </div>
                <button @click.stop="showSleepPreventionTip = false" class="text-white opacity-60">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M18 6L6 18M6 6l12 12"/>
                    </svg>
                </button>
            </div>
            <div class="text-white text-xs opacity-80 leading-relaxed space-y-1">
                <p>To prevent your iPhone from sleeping:</p>
                <ol class="list-decimal list-inside space-y-0.5 ml-2">
                    <li>Open <strong>Settings</strong> app</li>
                    <li>Go to <strong>Display & Brightness</strong></li>
                    <li>Tap <strong>Auto-Lock</strong></li>
                    <li>Select <strong>Never</strong></li>
                </ol>
                <button @click.stop="openIOSSettings" 
                        class="mt-2 w-full apple-button px-3 py-1.5 rounded-lg text-white text-xs font-medium flex items-center justify-center space-x-2">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                        <polyline points="17 21 17 13 7 13 7 21"/>
                        <polyline points="7 3 7 8 15 8"/>
                    </svg>
                    <span>Open Settings</span>
                </button>
                <p class="text-yellow-300 text-xs mt-1">ðŸ’¡ Change it back after your session!</p>
            </div>
        </div>
        
        <!-- Help/Tutorial Button -->
        <button v-if="!isSlave" @click="showTutorial = !showTutorial" 
                class="fixed top-6 right-6 z-50 w-8 h-8 rounded-full flex items-center justify-center apple-button-secondary transition-all duration-200"
                :class="showTutorial ? 'bg-blue-600' : ''"
                style="touch-action: manipulation;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white">
                <circle cx="12" cy="12" r="10"/>
                <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                <path d="M12 17h.01"/>
            </svg>
        </button>
        
        <!-- Sound Flake status indicator -->
        <div v-if="isSlave" class="fixed top-6 right-6 z-50 apple-button px-4 py-2 rounded-lg flex flex-col items-center space-y-1 min-w-[120px]">
            <div class="flex items-center space-x-2">
                <div class="w-3 h-3 rounded-full" :class="wsConnected && wsReceivedWelcome && assignedNotes && assignedNotes.length > 0 ? 'bg-green-400' : 'bg-red-400'"></div>
                <span class="text-white text-xs font-medium">{{ slaveName ? 'Sound Flake ' + slaveName : 'Sound Flake' }}</span>
            </div>
            <div class="text-white text-xs opacity-70 text-center">
                <div v-if="!ws">Initializing...</div>
                <div v-else-if="wsConnected && wsReceivedWelcome && assignedNotes && assignedNotes.length > 0">
                    {{ assignedNotes.length }} note{{ assignedNotes.length !== 1 ? 's' : '' }}
                </div>
                <div v-else-if="wsConnected && wsReceivedWelcome && (!assignedNotes || assignedNotes.length === 0)">Waiting for notes...</div>
                <div v-else-if="wsConnected && !wsReceivedWelcome">Connected, registering...</div>
                <div v-else-if="ws && ws.readyState === 2">Closing...</div>
                <div v-else-if="ws && ws.readyState === 3">Disconnected</div>
                <div v-else-if="ws && ws.readyState === 0">Connecting...</div>
                <div v-else-if="ws && ws.readyState === 1 && wsConnected">Connected</div>
                <div v-else>Connecting...</div>
            </div>
            <!-- Assigned Notes Display for Sound Flake -->
            <div v-if="isSlave && assignedNotes && assignedNotes.length > 0" class="mt-2 px-2">
                <div class="text-white text-xs opacity-70 mb-1 text-center">Assigned notes:</div>
                <div class="flex flex-wrap gap-1 justify-center">
                    <span 
                        v-for="note in assignedNotes" 
                        :key="note.note"
                        class="px-1.5 py-0.5 rounded text-xs font-mono inline-block"
                        :style="getPlayingNoteStyle(note, slaveCurrentlyPlayingNote === note.note)"
                        :class="{ 'note-playing': slaveCurrentlyPlayingNote === note.note }"
                    >
                        {{ note.note }}
                    </span>
                </div>
            </div>
            <!-- Status message -->
            <div v-if="slaveStatus" class="text-white text-xs mt-1 opacity-60 text-center">
                {{ slaveStatus }}
            </div>
            <!-- Error/Info display -->
            <div v-if="wsError" class="text-yellow-300 text-xs mt-2 max-w-[200px] break-words text-center font-semibold animate-pulse">
                {{ wsError }}
            </div>
        </div>
        
        <!-- Full-screen tap prompt for iOS - Show immediately when slave connects, before notes assigned -->
        <div v-if="isSlave && !audioReady" 
             class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-90"
             @touchstart.prevent.stop="handleTapToStart"
             @touchend.prevent.stop="handleTapToStart"
             @click.prevent.stop="handleTapToStart"
             style="touch-action: manipulation;">
            <div class="bg-white rounded-2xl p-10 mx-6 text-center shadow-2xl animate-pulse">
                <div class="text-5xl mb-6">ðŸŽµ</div>
                <div class="text-3xl font-bold text-black mb-4">Tap to Activate Audio</div>
                <div class="text-lg text-gray-700 mb-2">Tap anywhere on the screen</div>
                <div class="text-sm text-gray-500">to enable automatic playback</div>
                <div v-if="assignedNotes.length > 0" class="text-xs text-gray-400 mt-4">Ready to play {{ assignedNotes.length }} note{{ assignedNotes.length !== 1 ? 's' : '' }}</div>
                <div v-else class="text-xs text-gray-400 mt-4">Waiting for master connection...</div>
            </div>
        </div>
        
        <!-- Right-side menu (master only) - always visible -->
        <div v-if="!isSlave" 
             class="fixed inset-0 z-40"
             style="pointer-events: none;">
            <div v-show="true" class="absolute top-0 left-1/2 -translate-x-1/2 h-full w-full max-w-md backdrop-filter backdrop-blur-xl bg-black bg-opacity-60 shadow-2xl overflow-hidden flex flex-col"
                 style="pointer-events: auto; transition: none;">
                <!-- Header -->
                <div class="flex items-center justify-center px-4 py-2 border-b border-white border-opacity-10">
                    <div class="flex items-center gap-2">
                        <img src="/logo.jpg" alt="Soundflakes" class="w-8 h-8 rounded-full flex-shrink-0" id="logo-img" onerror="this.style.display='none';" onload="this.style.display='block';">
                        <div class="flex flex-col items-center">
                            <span class="text-white text-xs opacity-70" style="font-family: 'Be Vietnam Pro', sans-serif; font-weight: 300;">Stonewhistle presents:</span>
                            <h2 class="text-white text-lg font-bold tracking-tight" style="font-family: 'Be Vietnam Pro', sans-serif; font-weight: 700;">Soundflakes</h2>
                        </div>
                    </div>
                </div>
                
                <!-- Content -->
                <div class="overflow-y-auto flex-1 px-4 py-3 space-y-2">
                
                <div class="grid grid-cols-5 gap-1 mb-6">
                    <div class="text-center">
                        <label class="text-gray-300 text-xs font-medium block mb-0.5 opacity-70">Play</label>
                        <button @click="togglePlayback" 
                                class="apple-button w-12 h-12 rounded-full flex items-center justify-center text-white transition-all duration-200 mx-auto"
                                :class="isPlaying ? 'button-pulse' : ''"
                                style="touch-action: manipulation;">
                            <svg v-if="!isPlaying" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-left: 2px; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));">
                                <path d="M8 5v14l11-7z" stroke="currentColor" stroke-width="0.5"/>
                            </svg>
                            <svg v-else width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));">
                                <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z" stroke="currentColor" stroke-width="0.5"/>
                            </svg>
                        </button>
                    </div>
                    <div class="text-center">
                        <label class="text-gray-300 text-xs font-medium block mb-0.5 opacity-70">Length</label>
                        <svg-knob v-model="settings.noteLength" :min="2" :max="15" :step="0.1" unit="s"></svg-knob>
                    </div>
                    <div class="text-center">
                        <label class="text-gray-300 text-xs font-medium block mb-0.5 opacity-70">Pause</label>
                        <svg-knob v-model="settings.pauseLength" :min="0" :max="10" :step="0.1" unit="s"></svg-knob>
                    </div>
                    <div class="text-center">
                        <label class="text-white text-xs font-medium block mb-0.5 opacity-70">Volume</label>
                        <svg-knob v-model="settings.masterVolume" :min="0" :max="100" :step="1" unit="%"></svg-knob>
                    </div>
                    <div class="text-center">
                        <label class="text-gray-300 text-xs font-medium block mb-0.5 opacity-70">QR Code</label>
                        <button @click="showQRCode = !showQRCode" 
                                class="w-12 h-12 rounded-full flex items-center justify-center transition-all duration-200 mx-auto apple-button"
                                :class="showQRCode ? 'bg-blue-600' : ''">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#FFFFFF" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="filter: drop-shadow(0 1px 2px rgba(0,0,0,0.4));">
                                <rect x="3" y="3" width="5" height="5" fill="#FFFFFF"/>
                                <rect x="16" y="3" width="5" height="5" fill="#FFFFFF"/>
                                <rect x="3" y="16" width="5" height="5" fill="#FFFFFF"/>
                                <path d="M21 16h-3a2 2 0 0 0-2 2v3" fill="none"/>
                                <path d="M16 8h2" fill="none"/>
                                <path d="M8 16v2" fill="none"/>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <!-- Master Included Toggle -->
                <div class="mb-4 px-2 py-2 apple-input rounded-lg">
                    <div class="flex items-center justify-between gap-2">
                        <span class="text-gray-300 text-sm font-bold flex-1">Include master in note distribution</span>
                        <button @click.stop.prevent="() => { console.log('BUTTON CLICKED DIRECTLY'); toggleMasterIncluded(); }"
                                @mousedown.stop.prevent
                                @touchstart.stop.prevent
                                class="apple-button-secondary px-1.5 py-1 rounded text-xs font-medium flex-shrink-0 transition-all"
                                :class="settings.masterIncluded ? 'text-gray-300 bg-emerald-700' : 'text-gray-400'"
                                style="touch-action: manipulation; -webkit-tap-highlight-color: transparent; z-index: 100;">
                            {{ settings.masterIncluded ? 'ON' : 'OFF' }}
                        </button>
                    </div>
                </div>
                
                <!-- Sound Flakes Volume Controls -->
                <div v-if="!isSlave && (connectedSlaves.length > 0 || settings.masterIncluded)" class="mb-4 px-2 py-2 apple-input rounded-lg">
                    <div class="text-gray-300 text-sm font-medium mb-3 flex items-center justify-between">
                        <span>Sound Flakes Volumes</span>
                        <span class="text-gray-300 text-xs opacity-60">{{ connectedSlaves.length }} connected</span>
                    </div>
                    
                    <!-- Master Flake - rendered separately with stable key to prevent slider jumping -->
                    <div v-if="settings.masterIncluded" class="mb-3 last:mb-0" :key="'master-flake-' + settings.masterIncluded">
                        <div class="flex items-center justify-between mb-1">
                            <span class="text-gray-300 text-xs opacity-80 font-medium">Sound Flake Master</span>
                            <span class="text-gray-300 text-xs opacity-60">{{ Math.round(masterVolume ?? 100) }}%</span>
                        </div>
                        <input 
                            ref="masterSliderRef"
                            type="range" 
                            v-model.number="masterVolume"
                            @input="updateSlaveVolume('master', masterVolume)"
                            @mousedown.stop
                            @touchstart.stop
                            min="0" 
                            max="100" 
                            step="1"
                            class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider"
                            style="touch-action: manipulation; --slider-color: #6b7280;">
                        
                        <!-- Assigned Notes Display - separate to avoid re-rendering slider -->
                        <div v-if="masterAssignedNotes && masterAssignedNotes.length > 0" class="mt-2 text-xs">
                            <div class="text-white opacity-70 mb-1">Assigned notes:</div>
                            <div class="flex flex-wrap gap-1">
                                <span 
                                    v-for="note in masterAssignedNotes" 
                                    :key="note.note"
                                    class="px-1.5 py-0.5 rounded text-xs font-mono inline-block"
                                    :style="getPlayingNoteStyle(note, masterCurrentlyPlayingNote === note.note)"
                                    :class="{ 'note-playing': masterCurrentlyPlayingNote === note.note }"
                                    :data-note-color="note.color"
                                >
                                    {{ note.note }}
                                </span>
                            </div>
                        </div>
                        <div v-else class="mt-2 text-xs text-white opacity-50">
                            No notes assigned
                        </div>
                    </div>
                    
                    <!-- Regular Slaves -->
                    <div v-for="(slave, index) in connectedSlaves" :key="slave.id" class="mb-3 last:mb-0">
                        <div class="flex items-center justify-between mb-1">
                            <span class="text-gray-300 text-xs opacity-80 font-medium">Sound Flake {{ slave.name || (index + 1) }}</span>
                            <span class="text-gray-300 text-xs opacity-60">{{ getSlaveDisplayVolume(slave) }}%</span>
                        </div>
                        <input 
                            type="range" 
                            :value="slave.volume"
                            @input="updateSlaveVolume(slave.id, parseFloat($event.target.value))"
                            @mousedown.stop
                            @touchstart.stop
                            min="0" 
                            max="100" 
                            step="1"
                            class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider"
                            style="touch-action: manipulation; --slider-color: #6b7280;">
                        
                        <!-- Assigned Notes Display -->
                        <div v-if="slave.assignedNotes && slave.assignedNotes.length > 0" class="mt-2 text-xs">
                            <div class="text-white opacity-70 mb-1">Assigned notes:</div>
                            <div class="flex flex-wrap gap-1">
                                <span 
                                    v-for="note in slave.assignedNotes" 
                                    :key="note.note"
                                    class="px-1.5 py-0.5 rounded text-xs font-mono inline-block"
                                    :style="getPlayingNoteStyle(note, slave.currentlyPlayingNote === note.note)"
                                    :class="{ 'note-playing': slave.currentlyPlayingNote === note.note }"
                                    :data-note-color="note.color"
                                >
                                    {{ note.note }}
                                </span>
                            </div>
                        </div>
                        <div v-else class="mt-2 text-xs text-white opacity-50">
                            No notes assigned
                        </div>
                    </div>
                </div>
                
                <!-- Sound Preset Selector and Controls -->
                <div class="space-y-1.5 apple-input px-2.5 py-2">
                    <div class="text-gray-300 text-sm font-medium mb-2">Sound Options</div>
                    <div class="flex items-center space-x-2">
                        <!-- Sound Preset Selector -->
                        <select v-model="currentPresetName" @change="loadSynthPresetByName($event.target.value)"
                                class="apple-button-secondary px-2 py-1 rounded text-gray-300 text-xs opacity-70 hover:opacity-100 transition-opacity flex-1 min-w-0"
                                style="touch-action: manipulation; background: rgba(255, 255, 255, 0.08); border: 0.5px solid rgba(255, 255, 255, 0.15); cursor: pointer;">
                            <option v-for="preset in synthPresets" :key="preset.name" :value="preset.name">
                                {{ preset.name }}
                            </option>
                        </select>
                        <!-- Transpose dropdown -->
                        <select @change="transposeAllNotes($event.target.value); $event.target.value = ''" class="apple-button-secondary px-1.5 py-1 rounded text-gray-300 text-xs opacity-70 hover:opacity-100 transition-opacity" style="touch-action: manipulation; background: rgba(255, 255, 255, 0.08); border: 0.5px solid rgba(255, 255, 255, 0.15); cursor: pointer; max-width: 90px;">
                            <option value="">Transpose...</option>
                            <option value="up">Raise semitone</option>
                            <option value="down">Lower semitone</option>
                        </select>
                        <!-- Reference Pitch toggle -->
                        <button @click="settings.referencePitch = settings.referencePitch === 440 ? 432 : 440" 
                                class="apple-button-secondary px-2 py-1 rounded text-gray-300 text-xs opacity-70 hover:opacity-100 transition-opacity" 
                                style="touch-action: manipulation; min-width: 50px; display: inline-flex; align-items: center; justify-content: center;">
                            {{ settings.referencePitch }} Hz
                        </button>
                        <!-- Advanced settings toggle -->
                        <button @click="showAdvancedSettings = !showAdvancedSettings" class="apple-button-secondary px-2 py-1 rounded flex items-center space-x-1.5 text-gray-300 opacity-70 hover:opacity-100 transition-opacity text-xs" style="touch-action: manipulation;">
                            <svg v-if="showAdvancedSettings" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M18 15l-6-6-6 6"/>
                            </svg>
                            <svg v-else width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M6 9l6 6 6-6"/>
                            </svg>
                            <span>{{ showAdvancedSettings ? 'Simple' : 'Advanced' }}</span>
                        </button>
                    </div>
                </div>
                <!-- Preset controls and Keys -->
                <div class="space-y-1.5 apple-input px-2.5 py-2">
                        <div class="text-gray-300 text-sm font-medium mb-2">Presets</div>
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex-1 relative preset-menu-container">
                                <select v-model="currentNotePreset" @change="loadNotePreset($event.target.value)" 
                                        class="apple-button-secondary px-2 py-1 rounded text-gray-300 text-xs opacity-70 hover:opacity-100 transition-opacity w-full" 
                                        style="touch-action: manipulation; background: rgba(255, 255, 255, 0.08); border: 0.5px solid rgba(255, 255, 255, 0.15); cursor: pointer;">
                                    <option v-for="preset in allPresets" :key="preset.name" :value="preset.name">
                                        {{ preset.name }}
                                    </option>
                                </select>
                            </div>
                            <button @click="showPaletteEditor = !showPaletteEditor" class="apple-button-secondary px-2 py-0.5 text-gray-300 text-xs font-medium ml-2 flex-shrink-0">
                                {{ showPaletteEditor ? 'Hide' : 'Edit' }}
                        </button>
                    </div>
                    <!-- Header row -->
                    <div class="flex items-center space-x-1.5 px-2 py-1 text-xs opacity-60">
                        <div class="w-2.5 flex-shrink-0"></div>
                        <span class="text-gray-300 font-medium flex-shrink-0" :class="showPaletteEditor ? 'w-14' : 'w-9'">Key</span>
                        <span v-if="showAdvancedSettings && showPaletteEditor" class="text-gray-300 text-[10px] w-18 flex-shrink-0">Hertz</span>
                        <span v-else-if="showAdvancedSettings" class="text-gray-300 text-[10px] w-14 flex-shrink-0">Hertz</span>
                        <div v-if="showAdvancedSettings" class="flex items-center justify-center w-[65px] flex-shrink-0">
                            <span class="text-gray-300 text-xs">Cents</span>
                        </div>
                        <div class="flex-1 flex items-center justify-center min-w-0">
                            <span class="text-gray-300 text-xs">Volume</span>
                        </div>
                        <span class="text-gray-300 text-xs w-6 text-right flex-shrink-0">%</span>
                        <div class="flex-shrink-0" :class="showPaletteEditor ? 'w-[58px]' : 'w-[45px]'"></div>
                    </div>
                    <!-- Note rows -->
                    <div v-for="(note, idx) in noteData" :key="idx" class="flex items-center space-x-1.5 px-2 py-1.5 rounded" :style="{ borderLeft: '2px solid ' + note.color, background: 'rgba(255, 255, 255, 0.04)', backdropFilter: 'blur(10px)', WebkitBackdropFilter: 'blur(10px)', border: '0.5px solid rgba(255, 255, 255, 0.1)' }">
                        <div class="w-2.5 h-2.5 rounded-full flex-shrink-0" :style="{ backgroundColor: note.color }"></div>
                        <!-- Note name - editable when in edit mode -->
                        <input v-if="showPaletteEditor" v-model="note.note" @input="updateNoteFrequency(idx)" class="apple-input w-14 px-1.5 py-1 text-white text-xs flex-shrink-0" maxlength="4" placeholder="Note">
                        <span v-else class="text-gray-300 text-xs font-medium w-9 flex-shrink-0">{{ note.note }}</span>
                        <!-- Frequency - editable when in edit mode AND advanced settings -->
                        <input v-if="showPaletteEditor && showAdvancedSettings" v-model.number="note.freq" type="number" @input="updateNoteFrequency(idx)" class="apple-input w-18 px-1.5 py-1 text-white text-xs flex-shrink-0" step="0.01" min="50" max="2000" placeholder="Hz">
                        <span v-else-if="showAdvancedSettings" class="text-gray-300 text-[10px] opacity-60 w-14 flex-shrink-0">{{ note.freq.toFixed(2) }} Hz</span>
                        <!-- Cent adjustment buttons -->
                        <div v-if="showAdvancedSettings" class="flex items-center space-x-1 flex-shrink-0" :class="showPaletteEditor ? 'w-[40px]' : 'w-[40px]'">
                            <div v-if="showPaletteEditor" class="flex flex-col space-y-0.5">
                                <button @click="adjustNoteFrequency(idx, 1)" class="apple-button-secondary w-4 h-4 rounded text-xs leading-none flex items-center justify-center text-gray-300 opacity-70 hover:opacity-100" style="touch-action: manipulation; padding: 0;">+</button>
                                <button @click="adjustNoteFrequency(idx, -1)" class="apple-button-secondary w-4 h-4 rounded text-xs leading-none flex items-center justify-center text-gray-300 opacity-70 hover:opacity-100" style="touch-action: manipulation; padding: 0;">âˆ’</button>
                            </div>
                            <span class="text-gray-300 text-xs opacity-50" :class="showPaletteEditor ? '' : 'ml-0'">{{ getCentsOffset(note) !== 0 ? (getCentsOffset(note) > 0 ? '+' : '') + getCentsOffset(note) + 'Â¢' : (showPaletteEditor ? '0Â¢' : '') }}</span>
                        </div>
                        <input type="range" v-model.number="note.volume" min="0" max="100" class="flex-1 h-1 rounded-lg appearance-none min-w-0" :style="{ background: `linear-gradient(to right, ${note.color} 0%, ${note.color} ${note.volume}%, rgba(255,255,255,0.1) ${note.volume}%, rgba(255,255,255,0.1) 100%)`, '--slider-color': note.color }">
                        <span class="text-gray-300 text-xs w-6 text-right flex-shrink-0">{{ note.volume }}%</span>
                        <button @click="note.enabled = !note.enabled" class="apple-button-secondary px-1.5 py-1 text-xs font-medium flex-shrink-0 transition-all" :class="note.enabled ? 'text-gray-300 bg-emerald-700' : 'text-gray-400'">{{ note.enabled ? 'ON' : 'OFF' }}</button>
                        <button v-if="showPaletteEditor" @click="removeNote(idx)" class="apple-button-secondary w-6 h-6 rounded-full flex items-center justify-center text-white text-xs leading-none flex-shrink-0 ml-1">Ã—</button>
                    </div>
                    <!-- Insert new key button - shown when in edit mode -->
                    <div v-if="showPaletteEditor" class="px-2 py-2">
                        <button @click="showAddNoteInput = !showAddNoteInput" class="apple-button-secondary px-3 py-1.5 rounded text-gray-300 text-xs font-medium flex items-center space-x-1.5 w-full justify-center" style="touch-action: manipulation;">
                            <span class="text-lg leading-none">+</span>
                            <span>insert new key</span>
                    </button>
                        <!-- Add note input row - shown when button is clicked -->
                        <div v-if="showAddNoteInput" class="flex items-center space-x-1.5 px-2 py-1.5 apple-input mt-2">
                            <div class="w-2.5 h-2.5 rounded-full flex-shrink-0 bg-gray-500"></div>
                            <input v-model="newNoteName" @input="calculateFrequency" placeholder="E4" class="apple-input w-16 px-1.5 py-1 text-white text-xs flex-shrink-0" maxlength="4">
                            <input v-model.number="newNoteFreq" type="number" placeholder="Hz" class="apple-input w-18 px-1.5 py-1 text-white text-xs flex-shrink-0" step="0.01" min="50" max="2000">
                            <div class="flex-1"></div>
                            <button @click="addNoteAndClose" class="apple-button-secondary px-2 py-1 text-white text-xs font-medium flex-shrink-0">Add</button>
                </div>
                </div>
                    <!-- Save Preset button - shown when in edit mode -->
                    <div v-if="showPaletteEditor" class="px-2 py-2">
                        <button @click="savePreset" class="w-full apple-button-secondary px-2 py-1.5 text-gray-300 text-xs font-medium">Save Preset</button>
                    </div>
                </div>
                
                <!-- Sleep Prevention Tip for iOS -->
                <div v-if="isIOSDevice" class="mt-4 px-3 py-3 apple-input rounded-lg border border-yellow-500 border-opacity-50">
                    <div class="flex items-start justify-between mb-2">
                        <div class="flex items-center space-x-2">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-yellow-400">
                                <circle cx="12" cy="12" r="10"/>
                                <path d="M12 16v-4M12 8h.01"/>
                            </svg>
                            <span class="text-white text-sm font-medium">Prevent iPhone Sleep</span>
                        </div>
                        <button @click.stop="showSleepPreventionTip = !showSleepPreventionTip" class="text-white opacity-60 hover:opacity-100">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M18 6L6 18M6 6l12 12"/>
                            </svg>
                        </button>
                    </div>
                    <div v-if="showSleepPreventionTip" class="text-white text-xs opacity-80 leading-relaxed space-y-2">
                        <p>To prevent your iPhone from sleeping during playback:</p>
                        <ol class="list-decimal list-inside space-y-1 ml-2">
                            <li>Open <strong>Settings</strong> app</li>
                            <li>Go to <strong>Display & Brightness</strong></li>
                            <li>Tap <strong>Auto-Lock</strong></li>
                            <li>Select <strong>Never</strong></li>
                        </ol>
                        <button @click.stop="openIOSSettings" 
                                class="mt-3 w-full apple-button px-3 py-2 rounded-lg text-white text-xs font-medium flex items-center justify-center space-x-2">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                                <polyline points="17 21 17 13 7 13 7 21"/>
                                <polyline points="7 3 7 8 15 8"/>
                            </svg>
                            <span>Open Settings App</span>
                        </button>
                        <p class="text-yellow-300 text-xs mt-2">ðŸ’¡ Remember to change it back after your session to save battery!</p>
                    </div>
                    <div v-else class="text-white text-xs opacity-60 cursor-pointer" @click="showSleepPreventionTip = true">
                        Tap to see instructions â†’
                    </div>
                </div>
                </div>
                <!-- QR Code section hidden by default -->
                <div v-if="showQRCode" class="px-4 pb-3 flex-1 flex flex-col min-h-0">
                    <div class="text-center px-3 py-2 apple-input border-dashed flex-1 flex flex-col items-center justify-center min-h-0">
                        <div class="text-white text-xs font-medium mb-2 opacity-70">QR Code for Slaves</div>
                        <div class="apple-input flex items-center justify-center flex-1 w-full max-w-full aspect-square p-2" style="min-height: 0;" ref="qrCanvas">
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Fullscreen QR Code Overlay -->
        <div v-if="showQRCode && !isSlave" 
             class="fixed inset-0 z-[100] bg-black bg-opacity-95 flex items-center justify-center"
             @click.self="showQRCode = false"
             style="touch-action: manipulation;">
            <div class="relative w-full h-full flex flex-col items-center justify-center p-8">
                <button @click="showQRCode = false"
                        class="absolute top-4 right-4 w-12 h-12 rounded-full flex items-center justify-center text-white bg-gray-800 hover:bg-gray-700 transition-all duration-200 z-20"
                        style="touch-action: manipulation; cursor: pointer;">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
                <div class="text-white text-lg font-medium mb-4">QR Code for Slaves</div>
                <div class="flex items-center justify-center w-full max-w-md aspect-square p-8 bg-white rounded-lg" ref="qrCanvasFullscreen">
                </div>
            </div>
        </div>
        
        <!-- Tutorial/Help Overlay -->
        <div v-if="showTutorial && !isSlave" 
             class="fixed inset-0 z-[200] bg-black bg-opacity-95 flex"
             style="touch-action: manipulation; backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);">
            <div class="flex w-full h-full">
                <!-- Side Menu - Condensed -->
                <div class="w-40 apple-input border-r border-gray-700 overflow-y-auto flex-shrink-0" style="background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);">
                    <div class="p-2 border-b border-gray-700 flex items-center justify-between">
                        <h2 class="text-white text-sm font-bold">Tutorial</h2>
                        <button @click="showTutorial = false" class="apple-button-secondary w-6 h-6 rounded-full flex items-center justify-center text-gray-300 hover:text-white transition-colors" style="touch-action: manipulation;">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="18" y1="6" x2="6" y2="18"/>
                                <line x1="6" y1="6" x2="18" y2="18"/>
                            </svg>
                        </button>
                    </div>
                    <nav class="p-1">
                        <button v-for="section in tutorialSections" 
                                :key="section.id"
                                @click="currentTutorialSection = section.id"
                                class="w-full text-left px-2 py-1.5 rounded-lg mb-0.5 transition-all text-xs"
                                :class="currentTutorialSection === section.id ? 'apple-button text-white' : 'apple-button-secondary text-gray-300 opacity-70 hover:opacity-100'"
                                style="touch-action: manipulation;">
                            {{ section.title }}
                        </button>
                    </nav>
                </div>
                
                <!-- Content Area -->
                <div class="flex-1 overflow-y-auto px-4 py-4" style="background: rgba(0, 0, 0, 0.3);">
                    <div v-for="section in tutorialSections" 
                         :key="section.id"
                         v-show="currentTutorialSection === section.id"
                         class="w-full">
                        <div class="apple-input px-4 py-4 rounded-lg mb-4">
                            <h1 class="text-white text-xl font-bold mb-2">{{ section.title }}</h1>
                        </div>
                        <div class="text-gray-300 space-y-4 leading-relaxed tutorial-content" v-html="section.content"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, reactive, computed, onMounted, onUnmounted, watch } = Vue;
        
        let enableVerboseLogs = false;
        try {
            enableVerboseLogs = typeof window !== 'undefined' && window.localStorage?.getItem?.('soundflakes-debug') === 'true';
        } catch (e) {
            enableVerboseLogs = false;
        }
        const debugLog = (...args) => {
            if (enableVerboseLogs) {
                console.log(...args);
            }
        };
        
        // Intro Animation System
        (function() {
            const introOverlay = document.getElementById('intro-overlay');
            const introCanvas = document.getElementById('intro-canvas');
            const app = document.getElementById('app');
            const text1 = document.getElementById('intro-text-1');
            const text2 = document.getElementById('intro-text-2');
            const text3 = document.getElementById('intro-text-3');
            
            if (!introOverlay || !introCanvas || !app) return;
            
            // Setup canvas
            const ctx = introCanvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            let introRotation = 0;
            const introParticles = [];
            
            function resizeIntroCanvas() {
                const rect = introCanvas.getBoundingClientRect();
                introCanvas.width = rect.width * dpr;
                introCanvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
            }
            
            resizeIntroCanvas();
            window.addEventListener('resize', resizeIntroCanvas);
            
            // Create intro particles (similar to slave visualization)
            function createIntroParticle(freq = 440, color = '#ffffff') {
                return {
                    color,
                    radius: 0,
                    maxRadius: Math.max(window.innerWidth, window.innerHeight) * 0.6,
                    alpha: 1,
                    speed: 0.01,
                    rotation: Math.random() * Math.PI * 2,
                    frequency: freq,
                    startTime: Date.now(),
                    duration: 6
                };
            }
            
            // Add particles for visualization
            introParticles.push(createIntroParticle(440, '#ffffff'));
            introParticles.push(createIntroParticle(523.25, '#4f46e5'));
            introParticles.push(createIntroParticle(659.25, '#9333ea'));
            
            // Intro animation loop
            function animateIntro() {
                const width = introCanvas.width / dpr;
                const height = introCanvas.height / dpr;
                const centerX = width / 2;
                const centerY = height / 2;
                
                // Fade trail
                ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
                ctx.fillRect(0, 0, width, height);
                
                introRotation += 0.005; // Slower rotation for 6-second intro
                
                // Draw particles
                for (let i = introParticles.length - 1; i >= 0; i--) {
                    const p = introParticles[i];
                    if (!p) {
                        introParticles.splice(i, 1);
                        continue;
                    }
                    
                    // Update particle
                    const elapsed = (Date.now() - p.startTime) / 1000;
                    const progress = Math.min(elapsed / p.duration, 1);
                    p.radius = p.maxRadius * progress * 0.8;
                    p.alpha = 1 - progress * 0.5;
                    
                    if (progress >= 1) {
                        introParticles.splice(i, 1);
                        continue;
                    }
                    
                    const age = progress;
                    const pulse = Math.sin(age * Math.PI * 4 + introRotation * 2) * 0.5 + 0.5;
                    
                    // Draw cymatic pattern
                    ctx.save();
                    ctx.translate(centerX, centerY);
                    ctx.globalCompositeOperation = 'screen';
                    
                    const freq = p.frequency || 440;
                    const baseFreq = 220;
                    const freqRatio = freq / baseFreq;
                    const patternScale = Math.min(width, height) * 0.4;
                    
                    // Draw mandala pattern (reduced brightness for better text readability)
                    const numRings = 5;
                    for (let ring = 0; ring < numRings; ring++) {
                        const ringRadius = p.radius * (0.2 + ring * 0.15);
                        const ringAlpha = p.alpha * (1 - ring * 0.15) * (0.4 + pulse * 0.3); // Reduced brightness
                        
                        const gradient = ctx.createRadialGradient(0, 0, ringRadius * 0.7, 0, 0, ringRadius * 1.3);
                        gradient.addColorStop(0, p.color + Math.floor(ringAlpha * 200).toString(16).padStart(2, '0'));
                        gradient.addColorStop(0.5, p.color + Math.floor(ringAlpha * 120).toString(16).padStart(2, '0'));
                        gradient.addColorStop(1, 'transparent');
                        
                        ctx.globalAlpha = ringAlpha;
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = (5 - ring * 0.8) * (1 + pulse * 0.3);
                        ctx.beginPath();
                        ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Add frequency-based pattern
                        const patternPoints = 8 + Math.floor(freqRatio);
                        for (let i = 0; i < patternPoints; i++) {
                            const angle = (i / patternPoints) * Math.PI * 2 + p.rotation + introRotation;
                            const patternRadius = ringRadius * (0.8 + Math.sin(freqRatio * i) * 0.2);
                            const x = Math.cos(angle) * patternRadius;
                            const y = Math.sin(angle) * patternRadius;
                            
                            ctx.globalAlpha = ringAlpha * 0.4; // Reduced opacity for better text readability
                            ctx.fillStyle = p.color + Math.floor(ringAlpha * 100).toString(16).padStart(2, '0'); // Darker
                            ctx.beginPath();
                            ctx.arc(x, y, 3 + pulse * 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    ctx.restore();
                }
                
                requestAnimationFrame(animateIntro);
            }
            
            animateIntro();
            
            // Text animation sequence (slower, spread over 6 seconds)
            setTimeout(() => {
                text1.style.opacity = '1';
                text1.style.transform = 'translateY(0)';
            }, 400);
            
            setTimeout(() => {
                text2.style.opacity = '1';
                text2.style.transform = 'translateY(0)';
            }, 1500);
            
            setTimeout(() => {
                text3.style.opacity = '1';
                text3.style.transform = 'translateY(0)';
            }, 2800);
            
            // Fade out and show app after 6 seconds
            setTimeout(() => {
                introOverlay.style.opacity = '0';
                app.style.opacity = '1';
                
                setTimeout(() => {
                    introOverlay.style.display = 'none';
                }, 800);
            }, 6000);
        })();
        
        const SvgKnob = {
            props: ['modelValue', 'min', 'max', 'step', 'unit'],
            emits: ['update:modelValue'],
            template: `<div class="knob mx-auto" 
                @mousedown="onPointerStart" 
                @touchstart="onPointerStart"
                ref="knobElement">
                <svg viewBox="0 0 60 60" class="w-full h-full"><circle cx="30" cy="30" r="25" fill="none" stroke="#444" stroke-width="4"/>
                <line x1="30" y1="30" x2="30" y2="8" stroke="#fff" stroke-width="3" stroke-linecap="round" :transform="\`rotate(\${angle} 30 30)\`"/></svg>
                <div class="text-white text-xs text-center mt-1">{{ displayValue }}{{ unit }}</div>
            </div>`,
            setup(props, { emit }) {
                const knobElement = ref(null);
                
                const angle = computed(() => {
                    const normalized = (props.modelValue - props.min) / (props.max - props.min);
                    return normalized * 270 - 135;
                });
                const displayValue = computed(() => {
                    if (props.step < 1) return props.modelValue.toFixed(1);
                    return Math.round(props.modelValue);
                });
                
                let startY = 0;
                let startValue = 0;
                let isActive = false;
                
                const updateValue = (clientY) => {
                    const deltaY = startY - clientY;
                    const range = props.max - props.min;
                    const sensitivity = 100;
                    const newValue = startValue + (deltaY / sensitivity) * range;
                    const clamped = Math.max(props.min, Math.min(props.max, newValue));
                    const stepped = Math.round(clamped / props.step) * props.step;
                    
                    if (Math.abs(stepped - props.modelValue) > 0.001) {
                        emit('update:modelValue', stepped);
                    }
                };
                
                const onMove = (e) => {
                    if (!isActive) return;
                    e.preventDefault();
                    e.stopPropagation();
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    updateValue(clientY);
                };
                
                const onEnd = () => {
                    if (!isActive) return;
                    isActive = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                    document.removeEventListener('touchcancel', onEnd);
                };
                
                const onPointerStart = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    isActive = true;
                    
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    startY = clientY;
                    startValue = props.modelValue;
                    
                    if (e.touches) {
                        document.addEventListener('touchmove', onMove, { passive: false });
                        document.addEventListener('touchend', onEnd);
                        document.addEventListener('touchcancel', onEnd);
                    } else {
                        document.addEventListener('mousemove', onMove);
                        document.addEventListener('mouseup', onEnd);
                    }
                };
                
                return { angle, displayValue, onPointerStart, knobElement };
            }
        };

        createApp({
            components: { SvgKnob },
            setup() {
                const canvas = ref(null); const ctx = ref(null); const isPlaying = ref(false);
                const showPresetMenu = ref(false);
                // Check URL parameter to determine if slave (before isSlave is defined)
                const urlParamsCheck = new URLSearchParams(window.location.search);
                const isSlaveCheck = urlParamsCheck.get('slave') === 'true';
                const showControls = ref(!isSlaveCheck); // Always true for master (menu always visible)
                const qrCanvas = ref(null);
                const qrCanvasFullscreen = ref(null);
                const showQRCode = ref(false); // Show/hide QR code in fullscreen
                const isFullscreen = ref(false); // Track fullscreen state
                const showSleepPreventionTip = ref(false); // Show sleep prevention tip
                let isPageVisible = true; // Track page visibility for rendering throttling
                
                const audioReady = ref(false);
                
                // Detect iOS device
                const isIOSDevice = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                                   (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                
                // Function to show iOS Settings instructions
                // Note: Web apps cannot directly open iOS Settings due to security restrictions
                const openIOSSettings = () => {
                    // Show clear instructions since we can't open Settings directly
                    const instructions = `To prevent your iPhone from sleeping:

1. Press the Home button (or swipe up) to exit this app
2. Open the Settings app
3. Go to Display & Brightness
4. Tap Auto-Lock
5. Select Never
6. Return to this app

ðŸ’¡ Remember to change it back after your session to save battery!`;
                    
                    alert(instructions);
                };
                
                // Method to open menu
                const openMenu = (e) => {
                    debugLog('openMenu called, event:', e);
                    debugLog('current showControls:', showControls.value);
                    debugLog('current isSlave:', isSlave);
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    showControls.value = true;
                    debugLog('showControls set to:', showControls.value);
                };
                
                // Method to close menu
                const closeMenu = (e) => {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    debugLog('closeMenu called, current showControls:', showControls.value);
                    showControls.value = false;
                    debugLog('showControls set to:', showControls.value);
                };
                
                // Method to toggle menu (for backwards compatibility)
                const toggleMenu = (e) => {
                    if (showControls.value) {
                        closeMenu(e);
                    } else {
                        openMenu(e);
                    }
                };
                const settings = reactive({ noteLength: 5, pauseLength: 5, masterVolume: 70, vizMode: 'rotate', numGenerators: 3, masterMuted: false, masterIncluded: true, referencePitch: 440 });
                const masterAssignedNotes = ref([]); // Notes assigned to master
                const masterCurrentlyPlayingNote = ref(null); // Currently playing note on master
                const masterVolume = ref(100); // Master volume when included (separate from masterVolume setting)
                const masterSliderRef = ref(null); // Ref to master slider element
                const totalSlaves = ref(0); // Track total number of connected slaves (for master)
                const connectedSlaves = reactive([]); // Track individual slaves with their IDs, names, and volumes
                const slaveName = ref(null); // Slave's own name (for slave devices)
                const slaveVolume = ref(100); // Per-slave volume (for slave devices, default 100%)
                const slaveCurrentlyPlayingNote = ref(null); // Currently playing note on slave (for animation)
                
                // Computed property to display slaves including master when included
                // Note: We don't include masterVolume.value in the computed to avoid re-renders when slider moves
                const displaySlaves = computed(() => {
                    const slaves = [...connectedSlaves];
                    if (settings.masterIncluded) {
                        slaves.unshift({
                            id: 'master',
                            name: 'Master',
                            volume: 100, // Placeholder - actual value comes from masterVolume.value directly
                            assignedNotes: masterAssignedNotes.value,
                            currentlyPlayingNote: masterCurrentlyPlayingNote.value
                        });
                    }
                    return slaves;
                });
                
                // Debounce timers for slave volume updates (per slave)
                const slaveVolumeTimeouts = {};
                
                // Helper function to get display volume for a slave
                const getSlaveDisplayVolume = (slave) => {
                    if (slave.id === 'master') {
                        const vol = masterVolume.value;
                        return (vol !== null && vol !== undefined && !isNaN(vol)) ? Math.round(vol) : 100;
                    }
                    const vol = slave.volume;
                    return (vol !== null && vol !== undefined && !isNaN(vol)) ? Math.round(vol) : 100;
                };
                
                // Helper function to check if a color is dark
                const isDarkColor = (color) => {
                    const darkColors = ['#1e3a8a', '#4f46e5', '#9333ea'];
                    return darkColors.includes(color.toLowerCase());
                };
                
                // Helper function to get playing note style
                const getPlayingNoteStyle = (note, isPlaying) => {
                    if (!isPlaying) {
                        return {
                            backgroundColor: note.color + '40',
                            color: note.color,
                            border: '1px solid ' + note.color + '80',
                            boxSizing: 'border-box'
                        };
                    }
                    
                    // For playing notes, use white background with colored text for dark colors
                    // Keep border width the same (1px) to prevent size change, use box-shadow for emphasis
                    // Note: boxShadow glow is handled by CSS animation (.note-playing class)
                    if (isDarkColor(note.color)) {
                        return {
                            backgroundColor: '#ffffff',
                            color: note.color,
                            border: '1px solid ' + note.color,
                            boxSizing: 'border-box',
                            transition: 'all 0.2s ease-out'
                        };
                    } else {
                        return {
                            backgroundColor: note.color,
                            color: '#ffffff',
                            border: '1px solid ' + note.color,
                            boxSizing: 'border-box',
                            transition: 'all 0.2s ease-out'
                        };
                    }
                };
                
                // Track previous master volume for scaling calculations
                let previousMasterVolume = masterVolume.value;
                let masterVolumeLocked = false; // Lock to prevent resets
                let masterHighlightVersion = 0;
                let slaveHighlightVersion = 0;
                
                // Watch masterVolume to detect unauthorized resets
                watch(masterVolume, (newVal, oldVal) => {
                    if (masterVolumeLocked && oldVal !== undefined && newVal === 100 && oldVal !== 100) {
                        console.warn(`âš ï¸ Master volume was reset to 100! Old value: ${oldVal}, preventing reset...`);
                        masterVolume.value = oldVal; // Restore old value
                        return;
                    }
                });
                
                // Function to update slave volume
                const updateSlaveVolume = (slaveId, volume) => {
                    // Handle master flake volume separately (when master is included as a flake)
                    if (slaveId === 'master') {
                        masterVolumeLocked = true; // Lock to prevent resets
                        
                        // Update volume immediately in the UI to prevent slider jumping (same pattern as slave sliders)
                        masterVolume.value = volume;
                        
                        const oldVolume = previousMasterVolume;
                        previousMasterVolume = volume; // Update tracked value
                        
                        console.log(`Master flake volume updated: ${oldVolume}% â†’ ${volume}%`);
                        
                        // Update volume of currently playing master notes in real-time
                        // Only do this if audio is actually playing and volume changed
                        if (!isSlave && settings.masterIncluded && audioContext && audioContext.state === 'running' && oldVolume !== volume && isPlaying.value) {
                            const now = audioContext.currentTime;
                            const scaleFactor = oldVolume > 0 ? volume / oldVolume : volume / 100; // Scale factor based on volume change
                            
                            // Update all active oscillators for master
                            activeOscillators.forEach(osc => {
                                if (osc._oscGain && osc._startTime && osc._duration) {
                                    // Calculate current time in note's timeline
                                    const elapsed = now - osc._startTime;
                                    const remaining = osc._duration - elapsed;
                                    
                                    if (remaining > 0 && elapsed >= 0) {
                                        // Get current gain value
                                        osc._oscGain.gain.cancelScheduledValues(now);
                                        const currentGain = osc._oscGain.gain.value;
                                        
                                        // Scale gain by the volume change factor
                                        const newGain = Math.max(0, Math.min(0.5, currentGain * scaleFactor));
                                        
                                        // Apply new gain smoothly
                                        osc._oscGain.gain.setTargetAtTime(newGain, now, 0.05);
                                        console.log(`Updated master oscillator gain: ${currentGain.toFixed(4)} â†’ ${newGain.toFixed(4)} (scale: ${scaleFactor.toFixed(2)})`);
                                    }
                                }
                            });
                        }
                        
                        // Note: This doesn't affect settings.masterVolume - it's a separate control
                        // The master flake volume is applied in playNote when master is included
                        return;
                    }
                    
                    if (!slaveId || !ws.value || ws.value.readyState !== WebSocket.OPEN) {
                        return;
                    }
                    
                    const slave = connectedSlaves.find(s => s.id === slaveId);
                    if (!slave) {
                        return;
                    }
                    
                    // Update volume immediately in the UI to prevent slider jumping
                    slave.volume = volume;
                    
                    // Clear any pending update
                    if (slaveVolumeTimeouts[slaveId]) {
                        clearTimeout(slaveVolumeTimeouts[slaveId]);
                    }
                    
                    // Debounce slider updates to prevent rapid sends
                    slaveVolumeTimeouts[slaveId] = setTimeout(() => {
                        try {
                            ws.value.send(JSON.stringify({
                                type: 'slave_volume',
                                slaveId: String(slaveId),
                                volume: parseInt(volume)
                            }));
                            
                            // DON'T call sendPresetToSlaves() here - it causes conflicts
                            // The volume update is immediate, preset update happens separately
                        } catch (e) {
                            console.error('Error sending volume update:', e);
                        }
                        
                        delete slaveVolumeTimeouts[slaveId];
                    }, 150);
                };
                const noteData = reactive([
                    { note: 'G3', freq: 196.00, color: '#1e3a8a', volume: 80, enabled: true, centsOffset: 0 },
                    { note: 'Bb3', freq: 233.08, color: '#4f46e5', volume: 75, enabled: true, centsOffset: 0 },
                    { note: 'C4', freq: 261.63, color: '#9333ea', volume: 75, enabled: true, centsOffset: 0 },
                    { note: 'Eb4', freq: 311.13, color: '#ec4899', volume: 70, enabled: true, centsOffset: 0 },
                    { note: 'F4', freq: 349.23, color: '#ef4444', volume: 70, enabled: true, centsOffset: 0 },
                    { note: 'G4', freq: 392.00, color: '#f97316', volume: 65, enabled: true, centsOffset: 0 },
                    { note: 'Bb4', freq: 466.16, color: '#f59e0b', volume: 65, enabled: true, centsOffset: 0 },
                    { note: 'C5', freq: 523.25, color: '#10b981', volume: 60, enabled: true, centsOffset: 0 },
                    { note: 'D5', freq: 587.33, color: '#06b6d4', volume: 60, enabled: true, centsOffset: 0 }
                ]);
                
                const currentPaletteName = ref('Default');
                const showPaletteEditor = ref(false);
                const showAdvancedSettings = ref(false); // Start in simple mode (hide advanced settings by default)
                const showAddNoteInput = ref(false);
                const newNoteName = ref('');
                const newNoteFreq = ref(null);
                
                const colors = ['#1e3a8a', '#4f46e5', '#9333ea', '#ec4899', '#ef4444', '#f97316', '#f59e0b', '#10b981', '#06b6d4', '#3b82f6', '#8b5cf6', '#ec4899'];
                
                let audioContext = null; let masterGain = null;
                const activeOscillators = new Set(); 
                const generatorTimeouts = reactive([]);
                const generatorNoteEndTimes = reactive([]); // Track when each generator's current note ends (for overlap prevention)
                const generatorNextNoteTimes = reactive([]); // Track when each generator's next note should start (noteEnd + pause)
                const generatorOscillators = reactive([]); // Track oscillators per generator (array of Sets)
                let lastNoteEndTime = 0; // Track when the last note ended globally (for overlap prevention across all generators)
                let lastNextNoteTime = 0; // Track when the next note should start globally (noteEnd + pause)
                let isNotePlaying = false; // Lock to prevent multiple notes from starting simultaneously when overlap is off
                const particles = reactive([]); let rotation = 0;
                let droneOscillator = null; // Continuous inaudible drone to keep audio context active
                let droneGain = null; // Gain node for the drone (for smooth fade-out)
                let wakeLock = null; // Screen wake lock to prevent device sleep
                let wakeLockRetryInterval = null; // Interval to retry wake lock if released
                
                // Function to request fullscreen mode (helps prevent sleep on some devices)
                // This requires user interaction, so we'll call it from a button click
                // iOS Safari has limited fullscreen support, but we'll try multiple methods
                const requestFullscreenMode = async () => {
                    try {
                        const element = document.documentElement;
                        let success = false;
                        
                        // Try standard fullscreen API first
                        if (element.requestFullscreen) {
                            try {
                                await element.requestFullscreen();
                                success = true;
                            } catch (e) {
                                console.log('Standard fullscreen failed:', e.message);
                            }
                        }
                        
                        // Try webkit fullscreen (iOS Safari)
                        if (!success && element.webkitRequestFullscreen) {
                            try {
                                await element.webkitRequestFullscreen();
                                success = true;
                            } catch (e) {
                                console.log('Webkit fullscreen failed:', e.message);
                            }
                        }
                        
                        // Try webkitEnterFullscreen (older iOS)
                        if (!success && element.webkitEnterFullscreen) {
                            try {
                                element.webkitEnterFullscreen();
                                success = true;
                            } catch (e) {
                                console.log('WebkitEnterFullscreen failed:', e.message);
                            }
                        }
                        
                        // iOS Safari doesn't support fullscreen API for web pages
                        // But we can still activate wake lock and keep-alive mechanisms
                        // Check if iOS (iPhone specifically)
                        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                                     (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                        const isIPhone = /iPhone/.test(navigator.userAgent);
                        
                        if (isIOS && !success) {
                            console.log('âš ï¸ iOS detected - fullscreen API not supported, but activating keep-alive mechanisms...');
                            
                            // On iOS, fullscreen doesn't work, but we can activate all keep-alive mechanisms:
                            // 1. Ensure wake lock is active
                            requestWakeLock();
                            
                            // 2. Ensure keep-alive video is playing (critical for iOS)
                            if (typeof createKeepAliveVideo === 'function') {
                                const video = createKeepAliveVideo();
                                if (video) {
                                    video.play().catch(() => {
                                        // If play fails, recreate video
                                        if (video.parentNode) {
                                            video.remove();
                                        }
                                        createKeepAliveVideo();
                                    });
                                } else {
                                    createKeepAliveVideo();
                                }
                            }
                            
                            // 3. Ensure drone note is running
                            if (audioContext && audioContext.state === 'running' && !droneOscillator) {
                                startDroneNote();
                                if (typeof enhanceDroneForIOS === 'function') {
                                    setTimeout(() => enhanceDroneForIOS(), 100);
                                }
                            }
                            
                            // 4. For iPhone specifically, show visual feedback that keep-alive is active
                            if (isIPhone) {
                                // Update button to show it's "active" even though not in fullscreen
                                // We'll use a different visual state
                                console.log('âœ“ iPhone keep-alive mechanisms activated (fullscreen not available on iOS Safari)');
                                // Show a brief visual feedback
                                const button = document.getElementById('fullscreen-button');
                                if (button) {
                                    button.classList.add('bg-green-500');
                                    setTimeout(() => {
                                        button.classList.remove('bg-green-500');
                                    }, 2000);
                                }
                            }
                            
                            // Note: We don't set success = true because fullscreen didn't actually activate
                            // But all keep-alive mechanisms are now active to help prevent sleep
                        }
                        
                        // Try moz/ms fallbacks
                        if (!success && element.mozRequestFullScreen) {
                            try {
                                await element.mozRequestFullScreen();
                                success = true;
                            } catch (e) {
                                console.log('Moz fullscreen failed:', e.message);
                            }
                        }
                        
                        if (!success && element.msRequestFullscreen) {
                            try {
                                await element.msRequestFullscreen();
                                success = true;
                            } catch (e) {
                                console.log('MS fullscreen failed:', e.message);
                            }
                        }
                        
                        if (success) {
                            console.log('âœ“ Fullscreen mode activated (helps prevent sleep)');
                        } else {
                            console.log('âš ï¸ Fullscreen not available on this device/browser');
                            // If fullscreen fails, at least try to keep wake lock active
                            requestWakeLock();
                        }
                        return success;
                    } catch (e) {
                        console.log('Fullscreen error:', e.message);
                        // If fullscreen fails, at least try to keep wake lock active
                        requestWakeLock();
                        return false;
                    }
                };
                
                // Function to exit fullscreen
                const exitFullscreenMode = async () => {
                    try {
                        let exited = false;
                        
                        // Check current fullscreen state
                        const isCurrentlyFullscreen = !!(
                            document.fullscreenElement || 
                            document.webkitFullscreenElement || 
                            document.mozFullScreenElement ||
                            document.msFullscreenElement
                        );
                        
                        if (!isCurrentlyFullscreen) {
                            console.log('Not in fullscreen mode');
                            // Update state anyway
                            isFullscreen.value = false;
                            return;
                        }
                        
                        // Try standard exitFullscreen
                        if (document.exitFullscreen) {
                            try {
                                await document.exitFullscreen();
                                exited = true;
                                console.log('âœ“ Exited fullscreen (standard API)');
                            } catch (e) {
                                console.log('Standard exitFullscreen failed:', e.message);
                            }
                        }
                        
                        // Try webkit exitFullscreen (iOS Safari)
                        if (!exited && document.webkitExitFullscreen) {
                            try {
                                await document.webkitExitFullscreen();
                                exited = true;
                                console.log('âœ“ Exited fullscreen (webkit API)');
                            } catch (e) {
                                console.log('Webkit exitFullscreen failed:', e.message);
                            }
                        }
                        
                        // Try webkit cancelFullScreen (alternative iOS method)
                        if (!exited && document.webkitCancelFullScreen) {
                            try {
                                await document.webkitCancelFullScreen();
                                exited = true;
                                console.log('âœ“ Exited fullscreen (webkitCancelFullScreen)');
                            } catch (e) {
                                console.log('Webkit cancelFullScreen failed:', e.message);
                            }
                        }
                        
                        // Try moz exitFullscreen
                        if (!exited && document.mozCancelFullScreen) {
                            try {
                                await document.mozCancelFullScreen();
                                exited = true;
                                console.log('âœ“ Exited fullscreen (moz API)');
                            } catch (e) {
                                console.log('Moz exitFullscreen failed:', e.message);
                            }
                        }
                        
                        // Try ms exitFullscreen
                        if (!exited && document.msExitFullscreen) {
                            try {
                                await document.msExitFullscreen();
                                exited = true;
                                console.log('âœ“ Exited fullscreen (ms API)');
                            } catch (e) {
                                console.log('MS exitFullscreen failed:', e.message);
                            }
                        }
                        
                        // For iOS video fullscreen, try to exit by removing video or calling exitFullscreen on video
                        if (!exited) {
                            const fullscreenVideo = document.querySelector('video[style*="z-index: 9999"]');
                            if (fullscreenVideo) {
                                try {
                                    // Try to exit video fullscreen
                                    if (fullscreenVideo.webkitExitFullscreen) {
                                        fullscreenVideo.webkitExitFullscreen();
                                    }
                                    fullscreenVideo.remove();
                                    exited = true;
                                    console.log('âœ“ Removed fullscreen video element');
                                } catch (e) {
                                    console.log('Video exit failed:', e.message);
                                }
                            }
                        }
                        
                        // Force update state
                        isFullscreen.value = false;
                        
                        if (exited) {
                            console.log('âœ“ Exited fullscreen mode');
                        } else {
                            console.log('âš ï¸ Could not exit fullscreen - user may need to use device controls');
                            // On iOS, sometimes user needs to use device controls
                            // But we'll still update our state
                            isFullscreen.value = false;
                        }
                    } catch (e) {
                        console.log('Exit fullscreen error:', e.message);
                        // Force update state even on error
                        isFullscreen.value = false;
                    }
                };
                
                // Track fullscreen state changes
                const updateFullscreenState = () => {
                    isFullscreen.value = !!(
                        document.fullscreenElement || 
                        document.webkitFullscreenElement || 
                        document.mozFullScreenElement ||
                        document.msFullscreenElement ||
                        document.querySelector('video[style*="z-index: 9999"]')
                    );
                };
                
                document.addEventListener('fullscreenchange', updateFullscreenState);
                document.addEventListener('webkitfullscreenchange', updateFullscreenState);
                document.addEventListener('webkitendfullscreen', updateFullscreenState); // iOS specific
                document.addEventListener('mozfullscreenchange', updateFullscreenState);
                document.addEventListener('MSFullscreenChange', updateFullscreenState);
                
                // Also check periodically for iOS (sometimes events don't fire)
                setInterval(() => {
                    if (isFullscreen.value) {
                        const actuallyFullscreen = !!(
                            document.fullscreenElement || 
                            document.webkitFullscreenElement || 
                            document.mozFullScreenElement ||
                            document.msFullscreenElement
                        );
                        if (!actuallyFullscreen) {
                            isFullscreen.value = false;
                        }
                    }
                }, 1000);
                
                // Function to request/re-request wake lock to prevent device sleep
                let wakeLockLogCount = 0; // Track wake lock log frequency
                let wakeLockReleaseHandler = null; // Store handler to avoid duplicates
                const requestWakeLock = async () => {
                    if ('wakeLock' in navigator) {
                        try {
                            // Release existing lock if any
                            if (wakeLock) {
                                // Remove old event listener if it exists
                                if (wakeLockReleaseHandler) {
                                    wakeLock.removeEventListener('release', wakeLockReleaseHandler);
                                    wakeLockReleaseHandler = null;
                                }
                                await wakeLock.release();
                                wakeLock = null;
                            }
                            
                            // Request new wake lock
                            wakeLock = await navigator.wakeLock.request('screen');
                            // Disable logging to reduce console spam - wake lock is working silently
                            wakeLockLogCount++;
                            
                            // Create release handler only once
                            if (!wakeLockReleaseHandler) {
                                wakeLockReleaseHandler = () => {
                                    // Disable logging - wake lock is working silently
                                    wakeLockLogCount++;
                                    // Re-request if still playing
                                    if (isPlaying.value) {
                                        setTimeout(() => requestWakeLock(), 100);
                                    }
                                };
                                wakeLock.addEventListener('release', wakeLockReleaseHandler);
                            }
                        } catch (e) {
                            // Only log errors, not every attempt
                            if (wakeLockLogCount === 0) {
                                console.log('Wake lock not available:', e.message);
                            }
                            wakeLockLogCount++;
                            // iOS doesn't support wake lock API, but we'll keep trying
                            // The drone note and audio playback help keep device awake
                        }
                    } else {
                        // Only log once
                        if (wakeLockLogCount === 0) {
                            console.log('Wake Lock API not supported (e.g., iOS Safari)');
                        }
                        wakeLockLogCount++;
                        // iOS doesn't support wake lock, but continuous audio helps
                    }
                };
                
                const initAudio = async () => {
                    console.log('initAudio called, audioContext exists:', !!audioContext);
                    if (!audioContext) {
                        try {
                            console.log('Creating new audio context...');
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        masterGain = audioContext.createGain();
                            masterGain.gain.value = settings.masterMuted ? 0 : settings.masterVolume / 100;
                        masterGain.connect(audioContext.destination);
                            console.log('Audio context created, state:', audioContext.state);
                        } catch (e) {
                            console.error('Failed to create audio context:', e);
                            throw e;
                        }
                    }
                    console.log('Audio context state before resume check:', audioContext.state);
                    if (audioContext.state === 'suspended') {
                        try {
                            console.log('Attempting to resume audio context...');
                            // Add timeout to prevent hanging on iOS
                            const resumePromise = audioContext.resume();
                            const timeoutPromise = new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('Resume timeout')), 1000)
                            );
                            await Promise.race([resumePromise, timeoutPromise]);
                            console.log('Audio context resumed, state:', audioContext.state);
                        } catch (e) {
                            // Resume failed or timed out - this is expected without user interaction
                            // Don't throw, just log and let the caller handle it
                            console.log('Audio context resume failed/timed out (user interaction required):', e.message);
                            // Return the context anyway - it's created but suspended
                        }
                    }
                    // Ensure master gain is set (respect mute setting)
                    if (masterGain) {
                        const effectiveVolume = settings.masterMuted ? 0 : settings.masterVolume / 100;
                        masterGain.gain.value = effectiveVolume;
                        console.log('Master gain set to:', effectiveVolume);
                    }
                    console.log('initAudio returning, audioContext state:', audioContext?.state);
                    return audioContext;
                };
                
                // Setup MediaSession API for better background audio support on mobile
                // This helps iOS/Android recognize the app as playing audio and may keep it alive longer
                const setupMediaSession = () => {
                    if ('mediaSession' in navigator) {
                        try {
                            navigator.mediaSession.metadata = new MediaMetadata({
                                title: 'Soundflakes',
                                artist: 'Generative Sound',
                                album: 'Live Performance'
                            });
                            
                            // Set up action handlers
                            navigator.mediaSession.setActionHandler('play', () => {
                                if (!isPlaying.value && audioContext) {
                                    audioContext.resume().then(() => {
                                        togglePlayback();
                                    });
                                }
                            });
                            
                            navigator.mediaSession.setActionHandler('pause', () => {
                                if (isPlaying.value) {
                                    togglePlayback();
                                }
                            });
                            
                            // Update playback state
                            navigator.mediaSession.playbackState = isPlaying.value ? 'playing' : 'paused';
                            
                            console.log('âœ“ MediaSession API configured for background audio support');
                        } catch (e) {
                            console.log('MediaSession API not fully supported:', e.message);
                        }
                    }
                };
                
                // Update MediaSession playback state
                const updateMediaSessionState = () => {
                    if ('mediaSession' in navigator) {
                        try {
                            navigator.mediaSession.playbackState = isPlaying.value ? 'playing' : 'paused';
                        } catch (e) {
                            // Ignore errors
                        }
                    }
                };
                
                // Start continuous inaudible drone note (4 Hz, very quiet) to keep audio context active
                // This prevents iOS Safari from suspending audio and keeps devices awake
                // Works for both master and slaves
                const startDroneNote = () => {
                    if (droneOscillator) {
                        console.log('Drone note already running');
                        return; // Already started
                    }
                    if (!audioContext || !masterGain) {
                        console.log('Cannot start drone note - audio context not ready');
                        return;
                    }
                    if (audioContext.state !== 'running') {
                        console.log('Cannot start drone note - audio context not running');
                        return;
                    }
                    
                    try {
                        console.log('ðŸŽµ Starting inaudible drone note (18 Hz) to keep audio context active...');
                        droneOscillator = audioContext.createOscillator();
                        droneGain = audioContext.createGain();
                        
                        // 18 Hz frequency (just below human hearing range of ~20 Hz)
                        // iOS respects this frequency more for keeping device awake
                        droneOscillator.frequency.value = 18;
                        droneOscillator.type = 'sine';
                        
                        // Reduced intensity - still inaudible but more "active" for iOS
                        // 0.00025 is half the previous value, still completely inaudible
                        droneGain.gain.value = 0.00025;
                        
                        // Connect: oscillator -> gain -> masterGain -> destination
                        droneOscillator.connect(droneGain);
                        droneGain.connect(masterGain);
                        
                        // Start and let it run continuously
                        droneOscillator.start();
                        console.log('âœ“ Drone note started - audio context will stay active');
                        
                        // Create visual particle for drone (small pulsing living entity)
                        const droneParticle = {
                            color: '#ffffff', // White for drone
                            radius: Math.max(window.innerWidth, window.innerHeight) * 0.08, // Small base size
                            maxRadius: Math.max(window.innerWidth, window.innerHeight) * 0.08,
                            alpha: 0.6, // Base alpha
                            rotation: 0,
                            frequency: 18, // Drone frequency for pattern calculation
                            isDrone: true, // Mark as drone particle
                            pulsePhase: 0 // Track pulse phase for breathing animation
                        };
                        particles.push(droneParticle);
                        cachedDroneParticle = droneParticle; // Update cache
                        
                        // Keep drone particle alive by updating it periodically
                        const updateDroneVisual = () => {
                            if (droneOscillator && particles.length > 0) {
                                const droneP = cachedDroneParticle || particles.find(p => p.isDrone);
                                if (droneP) {
                                    cachedDroneParticle = droneP; // Update cache
                                    // Pulse phase is updated in the animate loop for smooth animation
                                    // Just ensure it exists
                                    if (!droneP.pulsePhase) droneP.pulsePhase = 0;
                                }
                            }
                        };
                        const droneVisualInterval = setInterval(() => {
                            if (!droneOscillator) {
                                clearInterval(droneVisualInterval);
                                // Remove drone particle
                                const index = particles.findIndex(p => p.isDrone);
                                if (index >= 0) {
                                    particles.splice(index, 1);
                                    cachedDroneParticle = null;
                                }
                            } else {
                                updateDroneVisual();
                            }
                        }, 50); // Update every 50ms
                        
                        // Monitor audio context state and restart drone if suspended
                        const monitorInterval = setInterval(() => {
                            if (!audioContext || !droneOscillator) {
                                clearInterval(monitorInterval);
                                return;
                            }
                            if (audioContext.state === 'suspended') {
                                console.log('âš ï¸ Audio context suspended, attempting to resume...');
                                audioContext.resume().then(() => {
                                    console.log('âœ“ Audio context resumed');
                                }).catch(e => {
                                    console.log('Could not resume audio context:', e.message);
                                });
                            }
                        }, 5000);
                    } catch (e) {
                        console.error('Failed to start drone note:', e);
                        droneOscillator = null;
                    }
                };
                
                // Stop drone note smoothly (if needed) - prevents audio clicks/pops
                const stopDroneNote = () => {
                    if (droneOscillator && droneGain && audioContext) {
                        try {
                            // Remove drone particle visual
                            const droneParticleIndex = particles.findIndex(p => p.isDrone);
                            if (droneParticleIndex >= 0) {
                                particles.splice(droneParticleIndex, 1);
                                cachedDroneParticle = null;
                            }
                            
                            // Smoothly fade out the drone gain to prevent clicks
                            const now = audioContext.currentTime;
                            const fadeTime = 0.05; // 50ms fade out (very quick but smooth)
                            
                            // Fade out the gain node smoothly
                            droneGain.gain.cancelScheduledValues(now);
                            droneGain.gain.setValueAtTime(droneGain.gain.value, now);
                            droneGain.gain.linearRampToValueAtTime(0, now + fadeTime);
                            
                            // Stop oscillator after fade completes
                            droneOscillator.stop(now + fadeTime + 0.01);
                            
                            // Clean up after fade
                            setTimeout(() => {
                                try {
                                    if (droneOscillator) {
                                        droneOscillator.disconnect();
                                    }
                                    if (droneGain) {
                                        droneGain.disconnect();
                                    }
                                } catch (e) {
                                    // Ignore disconnect errors
                                }
                                droneOscillator = null;
                                droneGain = null;
                            }, (fadeTime + 0.01) * 1000);
                            
                            console.log('Drone note stopped smoothly');
                        } catch (e) {
                            console.error('Error stopping drone note:', e);
                            // Fallback: just stop it immediately
                            try {
                                if (droneOscillator) {
                                    droneOscillator.stop();
                                    droneOscillator.disconnect();
                                }
                                if (droneGain) {
                                    droneGain.disconnect();
                                }
                            } catch (e2) {
                                // Ignore
                            }
                            droneOscillator = null;
                            droneGain = null;
                        }
                    } else if (droneOscillator) {
                        // Fallback if audio context is gone
                        try {
                            droneOscillator.stop();
                            droneOscillator.disconnect();
                            if (droneGain) {
                                droneGain.disconnect();
                            }
                        } catch (e) {
                            // Ignore
                        }
                        droneOscillator = null;
                        droneGain = null;
                    }
                };
                
                const playNote = (freq, volume, color, durationOverride = null, noteName = null, generatorId = null) => {
                    debugLog('playNote called:', { freq, volume, color, isSlave, durationOverride, noteName, generatorId });
                    let highlightTimeoutMs = 0;
                    
                    // Track currently playing note so UI can highlight it
                    let highlightVersion = null;
                    const highlightIsSlave = isSlave;
                    
                    if (!isSlave && settings.masterIncluded && noteName) {
                        masterHighlightVersion += 1;
                        highlightVersion = masterHighlightVersion;
                        masterCurrentlyPlayingNote.value = noteName;
                    }
                    
                    if (isSlave && noteName) {
                        slaveHighlightVersion += 1;
                        highlightVersion = slaveHighlightVersion;
                        slaveCurrentlyPlayingNote.value = noteName;
                    }
                    
                    // Master never shows visuals - only slaves do
                    if (!isSlave) {
                        // If master is not included, don't play sound
                        if (!settings.masterIncluded) {
                            console.log('Master not included - skipping sound');
                            return;
                        }
                        // Master is included but no visuals - continue to play sound only
                    } else {
                        // Slaves: Always create particles for visuals FIRST
                        // This ensures visuals work even if audio isn't ready
                        // Store frequency for cymatic mandala visualization
                        const duration = durationOverride !== null ? durationOverride : (settings.noteLength + (Math.random() * 4 - 2));
                        const particle = {
                            color,
                            radius: 0,
                            maxRadius: Math.max(window.innerWidth, window.innerHeight) * 0.6,
                            alpha: 1,
                            speed: 0.01,
                            rotation: Math.random() * Math.PI * 2,
                            frequency: freq, // Store frequency for cymatic patterns
                            noteName: noteName, // Store note name for reference
                            duration: duration, // Store note duration
                            startTime: Date.now() // Track when particle was created
                        };
                        particles.push(particle);
                        debugLog('Particle created with frequency:', freq, 'Hz for note:', noteName, 'duration:', duration, 's');
                    }
                    
                    // Check if we should play sound
                    if (!masterGain || !audioContext) {
                        debugLog('playNote: audio context or masterGain not ready, visuals only');
                        debugLog('masterGain:', !!masterGain, 'audioContext:', !!audioContext);
                        return;
                    }
                    
                    // If master is muted, don't play sound (but visuals already created above)
                    if (!isSlave && settings.masterMuted) {
                        debugLog('Master muted - visuals only, no sound');
                        return;
                    }
                    
                    const now = audioContext.currentTime;
                    // Use provided duration or calculate with randomness: Â±2 seconds variation from the set noteLength
                    const duration = durationOverride !== null ? durationOverride : (settings.noteLength + (Math.random() * 4 - 2)); // Random between noteLength-2 and noteLength+2
                    
                    // Ensure minimum duration of 0.5 seconds to prevent very short notes
                    const finalDuration = Math.max(0.5, duration);
                    
                    debugLog('playNote: durationOverride=', durationOverride, 'calculated duration=', duration, 'finalDuration=', finalDuration);
                    
                    // Apply master flake volume when master is included (separate from master volume knob)
                    let effectiveVolume = volume / 100;
                    if (!isSlave && settings.masterIncluded) {
                        // When master is included as a flake, multiply by master flake volume
                        effectiveVolume = effectiveVolume * (masterVolume.value / 100);
                    }
                    
                    // Get current sound preset
                    const currentPreset = synthPresets.find(p => p.name === currentPresetName.value) || synthPresets[0];
                    const useWarmSynth = currentPreset.type === 'warm';
                    
                    if (noteName) {
                        const releaseTail = useWarmSynth ? Math.max(currentPreset.release || 0, 0) : 0.25;
                        const randomVariation = Math.random() * 1.2; // up to +1.2s extra for longer notes
                        const highlightExtraTail = useWarmSynth ? 2 : 0.4;
                        const highlightDurationSeconds = finalDuration + releaseTail + highlightExtraTail + randomVariation;
                        highlightTimeoutMs = Math.max(highlightDurationSeconds * 1000, (finalDuration + 0.1) * 1000);
                    }
                    
                    const scheduleHighlightClear = () => {
                        if (!noteName || highlightTimeoutMs <= 0 || highlightVersion === null) {
                            return;
                        }
                        setTimeout(() => {
                            if (!highlightIsSlave) {
                                if (!settings.masterIncluded) {
                                    return;
                                }
                                if (masterHighlightVersion === highlightVersion && masterCurrentlyPlayingNote.value === noteName) {
                                    masterCurrentlyPlayingNote.value = null;
                                }
                            } else {
                                if (slaveHighlightVersion === highlightVersion && slaveCurrentlyPlayingNote.value === noteName) {
                                    slaveCurrentlyPlayingNote.value = null;
                                }
                            }
                        }, highlightTimeoutMs);
                    };
                    
                    // Debug logging for sound preset usage
                    if (isSlave) {
                        debugLog('ðŸŽµ Slave playNote - currentPresetName:', currentPresetName.value, 'preset type:', currentPreset.type, 'useWarmSynth:', useWarmSynth);
                    }
                    
                    if (useWarmSynth) {
                        // Use warm synth engine for organic, meditative sounds
                        debugLog('ðŸŽ¹ Using warm synth engine for preset:', currentPresetName.value);
                        // Increase volume for all sounds except Original Sine
                        // Original Sine uses 0.15 multiplier (line 1758), other sounds use higher multiplier
                        const velocity = effectiveVolume * 0.6; // Increased from 0.3 to 0.6 for louder non-sine sounds
                        const voice = new WarmSynthVoice(audioContext, currentPreset, freq, velocity, finalDuration, masterGain);
                        
                        // Store voice for tracking (compatible with oscillator structure)
                        const voiceTracker = {
                            _isWarmSynthVoice: true,
                            _startTime: now,
                            _duration: finalDuration,
                            _oscGain: null,
                            _noteGain: null,
                            noteName: noteName,
                            voice: voice,
                            stop: () => voice.stop(),
                            release: () => voice.release()
                        };
                        
                        // Track active voice
                        activeOscillators.add(voiceTracker);
                        if (generatorId !== null && generatorId !== undefined) {
                            if (!generatorOscillators[generatorId]) {
                                generatorOscillators[generatorId] = new Set();
                            }
                            const placeholder = Array.from(generatorOscillators[generatorId]).find(item => item._isPlaceholder);
                            if (placeholder) {
                                generatorOscillators[generatorId].delete(placeholder);
                            }
                            generatorOscillators[generatorId].add(voiceTracker);
                        }
                        
                        // Cleanup on end
                        setTimeout(() => {
                            activeOscillators.delete(voiceTracker);
                            if (generatorId !== null && generatorId !== undefined && generatorOscillators[generatorId]) {
                                generatorOscillators[generatorId].delete(voiceTracker);
                                if (generatorOscillators[generatorId].size === 0) {
                                    generatorNoteEndTimes[generatorId] = null;
                                }
                            }
                        }, (finalDuration + (currentPreset.release || 1.5)) * 1000);
                        
                        scheduleHighlightClear();
                        return;
                    }
                    
                    // Simple clean sine wave - no detuning, no filters (for Original Sine and Pure Tone)
                    const osc = audioContext.createOscillator();
                    const oscGain = audioContext.createGain();
                    const noteGain = audioContext.createGain();
                    
                    // Pure sine wave
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    
                    // Simple smooth envelope - fade-out completes BEFORE oscillator stops to prevent clicks
                    const fadeOutTime = 0.15; // Fade out over 150ms for smooth stop
                    // Calculate when fade-out should start (ensuring minimum sustain time)
                    const fadeStartTime = Math.max(now + 0.2, now + finalDuration - fadeOutTime);
                    const fadeEndTime = now + finalDuration - 0.01; // Fade completes 10ms before stop
                    
                    oscGain.gain.setValueAtTime(0, now);
                    oscGain.gain.linearRampToValueAtTime(effectiveVolume * 0.15, now + 0.1); // Lower gain for Original Sine to match other sounds
                    // Hold full volume until fade starts
                    oscGain.gain.setValueAtTime(effectiveVolume * 0.15, fadeStartTime);
                    // Fade out smoothly
                    oscGain.gain.linearRampToValueAtTime(0, fadeEndTime);
                    
                    // For both slaves and master, noteGain should be 1.0
                    // Volume is controlled entirely by masterGain to prevent conflicts
                    noteGain.gain.value = 1.0;
                    
                    // Simple connection: oscillator -> gain -> master
                    osc.connect(oscGain);
                    oscGain.connect(noteGain);
                    noteGain.connect(masterGain);
                    
                    // Store gain nodes with oscillator for smooth fade-out on stop
                    osc._oscGain = oscGain;
                    osc._noteGain = noteGain;
                    osc._startTime = now;
                    osc._duration = finalDuration;
                    osc.noteName = noteName; // Store note name so we can update frequency when reference pitch changes
                    
                    // Track active oscillator globally
                    activeOscillators.add(osc);
                    // Track oscillator per generator (for per-generator overlap prevention)
                    if (generatorId !== null && generatorId !== undefined) {
                        if (!generatorOscillators[generatorId]) {
                            generatorOscillators[generatorId] = new Set();
                        }
                        // Remove placeholder if it exists
                        const placeholder = Array.from(generatorOscillators[generatorId]).find(item => item._isPlaceholder);
                        if (placeholder) {
                            generatorOscillators[generatorId].delete(placeholder);
                        }
                        // Add actual oscillator
                        generatorOscillators[generatorId].add(osc);
                        debugLog('Generator', generatorId, ': added oscillator, total active:', generatorOscillators[generatorId].size);
                    }
                    osc.onended = () => {
                        // Clean up when oscillator finishes naturally
                        activeOscillators.delete(osc);
                        // Clean up per-generator tracking
                        if (generatorId !== null && generatorId !== undefined) {
                            if (generatorOscillators[generatorId]) {
                                generatorOscillators[generatorId].delete(osc);
                                const remaining = generatorOscillators[generatorId].size;
                                // Clear note end time when oscillator ends (only if no oscillators remain)
                                if (remaining === 0) {
                                    generatorNoteEndTimes[generatorId] = null;
                                    debugLog('Generator', generatorId, ': oscillator ended, cleared note end time, remaining:', remaining);
                                } else {
                                    debugLog('Generator', generatorId, ': oscillator ended, remaining:', remaining);
                                }
                            }
                        }
                        // Disconnect gain nodes after a small delay to ensure fade-out completes
                        setTimeout(() => {
                            try {
                                if (osc._oscGain) osc._oscGain.disconnect();
                                if (osc._noteGain) osc._noteGain.disconnect();
                            } catch (e) {
                                // Already disconnected, ignore
                            }
                        }, 50);
                    };
                    
                    osc.start(now);
                    const stopTime = now + finalDuration;
                    osc.stop(stopTime); // Oscillator stops after full duration
                    debugLog('playNote:');
                    debugLog('  Generator:', generatorId);
                    debugLog('  Frequency:', freq, 'Hz');
                    debugLog('  Started at:', now.toFixed(3), 's');
                    debugLog('  Will stop at:', stopTime.toFixed(3), 's');
                    debugLog('  Duration:', finalDuration.toFixed(3), 's');
                    debugLog('  Fade starts at:', fadeStartTime.toFixed(3), 's');
                    debugLog('  Fade ends at:', fadeEndTime.toFixed(3), 's');
                    
                    scheduleHighlightClear();
                    // Particles are already created earlier for slaves (line 1508)
                    // This duplicate creation has been removed to prevent multiple particles per note
                };
                
                const scheduleNextNote = (generatorId) => {
                    // If master is not included, don't schedule notes
                    if (!settings.masterIncluded) {
                        console.log('Master not included - skipping note scheduling');
                        return;
                    }
                    
                    if (!isPlaying.value) {
                        console.log('Not playing, stopping generator', generatorId);
                        return;
                    }
                    if (!audioContext || !masterGain) {
                        console.error('Audio context not ready in scheduleNextNote');
                        return;
                    }
                    
                    // Always prevent overlap - check if ANY note is still playing
                    const now = audioContext.currentTime;
                    
                    // First check if any oscillators are actively playing
                    if (activeOscillators.size > 0) {
                        // A note is definitely playing, wait
                        const timeout = setTimeout(() => scheduleNextNote(generatorId), 100);
                        generatorTimeouts[generatorId] = timeout;
                        return;
                    }
                    
                    // Check the lock - if a note is starting, wait
                    if (isNotePlaying) {
                        const timeout = setTimeout(() => scheduleNextNote(generatorId), 50);
                        generatorTimeouts[generatorId] = timeout;
                        return;
                    }
                    
                    // Find the latest note end time and next note start time across all generators
                    let latestEndTime = lastNoteEndTime;
                    generatorNoteEndTimes.forEach(endTime => {
                        if (endTime && endTime > latestEndTime) {
                            latestEndTime = endTime;
                        }
                    });
                    
                    // Also check when the next note should start (including pause)
                    let earliestNextNoteTime = lastNextNoteTime;
                    generatorNextNoteTimes.forEach(nextTime => {
                        if (nextTime && nextTime > earliestNextNoteTime) {
                            earliestNextNoteTime = nextTime;
                        }
                    });
                    
                    // Wait until both the note ends AND the pause completes
                    const mustWaitUntil = Math.max(latestEndTime, earliestNextNoteTime);
                    
                    if (now < mustWaitUntil) {
                        // A note is still playing or pause hasn't completed, wait until it's safe to start
                        const waitTime = Math.max(50, (mustWaitUntil - now) * 1000); // Minimum 50ms
                        console.log('Generator', generatorId, ': Waiting', waitTime.toFixed(0), 'ms (note ends at', latestEndTime.toFixed(3), 's, next note starts at', earliestNextNoteTime.toFixed(3), 's, must wait until', mustWaitUntil.toFixed(3), 's, now:', now.toFixed(3), 's)');
                        const timeout = setTimeout(() => scheduleNextNote(generatorId), waitTime);
                        generatorTimeouts[generatorId] = timeout;
                        return;
                    }
                    
                    // Set lock to prevent other generators from starting simultaneously
                    isNotePlaying = true;
                    
                    // Use assigned notes if available (master mode), otherwise use all enabled notes
                    const notesToPlay = masterAssignedNotes.value.length > 0 
                        ? masterAssignedNotes.value 
                        : noteData.filter(n => n.enabled);
                    
                    if (notesToPlay.length === 0) {
                        const timeout = setTimeout(() => scheduleNextNote(generatorId), settings.pauseLength * 1000);
                        generatorTimeouts[generatorId] = timeout;
                        return;
                    }
                    const note = notesToPlay[Math.floor(Math.random() * notesToPlay.length)];
                    
                    // Calculate note duration FIRST (with randomness: Â±2 seconds)
                    // Random between noteLength-2 and noteLength+2, but ensure minimum 0.1 seconds
                    const baseDuration = settings.noteLength + (Math.random() * 4 - 2); // Random between noteLength-2 and noteLength+2
                    const noteDuration = Math.max(0.1, baseDuration); // Ensure minimum 0.1 seconds
                    
                    // Get current preset to account for release time
                    const currentPreset = synthPresets.find(p => p.name === currentPresetName.value) || synthPresets[0];
                    // For warm synth voices, use preset release time (fade-out happens AFTER note duration)
                    // For simple sine, fade-out happens WITHIN note duration, so no extra time needed
                    const releaseTime = (currentPreset.type === 'warm' && currentPreset.release) ? currentPreset.release : 0; // Only add release time for warm synth voices
                    
                    // CRITICAL: Get audio context time RIGHT BEFORE playing
                    // This ensures accurate timing calculation
                    const noteStartTime = audioContext.currentTime;
                    // Note end time: for warm synth, includes release phase; for simple sine, fade-out is already included in duration
                    const noteEndTime = noteStartTime + noteDuration + releaseTime;
                    generatorNoteEndTimes[generatorId] = noteEndTime;
                    // Update global last note end time
                    if (noteEndTime > lastNoteEndTime) {
                        lastNoteEndTime = noteEndTime;
                    }
                    
                    console.log('Generator', generatorId, '(master): note starts at:', noteStartTime.toFixed(3), 's, will end at:', noteEndTime.toFixed(3), 's, duration:', noteDuration.toFixed(3), 's');
                    
                    // Release lock after a short delay to allow note to start
                    setTimeout(() => {
                        isNotePlaying = false;
                    }, 100);
                    
                    // Pass the calculated duration and generatorId to playNote so it uses the same value
                    playNote(note.freq, note.volume, note.color, noteDuration, note.note, generatorId);
                    
                    // Calculate pause delay (with randomness: Â±2 seconds, minimum 0.1 seconds)
                    const basePauseDuration = settings.pauseLength + (Math.random() * 4 - 2); // Random between pauseLength-2 and pauseLength+2 seconds
                    const pauseDuration = Math.max(0.1, basePauseDuration); // Ensure minimum 0.1 seconds to prevent notes from jumping
                    
                    // CRITICAL: The pause starts AFTER the note ends, not after it starts
                    // So the next note should start at: noteEndTime + pauseDuration
                    const nextNoteStartTime = noteEndTime + pauseDuration;
                    
                    // Track when this generator's next note should start (for overlap prevention)
                    generatorNextNoteTimes[generatorId] = nextNoteStartTime;
                    if (nextNoteStartTime > lastNextNoteTime) {
                        lastNextNoteTime = nextNoteStartTime;
                    }
                    
                    // Get current audio context time RIGHT NOW for accurate delay calculation
                    const nowForScheduling = audioContext.currentTime;
                    
                    // Calculate delay in milliseconds from NOW until next note should start
                    const delayUntilNextNote = (nextNoteStartTime - nowForScheduling) * 1000;
                    
                    console.log('Generator', generatorId, '(master) scheduling next note:');
                    console.log('  Note duration:', noteDuration.toFixed(3), 's');
                    console.log('  Pause duration:', pauseDuration.toFixed(3), 's');
                    console.log('  Note started at:', noteStartTime.toFixed(3), 's');
                    console.log('  Note ends at:', noteEndTime.toFixed(3), 's');
                    console.log('  Pause ends at:', nextNoteStartTime.toFixed(3), 's (noteEnd + pause)');
                    console.log('  Current time (now):', nowForScheduling.toFixed(3), 's');
                    console.log('  Delay until next:', delayUntilNextNote.toFixed(0), 'ms');
                    console.log('  Time until note ends:', ((noteEndTime - nowForScheduling) * 1000).toFixed(0), 'ms');
                    console.log('  Time until pause ends:', ((nextNoteStartTime - nowForScheduling) * 1000).toFixed(0), 'ms');
                    
                    // Ensure delay is at least 50ms to prevent immediate scheduling
                    const finalDelay = Math.max(50, delayUntilNextNote);
                    if (finalDelay < delayUntilNextNote - 10) {
                        console.warn('Generator', generatorId, '(master): WARNING - delay was clamped from', delayUntilNextNote.toFixed(0), 'ms to', finalDelay, 'ms');
                    }
                    if (finalDelay < (pauseDuration * 1000) - 100) {
                        console.error('Generator', generatorId, '(master): ERROR - delay (', finalDelay, 'ms) is shorter than pause duration (', (pauseDuration * 1000).toFixed(0), 'ms)!');
                    }
                    const timeout = setTimeout(() => scheduleNextNote(generatorId), finalDelay);
                    generatorTimeouts[generatorId] = timeout;
                };
                
                const startAllGenerators = () => {
                    // If master is not included, don't start generators
                    if (!settings.masterIncluded) {
                        console.log('Master not included - skipping generator start');
                        return;
                    }
                    
                    if (!audioContext || !masterGain) {
                        console.error('Cannot start generators: audio context not ready');
                        return;
                    }
                    // Clear any existing timeouts
                    generatorTimeouts.forEach(timeout => {
                        if (timeout) clearTimeout(timeout);
                    });
                    generatorTimeouts.length = 0;
                    generatorNoteEndTimes.length = 0;
                    lastNoteEndTime = 0;
                    isNotePlaying = false;
                    
                    // Use assigned notes if available (master mode), otherwise use all enabled notes
                    const notesToPlay = masterAssignedNotes.value.length > 0 
                        ? masterAssignedNotes.value 
                        : noteData.filter(n => n.enabled);
                    
                    if (notesToPlay.length === 0) {
                        console.warn('No notes to play');
                        return;
                    }
                    
                    console.log('Master starting playback with', notesToPlay.length, 'assigned notes');
                    
                    // Start multiple generators
                    const numGenerators = Math.min(settings.numGenerators, notesToPlay.length);
                    for (let i = 0; i < numGenerators; i++) {
                        // Start all generators at the same time (they'll queue to prevent overlap)
                        const startDelay = 0;
                        const timeout = setTimeout(() => {
                            scheduleNextNote(i);
                        }, startDelay);
                        generatorTimeouts[i] = timeout;
                    }
                };
                
                const togglePlayback = async () => {
                    if (!isPlaying.value) {
                        try {
                            await initAudio();
                            console.log('Audio initialized, state:', audioContext ? audioContext.state : 'null');
                            if (!audioContext || !masterGain) {
                                console.error('Audio context or master gain not initialized');
                                alert('Audio initialization failed. Please check console.');
                                return;
                            }
                        isPlaying.value = true;
                            // Setup MediaSession for background audio support
                            setupMediaSession();
                            updateMediaSessionState();
                            
                            // Request wake lock when playback starts (to prevent device sleep)
                            requestWakeLock();
                            
                            // For iOS: Create and start keep-alive video immediately
                            // This must be done in the master context, so check if createKeepAliveVideo exists
                            setTimeout(() => {
                                // Try to access createKeepAliveVideo if it exists in slave context
                                if (typeof window.createKeepAliveVideo === 'function') {
                                    const video = window.createKeepAliveVideo();
                                    if (video) {
                                        video.play().catch(() => {});
                                    }
                                }
                            }, 100);
                            
                            // Start drone note for both master and slaves to keep audio context active
                            if (audioContext && audioContext.state === 'running') {
                                startDroneNote();
                            }
                            if (isSlave) {
                                startSlavePlayback();
                            } else {
                                // If master is included, treat it as a slave (use assigned notes with slave playback logic)
                                if (settings.masterIncluded && masterAssignedNotes.value.length > 0) {
                                    console.log('Master included: using slave playback logic with', masterAssignedNotes.value.length, 'assigned notes');
                                    // Temporarily set assignedNotes to masterAssignedNotes for slave playback
                                    const originalAssignedNotes = assignedNotes.value;
                                    assignedNotes.value = masterAssignedNotes.value.map(n => ({
                                        note: n.note,
                                        freq: n.freq,
                                        volume: n.volume,
                                        color: n.color
                                    }));
                                    startSlavePlayback();
                                    // Restore original assignedNotes (slave playback will use its own copy)
                                    assignedNotes.value = originalAssignedNotes;
                                } else if (settings.masterIncluded) {
                                    // Master is included but no assigned notes yet, use all enabled notes
                                    startAllGenerators();
                                } else {
                                    // Master not included - stop any running generators
                                    console.log('Master not included - stopping generators');
                                    generatorTimeouts.forEach(timeout => {
                                        if (timeout) clearTimeout(timeout);
                                    });
                                    generatorTimeouts.length = 0;
                                    generatorNoteEndTimes.length = 0;
                                    lastNoteEndTime = 0;
                                    isNotePlaying = false;
                                }
                                // Notify slaves to start - send preset first, then play command
                                if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                    console.log('Master: Sending preset to slaves...');
                                    sendPresetToSlaves();
                                    // Small delay to ensure preset is sent first
                                    setTimeout(() => {
                                        if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                            console.log('Master: Sending play command to slaves...');
                                            ws.value.send(JSON.stringify({ type: 'play' }));
                                        } else {
                                            console.warn('Master: WebSocket not open when trying to send play command');
                                        }
                                    }, 200);
                                } else {
                                    console.warn('WebSocket not connected, cannot notify slaves');
                                }
                            }
                        } catch (e) {
                            console.error('Error starting playback:', e);
                            alert('Error starting playback: ' + e.message);
                        }
                    } else {
                        // Graceful stop: smoothly fade out all active notes to prevent clicks
                        isPlaying.value = false;
                        
                        // Update MediaSession state
                        updateMediaSessionState();
                        
                        // Release wake lock when stopping (to save battery)
                        if (wakeLock) {
                            try {
                                wakeLock.release();
                                wakeLock = null;
                                console.log('Wake lock released (playback stopped)');
                            } catch (e) {
                                console.log('Error releasing wake lock:', e);
                            }
                        }
                        // Clear all scheduled timeouts to prevent new notes
                        generatorTimeouts.forEach(timeout => {
                            if (timeout) clearTimeout(timeout);
                        });
                        generatorTimeouts.length = 0;
                        generatorNoteEndTimes.length = 0;
                        
                        // Smoothly fade out all currently playing oscillators
                        if (audioContext && activeOscillators.size > 0) {
                            const now = audioContext.currentTime;
                            const fadeOutDuration = 0.2; // 200ms fade-out for smooth stop
                            
                            activeOscillators.forEach(osc => {
                                try {
                                    // Calculate when this oscillator was supposed to stop naturally
                                    const naturalStopTime = osc._startTime + osc._duration;
                                    const timeUntilNaturalStop = naturalStopTime - now;
                                    
                                    // Only fade out if it would stop later than our fade-out duration
                                    // If it's already almost done, let it finish naturally
                                    if (timeUntilNaturalStop > fadeOutDuration) {
                                        // Fade out the gain node smoothly
                                        if (osc._oscGain) {
                                            const currentGain = osc._oscGain.gain.value;
                                            osc._oscGain.gain.cancelScheduledValues(now);
                                            osc._oscGain.gain.setValueAtTime(currentGain, now);
                                            osc._oscGain.gain.linearRampToValueAtTime(0, now + fadeOutDuration);
                                        }
                                        
                                        // Stop oscillator after fade completes
                                        const stopTime = now + fadeOutDuration + 0.01;
                                        osc.stop(stopTime);
                                    } else {
                                        // Already almost done, just ensure smooth fade-out
                                        if (osc._oscGain && timeUntilNaturalStop > 0.01) {
                                            const currentGain = osc._oscGain.gain.value;
                                            osc._oscGain.gain.cancelScheduledValues(now);
                                            osc._oscGain.gain.setValueAtTime(currentGain, now);
                                            osc._oscGain.gain.linearRampToValueAtTime(0, naturalStopTime);
                                        }
                                    }
                                } catch (e) {
                                    console.error('Error fading out oscillator:', e);
                                    // Fallback: let it finish naturally
                                }
                            });
                        }
                        
                        // Clear the set after fade-out completes
                        setTimeout(() => {
                            activeOscillators.clear();
                        }, 300); // Wait for fade-out to complete
                        
                        // Keep drone note running even when stopped (for both master and slaves)
                        // This ensures audio context stays active
                        if (audioContext && audioContext.state === 'running' && !droneOscillator) {
                            startDroneNote();
                        }
                        
                        // Notify slaves to stop gracefully
                        if (!isSlave && ws.value && ws.value.readyState === WebSocket.OPEN) {
                            ws.value.send(JSON.stringify({ type: 'stop' }));
                        }
                    }
                };
                
                // Fractal drawing functions
                const drawFractalCircle = (ctx, x, y, radius, depth, maxDepth, color, alpha, rotation) => {
                    if (depth > maxDepth || radius < 2) return; // Increased min radius for performance
                    
                    const currentAlpha = alpha * (1 - depth / maxDepth) * 0.6;
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(rotation);
                    
                    // Draw circle with reduced center brightness
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                    gradient.addColorStop(0, color + Math.floor(currentAlpha * 150).toString(16).padStart(2, '0'));
                    gradient.addColorStop(0.5, color + Math.floor(currentAlpha * 80).toString(16).padStart(2, '0'));
                    gradient.addColorStop(0.7, color + Math.floor(currentAlpha * 50).toString(16).padStart(2, '0'));
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = color + Math.floor(currentAlpha * 120).toString(16).padStart(2, '0');
                    ctx.lineWidth = 2 * (1 - depth / maxDepth);
                    ctx.stroke();
                    
                    // Recursive circles - reduced count for performance
                    if (depth < maxDepth) {
                        const childCount = 4; // Reduced from 6
                        const childRadius = radius * 0.4;
                        const childDistance = radius * 0.6;
                        
                        for (let i = 0; i < childCount; i++) {
                            const angle = (i / childCount) * Math.PI * 2 + rotation * 0.5;
                            const childX = Math.cos(angle) * childDistance;
                            const childY = Math.sin(angle) * childDistance;
                            drawFractalCircle(ctx, childX, childY, childRadius, depth + 1, maxDepth, color, currentAlpha, rotation * 1.2);
                        }
                    }
                    
                    ctx.restore();
                };
                
                const drawFractalTree = (ctx, x, y, length, angle, depth, maxDepth, color, alpha) => {
                    if (depth > maxDepth || length < 3) return; // Increased min length for performance
                    
                    const currentAlpha = alpha * (1 - depth / maxDepth * 0.7);
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle);
                    
                    // Draw branch
                    ctx.strokeStyle = color + Math.floor(currentAlpha * 255).toString(16).padStart(2, '0');
                    ctx.lineWidth = (maxDepth - depth) * 2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -length);
                    ctx.stroke();
                    
                    // Recursive branches - reduced recursion for performance
                    if (depth < maxDepth - 1) { // Stop one level earlier
                        const newX = 0;
                        const newY = -length;
                        const newLength = length * 0.7;
                        const branchAngle = Math.PI / 6;
                        
                        drawFractalTree(ctx, newX, newY, newLength, -branchAngle, depth + 1, maxDepth, color, currentAlpha);
                        drawFractalTree(ctx, newX, newY, newLength, branchAngle, depth + 1, maxDepth, color, currentAlpha);
                    }
                    
                    ctx.restore();
                };
                
                const drawFractalSpiral = (ctx, x, y, radius, turns, depth, maxDepth, color, alpha, rotation) => {
                    if (depth > maxDepth || radius < 1) return;
                    
                    const currentAlpha = alpha * (1 - depth / maxDepth);
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(rotation);
                    
                    ctx.strokeStyle = color + Math.floor(currentAlpha * 255).toString(16).padStart(2, '0');
                    ctx.lineWidth = (maxDepth - depth + 1) * 1.5;
                    ctx.beginPath();
                    
                    for (let t = 0; t < turns * Math.PI * 2; t += 0.1) {
                        const r = radius * (t / (turns * Math.PI * 2));
                        const px = Math.cos(t) * r;
                        const py = Math.sin(t) * r;
                        if (t === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                    
                    // Recursive spirals
                    const childRadius = radius * 0.5;
                    const childTurns = turns * 0.8;
                    const childCount = 4;
                    
                    for (let i = 0; i < childCount; i++) {
                        const angle = (i / childCount) * Math.PI * 2;
                        const childX = Math.cos(angle) * radius * 0.7;
                        const childY = Math.sin(angle) * radius * 0.7;
                        drawFractalSpiral(ctx, childX, childY, childRadius, childTurns, depth + 1, maxDepth, color, currentAlpha, rotation * 1.3);
                    }
                    
                    ctx.restore();
                };
                
                // Cache drone particle reference to avoid find() every frame
                let cachedDroneParticle = null;
                const TARGET_FPS = 30;
                let lastFrameTimestamp = 0;
                
                const animate = (timestamp = 0) => {
                    requestAnimationFrame(animate);
                    
                    const shouldRender = isSlave && isPageVisible && (isPlaying.value || particles.length > 0);
                    if (!shouldRender) {
                        return;
                    }
                    if (timestamp - lastFrameTimestamp < (1000 / TARGET_FPS)) {
                        return;
                    }
                    lastFrameTimestamp = timestamp;
                    
                    const c = canvas.value; const context = ctx.value;
                    if (!c || !context) {
                        return;
                    }
                    // Use actual canvas dimensions, not bounding rect
                    const width = c.width / (window.devicePixelRatio || 1);
                    const height = c.height / (window.devicePixelRatio || 1);
                    const centerX = width / 2;
                    const centerY = height / 2;
                    const maxDim = Math.max(width, height);
                    
                    // Beautiful fade trail effect
                    context.fillStyle = 'rgba(0, 0, 0, 0.06)';
                    context.fillRect(0, 0, width, height);
                    
                    rotation += 0.008;
                    
                    // Update cached drone particle reference if needed (only when particles change)
                    if (!cachedDroneParticle || !particles.includes(cachedDroneParticle)) {
                        cachedDroneParticle = particles.find(p => p && p.isDrone) || null;
                    }
                    
                    // Draw drone particle first (so it appears underneath other animations)
                    const droneParticle = cachedDroneParticle;
                    if (droneParticle) {
                        // Simple small glowing blurry orb that pulses with water ripples
                        context.save();
                        context.translate(centerX, centerY);
                        context.globalCompositeOperation = 'screen';
                        
                        // Update pulse phase for subtle pulsing
                        if (!droneParticle.pulsePhase) droneParticle.pulsePhase = 0;
                        droneParticle.pulsePhase += 0.02; // Slow pulse
                        
                        // Create subtle pulse
                        const pulse = Math.sin(droneParticle.pulsePhase) * 0.1 + 0.9; // Pulse between 0.9 and 1.0
                        
                        // Small orb size
                        const orbSize = Math.max(window.innerWidth, window.innerHeight) * 0.04 * pulse;
                        const baseAlpha = 0.4;
                        const pulseAlpha = baseAlpha * pulse;
                        
                        // Draw water ripples (contained within the orb)
                        const numRipples = 3;
                        for (let i = 0; i < numRipples; i++) {
                            const ripplePhase = droneParticle.pulsePhase * 0.5 + i * 0.8;
                            // Ripples stay within orb - start from center and expand inward from edge
                            const rippleRadius = orbSize * (0.3 + i * 0.2) + Math.sin(ripplePhase) * orbSize * 0.1;
                            const rippleAlpha = pulseAlpha * (0.2 - i * 0.05) * (0.5 + Math.sin(ripplePhase) * 0.5);
                            
                            if (rippleAlpha > 0 && rippleRadius < orbSize) {
                                context.globalAlpha = rippleAlpha;
                                context.strokeStyle = '#ffffff';
                                context.lineWidth = 1.5;
                                context.shadowBlur = 8;
                                context.shadowColor = '#ffffff';
                                context.filter = 'blur(3px)';
                                
                                context.beginPath();
                                context.arc(0, 0, rippleRadius, 0, Math.PI * 2);
                                context.stroke();
                            }
                        }
                        
                        // Create blurry glowing orb with radial gradient
                        const gradient = context.createRadialGradient(0, 0, 0, 0, 0, orbSize);
                        gradient.addColorStop(0, '#ffffff');
                        gradient.addColorStop(0.3, '#ffffff' + Math.floor(pulseAlpha * 200).toString(16).padStart(2, '0'));
                        gradient.addColorStop(0.6, '#ffffff' + Math.floor(pulseAlpha * 100).toString(16).padStart(2, '0'));
                        gradient.addColorStop(1, 'transparent');
                        
                        // Add blur effect
                        context.shadowBlur = 20;
                        context.shadowColor = '#ffffff';
                        context.filter = 'blur(8px)'; // Blurry effect
                        
                        context.globalAlpha = pulseAlpha;
                        context.fillStyle = gradient;
                        context.beginPath();
                        context.arc(0, 0, orbSize, 0, Math.PI * 2);
                        context.fill();
                        
                        // Reset effects
                        context.filter = 'none';
                        context.shadowBlur = 0;
                        context.restore();
                    }
                    
                    // Draw beautiful particle network (slaves only) - drawn on top of drone
                    // Optimize: cache particles length to avoid recalculation
                    const particlesLength = particles.length;
                    for (let i = particlesLength - 1; i >= 0; i--) {
                        const p = particles[i];
                        if (!p) {
                            particles.splice(i, 1);
                            if (p === cachedDroneParticle) cachedDroneParticle = null;
                            continue;
                        }
                        
                        // Skip drone particle - already drawn above
                        if (p.isDrone) {
                            continue;
                        }
                        
                        const age = 1 - p.alpha;
                        const pulse = Math.sin(age * Math.PI * 4 + rotation * 2) * 0.5 + 0.5;
                        
                        if (settings.vizMode === 'pulse') {
                            // Psychedelic fractal pulse mode
                            context.save();
                            context.globalCompositeOperation = 'screen';
                            
                            // Draw fractal circles at center (reduced intensity)
                            const fractalDepth = 2; // Reduced from 3
                            const fractalRadius = p.radius * (0.3 + pulse * 0.7);
                            drawFractalCircle(context, centerX, centerY, fractalRadius, 0, fractalDepth, p.color, p.alpha * 0.4, p.rotation + rotation);
                            
                            // Add expanding rings with fractal patterns - reduced count
                            for (let ring = 0; ring < 3; ring++) { // Reduced from 4
                                const ringRadius = p.radius + (ring * 20 * pulse);
                                const ringAlpha = p.alpha * (1 - ring * 0.2) * (0.5 + pulse * 0.3); // Reduced intensity
                                
                                // Radial gradient with reduced brightness
                                const gradient = context.createRadialGradient(
                                    centerX, centerY, ringRadius * 0.7,
                                    centerX, centerY, ringRadius * 1.3
                                );
                                gradient.addColorStop(0, p.color + Math.floor(ringAlpha * 180).toString(16).padStart(2, '0')); // Reduced from 255
                                gradient.addColorStop(0.5, p.color + Math.floor(ringAlpha * 100).toString(16).padStart(2, '0')); // Reduced from 120
                                gradient.addColorStop(1, 'transparent');
                                
                                context.globalAlpha = ringAlpha;
                                context.strokeStyle = gradient;
                                context.lineWidth = (4 - ring * 0.7) * (1 + pulse * 0.3); // Slightly thinner
                            context.beginPath();
                                context.arc(centerX, centerY, ringRadius, 0, Math.PI * 2);
                            context.stroke();
                                
                                // Add smaller fractal circles around the ring (reduced intensity)
                                if (ring > 0 && ringRadius > 50) {
                                    const smallCircleCount = 4; // Reduced from 6
                                    for (let i = 0; i < smallCircleCount; i++) {
                                        const angle = (i / smallCircleCount) * Math.PI * 2 + p.rotation + rotation;
                                        const smallX = centerX + Math.cos(angle) * ringRadius;
                                        const smallY = centerY + Math.sin(angle) * ringRadius;
                                        const smallRadius = ringRadius * 0.12;
                                        drawFractalCircle(context, smallX, smallY, smallRadius, 0, 1, p.color, ringAlpha * 0.4, angle); // Reduced depth from 2 to 1
                                    }
                                }
                            }
                            
                            context.restore();
                            
                            // Connect particles with flowing lines - disabled for performance
                            // Removed O(nÂ²) connection algorithm to improve performance
                            
                        } else {
                            // Cymatic Mandala Mode - accurate Chladni plate style patterns
                            context.save();
                            context.translate(centerX, centerY);
                            context.globalCompositeOperation = 'screen';
                            
                            // Get frequency and calculate pattern parameters
                            const freq = p.frequency || 440;
                            const baseFreq = 220; // C3 as base reference
                            const freqRatio = freq / baseFreq;
                            
                            // Calculate number of lobes/petals based on frequency
                            // Lower frequencies = fewer lobes, higher = more lobes
                            // Common patterns: 3, 4, 5, 6, 8, 10, 12 lobes
                            const numLobes = Math.max(3, Math.min(16, Math.round(3 + Math.sqrt(freqRatio) * 5)));
                            
                            // Calculate number of concentric rings based on frequency
                            const numRings = Math.max(2, Math.min(8, Math.round(2 + Math.log(freqRatio + 1) * 2)));
                            
                            const maxR = p.radius;
                            const lobeAngle = (Math.PI * 2) / numLobes;
                            
                            context.globalAlpha = p.alpha;
                            
                            // Draw concentric rings with soundwave ripples
                            // Increase number of rings for more ripple effect
                            const rippleRings = numRings * 2; // Double the rings for more ripples
                            
                            for (let ring = 0; ring < rippleRings; ring++) {
                                const ringRadius = (maxR * (ring + 1)) / (rippleRings + 1);
                                const ringAlpha = p.alpha * (1 - ring / rippleRings * 0.4) * 0.5; // Half intensity
                                
                                // Create soundwave ripple effect - alternating bright/dim rings
                                const ripplePhase = Math.sin((ring / rippleRings) * Math.PI * 4 + rotation * freqRatio * 0.2) * 0.5 + 0.5;
                                const rippleAlpha = ringAlpha * (0.3 + ripplePhase * 0.7); // Pulsing ripple effect
                                
                                // Draw the ring with lobe modulation and wave patterns
                                context.beginPath();
                                context.strokeStyle = p.color + Math.floor(rippleAlpha * 180).toString(16).padStart(2, '0');
                                context.lineWidth = (rippleRings - ring + 1) * 1.2 * p.alpha * 0.5; // Half intensity
                                context.globalAlpha = rippleAlpha;
                                
                                const pointsPerLobe = 40; // Higher resolution for smoother waves
                                const totalPoints = numLobes * pointsPerLobe;
                                
                                for (let i = 0; i <= totalPoints; i++) {
                                    const angle = (i / totalPoints) * Math.PI * 2 + p.rotation;
                                    
                                    // Calculate lobe modulation - creates the petal shape
                                    const lobeIndex = (angle / lobeAngle) % numLobes;
                                    const lobeProgress = (lobeIndex % 1);
                                    
                                    // Create smooth lobe shape using cosine
                                    const lobeModulation = Math.cos(lobeProgress * Math.PI * 2) * 0.15 + 1;
                                    
                                    // Add soundwave ripple effect - multiple frequencies
                                    const wave1 = Math.sin(angle * numLobes + rotation * freqRatio * 0.3) * 0.08;
                                    const wave2 = Math.sin(angle * numLobes * 2 + rotation * freqRatio * 0.5) * 0.04;
                                    const wave3 = Math.sin((ring / rippleRings) * Math.PI * 8 + rotation * 2) * 0.03;
                                    const waveMod = wave1 + wave2 + wave3;
                                    
                                    const r = ringRadius * lobeModulation * (1 + waveMod);
                                    const x = Math.cos(angle) * r;
                                    const y = Math.sin(angle) * r;
                                    
                                    if (i === 0) context.moveTo(x, y);
                                    else context.lineTo(x, y);
                                }
                                
                                context.closePath();
                                context.stroke();
                                
                                // Fill with subtle gradient (half intensity) - only for every other ring for ripple effect
                                if (ring % 2 === 0) {
                                    const gradient = context.createRadialGradient(0, 0, 0, 0, 0, ringRadius);
                                    gradient.addColorStop(0, p.color + Math.floor(rippleAlpha * 25).toString(16).padStart(2, '0'));
                                    gradient.addColorStop(0.7, p.color + Math.floor(rippleAlpha * 12).toString(16).padStart(2, '0'));
                                    gradient.addColorStop(1, 'transparent');
                                    context.fillStyle = gradient;
                                    context.fill();
                                }
                            }
                            
                            // Draw radial lines (nodal lines) creating the divisions (half intensity)
                            context.strokeStyle = p.color + Math.floor(p.alpha * 75).toString(16).padStart(2, '0'); // Half
                            context.lineWidth = 2 * p.alpha * 0.5; // Half intensity
                            context.globalAlpha = p.alpha * 0.35; // Half intensity
                            
                            for (let lobe = 0; lobe < numLobes; lobe++) {
                                const angle = (lobe / numLobes) * Math.PI * 2 + p.rotation + rotation * 0.02;
                                
                                // Draw main radial line
                                context.beginPath();
                                context.moveTo(0, 0);
                                context.lineTo(
                                    Math.cos(angle) * maxR * 0.95,
                                    Math.sin(angle) * maxR * 0.95
                                );
                                context.stroke();
                            }
                            
                            // Draw intersection points (antinodes) at ring intersections (half intensity)
                            context.fillStyle = p.color + Math.floor(p.alpha * 100).toString(16).padStart(2, '0'); // Half
                            context.globalAlpha = p.alpha * 0.4; // Half intensity
                            
                            for (let ring = 1; ring < numRings; ring++) {
                                const ringRadius = (maxR * (ring + 1)) / (numRings + 1);
                                
                                for (let lobe = 0; lobe < numLobes; lobe++) {
                                    // Position between radial lines (antinode position)
                                    const angle1 = (lobe / numLobes) * Math.PI * 2 + p.rotation;
                                    const angle2 = ((lobe + 1) / numLobes) * Math.PI * 2 + p.rotation;
                                    const antinodeAngle = (angle1 + angle2) / 2 + rotation * 0.03;
                                    
                                    const pointSize = maxR * 0.02 * (1 + Math.sin(rotation * 2 + ring + lobe) * 0.3);
                                    
                                    context.beginPath();
                                    context.arc(
                                        Math.cos(antinodeAngle) * ringRadius,
                                        Math.sin(antinodeAngle) * ringRadius,
                                        pointSize,
                                        0,
                                        Math.PI * 2
                                    );
                                    context.fill();
                                }
                            }
                            
                            // Draw bright central core (half intensity)
                            const coreRadius = maxR * 0.1;
                            const coreGradient = context.createRadialGradient(0, 0, 0, 0, 0, coreRadius);
                            coreGradient.addColorStop(0, p.color + Math.floor(p.alpha * 127).toString(16).padStart(2, '0')); // Half
                            coreGradient.addColorStop(0.5, p.color + Math.floor(p.alpha * 100).toString(16).padStart(2, '0')); // Half
                            coreGradient.addColorStop(1, 'transparent');
                            
                            context.fillStyle = coreGradient;
                            context.globalAlpha = p.alpha * 0.5; // Half intensity
                            context.beginPath();
                            context.arc(0, 0, coreRadius, 0, Math.PI * 2);
                            context.fill();
                            
                            // Draw radial lines from center matching number of lobes (half intensity)
                            context.strokeStyle = p.color + Math.floor(p.alpha * 110).toString(16).padStart(2, '0'); // Half
                            context.lineWidth = 2.5 * p.alpha * 0.5; // Half intensity
                            for (let lobe = 0; lobe < numLobes; lobe++) {
                                const angle = (lobe / numLobes) * Math.PI * 2 + p.rotation + rotation * 0.05;
                                context.beginPath();
                                context.moveTo(0, 0);
                                context.lineTo(
                                    Math.cos(angle) * coreRadius * 2,
                                    Math.sin(angle) * coreRadius * 2
                                );
                                context.stroke();
                            }
                            
                            context.restore();
                        }
                        
                        // Update particle with smooth easing
                        // Keep particle visible for the full note duration, then fade out completely
                        
                        // Skip drone particles (they have their own update logic)
                        if (p.isDrone) {
                            // Drone particles are handled separately
                            p.radius += p.maxRadius * p.speed;
                            continue;
                        }
                        
                        // Only process particles with proper timing data
                        // Remove old particles that don't have timing data
                        if (!p.startTime || !p.duration) {
                            // Old particle without timing data - remove it immediately
                            particles.splice(i, 1);
                            continue;
                        }
                        
                        const startTime = p.startTime;
                        const elapsed = (Date.now() - startTime) / 1000; // seconds
                        const duration = p.duration;
                        const progress = elapsed / duration;
                        
                        if (progress >= 1) {
                            // Note finished - fade out slowly and completely
                            // Calculate fade-out progress (0 to 1 over 3 seconds)
                            const fadeOutDuration = 3; // Fade out over 3 seconds (slower)
                            const fadeOutProgress = Math.min(1, (elapsed - duration) / fadeOutDuration);
                            p.alpha = Math.max(0, 1 - fadeOutProgress); // Fade from 1 to 0
                            
                            if (p.alpha <= 0) {
                                particles.splice(i, 1);
                                continue;
                            }
                        } else {
                            // Note still playing - keep alpha high, only slight fade
                            p.alpha = Math.max(0.95, 1 - progress * 0.05); // Stay at 95-100% alpha during note
                        }
                        
                        // Expand radius smoothly
                        p.radius += p.maxRadius * p.speed * 1.2;
                        p.rotation += 0.015 + Math.sin(rotation) * 0.005;
                    }
                    
                    // Background interference pattern removed - was causing unwanted dark rotating lines
                };
                requestAnimationFrame(animate);
                
                const savePreset = () => {
                    const preset = { name: prompt('Preset name:') || 'Untitled', settings: { ...settings }, notes: noteData.map(n => ({ ...n })) };
                    const presets = JSON.parse(localStorage.getItem('soundmarbles-presets') || '[]');
                    presets.push(preset);
                    localStorage.setItem('soundmarbles-presets', JSON.stringify(presets));
                };
                
                // Computed property for all presets (predefined + saved)
                const allPresets = computed(() => {
                    try {
                        const savedPresets = JSON.parse(localStorage.getItem('soundmarbles-presets') || '[]');
                        if (typeof predefinedPresets === 'undefined') {
                            return [];
                        }
                        return [...predefinedPresets, ...savedPresets];
                    } catch (error) {
                        console.error('Error loading presets:', error);
                        return typeof predefinedPresets !== 'undefined' ? [...predefinedPresets] : [];
                    }
                });
                
                const togglePresetMenu = () => {
                    showPresetMenu.value = !showPresetMenu.value;
                };
                
                const selectPreset = (presetIndex) => {
                    try {
                        const presets = allPresets.value;
                        if (presetIndex < 0 || presetIndex >= presets.length) {
                            console.error('Invalid preset index:', presetIndex);
                            return;
                        }
                        
                        const preset = presets[presetIndex];
                        console.log('Loading preset:', preset.name, 'index:', presetIndex);
                        
                        // Load the preset using loadNotePreset if it's a predefined preset
                        if (presetIndex < predefinedPresets.length) {
                            console.log('Loading predefined preset via loadNotePreset');
                            loadNotePreset(preset.name);
                        } else {
                            console.log('Loading saved preset manually');
                            // For saved presets, load manually
                            if (preset.settings) {
                    Object.assign(settings, preset.settings);
                            }
                            if (preset.soundPreset) {
                                currentPresetName.value = preset.soundPreset;
                                loadSynthPresetByName(preset.soundPreset);
                            }
                            if (preset.notes) {
                                noteData.splice(0, noteData.length);
                                preset.notes.forEach(note => {
                                    noteData.push({ ...note });
                                });
                            }
                            console.log('Loaded saved preset:', preset.name);
                        }
                        
                        // Close the menu
                        showPresetMenu.value = false;
                    } catch (error) {
                        console.error('Error loading preset:', error);
                        alert('Error loading preset: ' + error.message);
                    }
                };
                
                const loadPreset = () => {
                    togglePresetMenu();
                };
                
                // Sound Preset System
                const currentPresetName = ref('Original Sine');
                
                // Professional Sound Healing & Meditation Presets
                // Complete synthesized sound library - 20+ beautiful sounds for meditation and sound healing
                const synthPresets = [
                    // Pure Tones - Foundation for harmonic fields
                    { name: 'Original Sine', type: 'sine' },
                    
                    // Warm Ambient Pads (4 patches) - Triangle/sine for warmth, no sawtooth
                    { name: 'Soft Innato Pad', type: 'warm', osc1Type: 'triangle', osc2Type: 'triangle', detune1: 0.04, detune2: -0.04, attack: 1.8, decay: 3.5, sustain: 0.75, release: 4.5, filterCutoff: 2800, filterQ: 0.6, vibratoSpeed: 0, vibratoDepth: 0 },
                    { name: 'Ethereal Cloud', type: 'warm', osc1Type: 'triangle', osc2Type: 'sine', detune1: 0.05, detune2: -0.05, attack: 2.2, decay: 4.5, sustain: 0.8, release: 5.5, filterCutoff: 2600, filterQ: 0.5, vibratoSpeed: 0, vibratoDepth: 0 },
                    { name: 'Warm Embrace', type: 'warm', osc1Type: 'triangle', osc2Type: 'triangle', detune1: 0.03, detune2: -0.03, attack: 1.5, decay: 3.0, sustain: 0.85, release: 4.0, filterCutoff: 3000, filterQ: 0.7, vibratoSpeed: 0, vibratoDepth: 0 },
                    { name: 'Meditative Space', type: 'warm', osc1Type: 'triangle', osc2Type: 'sine', detune1: 0.04, detune2: -0.04, attack: 2.0, decay: 4.0, sustain: 0.78, release: 5.0, filterCutoff: 2700, filterQ: 0.6, vibratoSpeed: 0, vibratoDepth: 0 },
                    
                    // Flute-like Synth Voices (4 patches)
                    { name: 'Breath Flute', type: 'warm', osc1Type: 'triangle', detune1: 0, detune2: 0, attack: 0.15, decay: 0.2, sustain: 0.75, release: 1.2, filterCutoff: 3500, filterQ: 2.5, vibratoSpeed: 6, vibratoDepth: 2 },
                    { name: 'Warm Flute', type: 'warm', osc1Type: 'triangle', detune1: 0.005, detune2: -0.005, attack: 0.18, decay: 0.25, sustain: 0.7, release: 1.5, filterCutoff: 3200, filterQ: 2.2, vibratoSpeed: 5.5, vibratoDepth: 1.8 },
                    { name: 'Shakuhachi Flute', type: 'warm', osc1Type: 'sine', detune1: 0.004, detune2: -0.004, attack: 0.2, decay: 0.3, sustain: 0.65, release: 1.8, filterCutoff: 3000, filterQ: 2.0, vibratoSpeed: 7, vibratoDepth: 2.5 },
                    { name: 'Bamboo Flute', type: 'warm', osc1Type: 'triangle', detune1: 0.006, detune2: -0.006, attack: 0.16, decay: 0.22, sustain: 0.72, release: 1.3, filterCutoff: 3400, filterQ: 2.3, vibratoSpeed: 6.5, vibratoDepth: 2.2 },
                    
                    // Meditative Drones (4 patches)
                    { name: 'Deep Earth Drone', type: 'warm', osc1Type: 'sine', osc2Type: 'sine', detune1: 0, detune2: 0, attack: 2.5, decay: 1.5, sustain: 0.99, release: 6.0, filterCutoff: 1500, filterQ: 0.5, vibratoSpeed: 0, vibratoDepth: 0 },
                    { name: 'Expansive Sky', type: 'warm', osc1Type: 'sine', osc2Type: 'triangle', detune1: 0.01, detune2: -0.01, attack: 2.0, decay: 1.2, sustain: 0.98, release: 5.5, filterCutoff: 2500, filterQ: 0.6, vibratoSpeed: 0, vibratoDepth: 0 },
                    { name: 'Grounding Tone', type: 'warm', osc1Type: 'sine', osc2Type: 'sine', detune1: 0, detune2: 0, attack: 3.0, decay: 2.0, sustain: 0.99, release: 7.0, filterCutoff: 1200, filterQ: 0.4, vibratoSpeed: 0, vibratoDepth: 0 },
                    { name: 'Celestial Drone', type: 'warm', osc1Type: 'triangle', osc2Type: 'sine', detune1: 0.008, detune2: -0.008, attack: 1.8, decay: 1.0, sustain: 0.97, release: 5.0, filterCutoff: 2800, filterQ: 0.7, vibratoSpeed: 0, vibratoDepth: 0 },
                    
                    // Bowl / Bell-like Tones (4 patches)
                    { name: 'Crystal Bowl', type: 'warm', osc1Type: 'sine', osc2Type: 'sine', detune1: 0, detune2: 0, attack: 0.01, decay: 0.05, sustain: 0.4, release: 6.0, filterCutoff: 6000, filterQ: 4.0, vibratoSpeed: 0, vibratoDepth: 0 },
                    { name: 'Tibetan Singing Bowl', type: 'warm', osc1Type: 'sine', osc2Type: 'sine', detune1: 0, detune2: 0, attack: 0.02, decay: 0.08, sustain: 0.5, release: 7.0, filterCutoff: 4500, filterQ: 3.5, vibratoSpeed: 0, vibratoDepth: 0 },
                    { name: 'Temple Bell', type: 'warm', osc1Type: 'sine', osc2Type: 'sine', detune1: 0, detune2: 0, attack: 0.005, decay: 0.03, sustain: 0.35, release: 5.5, filterCutoff: 5500, filterQ: 3.8, vibratoSpeed: 0, vibratoDepth: 0 },
                    { name: 'Golden Gong', type: 'warm', osc1Type: 'sine', osc2Type: 'sine', detune1: 0, detune2: 0, attack: 0.03, decay: 0.1, sustain: 0.45, release: 8.0, filterCutoff: 3000, filterQ: 2.2, vibratoSpeed: 0, vibratoDepth: 0 },
                    
                    // Noise Beds / Nature-like (4 patches)
                    { name: 'Wind Breath', type: 'warm', osc1Type: 'noise', detune1: 0, detune2: 0, attack: 3.0, decay: 2.0, sustain: 0.8, release: 4.0, filterCutoff: 1500, filterQ: 1.0, vibratoSpeed: 0, vibratoDepth: 0 },
                    { name: 'Distant Water', type: 'warm', osc1Type: 'noise', detune1: 0, detune2: 0, attack: 2.5, decay: 1.8, sustain: 0.75, release: 3.5, filterCutoff: 2000, filterQ: 0.8, vibratoSpeed: 0, vibratoDepth: 0 },
                    { name: 'Gentle Air', type: 'warm', osc1Type: 'noise', detune1: 0, detune2: 0, attack: 4.0, decay: 3.0, sustain: 0.85, release: 5.0, filterCutoff: 1800, filterQ: 1.2, vibratoSpeed: 0, vibratoDepth: 0 },
                    { name: 'Soft Texture', type: 'warm', osc1Type: 'noise', detune1: 0, detune2: 0, attack: 3.5, decay: 2.5, sustain: 0.82, release: 4.5, filterCutoff: 2200, filterQ: 0.9, vibratoSpeed: 0, vibratoDepth: 0 },
                    
                    // Additional Beautiful Pads (4 more patches) - All triangle/sine for warmth
                    { name: 'Heavenly Pad', type: 'warm', osc1Type: 'triangle', osc2Type: 'sine', detune1: 0.03, detune2: -0.03, attack: 1.8, decay: 3.5, sustain: 0.8, release: 4.5, filterCutoff: 2900, filterQ: 0.6, vibratoSpeed: 0, vibratoDepth: 0 },
                    { name: 'Serene Pad', type: 'warm', osc1Type: 'triangle', osc2Type: 'triangle', detune1: 0.04, detune2: -0.04, attack: 1.6, decay: 3.2, sustain: 0.82, release: 4.2, filterCutoff: 2800, filterQ: 0.65, vibratoSpeed: 0, vibratoDepth: 0 },
                    { name: 'Peaceful Pad', type: 'warm', osc1Type: 'sine', osc2Type: 'triangle', detune1: 0.03, detune2: -0.03, attack: 1.9, decay: 3.8, sustain: 0.8, release: 4.8, filterCutoff: 2700, filterQ: 0.6, vibratoSpeed: 0, vibratoDepth: 0 },
                    { name: 'Healing Pad', type: 'warm', osc1Type: 'triangle', osc2Type: 'sine', detune1: 0.025, detune2: -0.025, attack: 1.5, decay: 3.0, sustain: 0.85, release: 4.0, filterCutoff: 3000, filterQ: 0.7, vibratoSpeed: 0, vibratoDepth: 0 }
                ];
                
                // ============================================================================
                // AMBIENT ENGINE - Professional Tone.js-based Synthesized Sound Library
                // ============================================================================
                // Expert sound design for meditation, sound healing, and deep listening
                // All sounds are 100% synthesized using Tone.js and Web Audio API
                // ============================================================================
                
                // Global Tone.js context initialization
                let toneInitialized = false;
                const initTone = async () => {
                    if (toneInitialized || typeof Tone === 'undefined') {
                        return toneInitialized;
                    }
                    try {
                        await Tone.start();
                        Tone.context.latencyHint = 'playback';
                        toneInitialized = true;
                        console.log('âœ… Tone.js initialized');
                        return true;
                    } catch (e) {
                        console.warn('Tone.js initialization failed, using Web Audio fallback:', e);
                        return false;
                    }
                };
                
                // ============================================================================
                // AMBIENT PATCH BASE CLASS
                // ============================================================================
                class AmbientPatch {
                    constructor(preset, masterGain) {
                        this.preset = preset;
                        this.masterGain = masterGain || null;
                        this.nodes = [];
                        this.activeVoices = new Map();
                        this.isDisposed = false;
                        
                        // Initialize Tone.js if available
                        if (typeof Tone !== 'undefined') {
                            initTone();
                        }
                    }
                    
                    // Create a voice for note playback (to be overridden)
                    createVoice(freq, velocity, duration) {
                        throw new Error('createVoice must be implemented by subclass');
                    }
                    
                    // Shared reverb creation for all patch types
                    createReverb(audioContext) {
                        // Create spacious convolution reverb
                        const convolver = audioContext.createConvolver();
                        const reverbGain = audioContext.createGain();
                        const dryGain = audioContext.createGain();
                        const reverbFilter = audioContext.createBiquadFilter();
                        
                        const sampleRate = audioContext.sampleRate;
                        const length = sampleRate * 3.5;
                        const impulse = audioContext.createBuffer(2, length, sampleRate);
                        
                        try {
                            for (let channel = 0; channel < 2; channel++) {
                                const channelData = impulse.getChannelData(channel);
                                for (let i = 0; i < length; i++) {
                                    const n = length - i;
                                    const t = i / sampleRate;
                                    
                                    let earlyReflections = 0;
                                    if (t < 0.1) {
                                        const earlyTime = t * 10;
                                        earlyReflections = Math.sin(earlyTime * Math.PI * 8) * Math.exp(-earlyTime * 5) * 0.3;
                                    }
                                    
                                    const decay = Math.pow(n / length, 1.5);
                                    const noise = (Math.random() * 2 - 1) * 0.3;
                                    const tail = decay * (0.7 + noise);
                                    channelData[i] = (earlyReflections + tail) * 0.8;
                                }
                            }
                        } catch (e) {
                            console.error('Error creating reverb impulse:', e);
                            for (let channel = 0; channel < 2; channel++) {
                                const channelData = impulse.getChannelData(channel);
                                for (let i = 0; i < length; i++) {
                                    const n = length - i;
                                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(n / length, 2) * 0.6;
                                }
                            }
                        }
                        
                        convolver.buffer = impulse;
                        reverbFilter.type = 'lowpass';
                        reverbFilter.frequency.value = 8000;
                        reverbFilter.Q.value = 0.5;
                        
                        reverbGain.gain.value = 0.8; // Reverb level
                        dryGain.gain.value = 0.5; // Dry signal level (more audible)
                        
                        const output = audioContext.createGain();
                        convolver.connect(reverbFilter);
                        reverbFilter.connect(reverbGain);
                        reverbGain.connect(output);
                        dryGain.connect(output);
                        
                        return {
                            dryGain: dryGain,
                            convolver: convolver,
                            output: output,
                            reverbGain: reverbGain,
                            reverbFilter: reverbFilter
                        };
                    }
                    
                    // Cleanup
                    dispose() {
                        this.isDisposed = true;
                        this.activeVoices.forEach(voice => {
                            try {
                                if (voice.stop) voice.stop();
                                if (voice.dispose) voice.dispose();
                            } catch (e) {}
                        });
                        this.activeVoices.clear();
                        this.nodes.forEach(node => {
                            try {
                                if (node.disconnect) node.disconnect();
                                if (node.dispose) node.dispose();
                            } catch (e) {}
                        });
                        this.nodes = [];
                    }
                }
                
                // ============================================================================
                // WARM AMBIENT PAD PATCHES
                // ============================================================================
                class PadPatch extends AmbientPatch {
                    createVoice(freq, velocity, duration, masterGain) {
                        const useTone = typeof Tone !== 'undefined' && toneInitialized;
                        const voiceId = `${freq}-${Date.now()}`;
                        
                        if (useTone) {
                            return this.createTonePadVoice(freq, velocity, duration, masterGain, voiceId);
                        } else {
                            return this.createWebAudioPadVoice(freq, velocity, duration, masterGain, voiceId);
                        }
                    }
                    
                    createTonePadVoice(freq, velocity, duration, masterGain, voiceId) {
                        const preset = this.preset;
                        
                        try {
                            // Create multiple oscillators with detuning for warmth
                            const osc1 = new Tone.Oscillator({
                                type: preset.osc1Type || 'sawtooth',
                                frequency: freq,
                                detune: (preset.detune1 || 0) * 100
                            });
                            
                            const osc2 = new Tone.Oscillator({
                                type: preset.osc2Type || 'sawtooth',
                                frequency: freq,
                                detune: (preset.detune2 || 0) * 100
                            });
                            
                            const osc3 = new Tone.Oscillator({
                                type: 'triangle',
                                frequency: freq * 0.5, // Sub-octave for body
                                detune: 0
                            });
                            
                            // Mixer for oscillators
                            const mixer = new Tone.Gain(1);
                            osc1.connect(mixer);
                            osc2.connect(mixer);
                            osc3.connect(mixer);
                            
                            // Low-pass filter with envelope
                            const filter = new Tone.Filter({
                                type: 'lowpass',
                                frequency: preset.filterCutoff || 4000,
                                Q: preset.filterQ || 1
                            });
                            
                            // Filter envelope (opens over attack)
                            const filterEnv = new Tone.Envelope({
                                attack: preset.attack || 1.5,
                                decay: preset.decay || 3.0,
                                sustain: 0.7,
                                release: preset.release || 4.0
                            });
                            filterEnv.connect(filter.frequency);
                            filterEnv.attackCurve = 'exponential';
                            
                            // ADSR envelope
                            const envelope = new Tone.AmplitudeEnvelope({
                                attack: preset.attack || 1.5,
                                decay: preset.decay || 3.0,
                                sustain: preset.sustain || 0.7,
                                release: preset.release || 4.0
                            });
                            
                            // Slow LFO for filter movement
                            const lfo = new Tone.LFO({
                                frequency: 0.1, // Very slow
                                min: preset.filterCutoff * 0.8 || 3200,
                                max: preset.filterCutoff * 1.1 || 4400
                            });
                            lfo.connect(filter.frequency);
                            lfo.start();
                            
                            // Pan LFO for spaciousness
                            const panLFO = new Tone.LFO({
                                frequency: 0.05,
                                min: -0.3,
                                max: 0.3
                            });
                            const panner = new Tone.Panner(0);
                            panLFO.connect(panner.pan);
                            panLFO.start();
                            
                            // Reverb (long, soft) - generate synchronously
                            const reverb = new Tone.Reverb({
                                roomSize: 0.9,
                                dampening: 3000,
                                wet: 0.6
                            });
                            // Generate reverb impulse (synchronous, may take a moment)
                            reverb.generate();
                            
                            // Delay for ambient trails
                            const delay = new Tone.FeedbackDelay({
                                delayTime: '0.5',
                                feedback: 0.3,
                                wet: 0.2
                            });
                            
                            // Connect: mixer -> filter -> envelope -> delay -> reverb -> panner -> master
                            mixer.connect(filter);
                            filter.connect(envelope);
                            envelope.connect(delay);
                            delay.connect(reverb);
                            reverb.connect(panner);
                            
                            // Connect to masterGain if it's a Web Audio node, otherwise to Tone.Destination
                            if (masterGain && masterGain.context && masterGain.context !== Tone.context) {
                                // Web Audio API masterGain - need to connect via Tone.js output
                                const output = new Tone.Gain(1);
                                panner.connect(output);
                                // Connect Tone.js output to Web Audio masterGain
                                const toneToWebAudio = Tone.context.createMediaStreamDestination();
                                output.connect(Tone.Destination);
                                // Note: This is complex, fallback to Web Audio for now
                                panner.toDestination();
                            } else {
                                panner.toDestination();
                            }
                            
                            // Start oscillators
                            osc1.start();
                            osc2.start();
                            osc3.start();
                            
                            // Trigger envelopes
                            filterEnv.triggerAttack();
                            envelope.triggerAttack(velocity);
                            
                            // Schedule stop
                            const stopTime = Tone.now() + duration;
                            Tone.Transport.schedule(() => {
                                filterEnv.triggerRelease();
                                envelope.triggerRelease();
                                setTimeout(() => {
                                    osc1.stop();
                                    osc2.stop();
                                    osc3.stop();
                                    lfo.stop();
                                    panLFO.stop();
                                    osc1.dispose();
                                    osc2.dispose();
                                    osc3.dispose();
                                    mixer.dispose();
                                    filter.dispose();
                                    envelope.dispose();
                                    reverb.dispose();
                                    delay.dispose();
                                    panner.dispose();
                                    lfo.dispose();
                                    panLFO.dispose();
                                    filterEnv.dispose();
                                }, (preset.release || 4.0) * 1000);
                            }, stopTime);
                            
                            const voice = {
                                stop: () => {
                                    filterEnv.triggerRelease();
                                    envelope.triggerRelease();
                                    osc1.stop();
                                    osc2.stop();
                                    osc3.stop();
                                    lfo.stop();
                                    panLFO.stop();
                                },
                                release: () => {
                                    filterEnv.triggerRelease();
                                    envelope.triggerRelease();
                                }
                            };
                            
                            this.activeVoices.set(voiceId, voice);
                            return voice;
                        } catch (e) {
                            console.error('Error creating Tone.js pad voice:', e);
                            // Fallback to Web Audio
                            return this.createWebAudioPadVoice(freq, velocity, duration, masterGain, voiceId);
                        }
                    }
                    
                    createWebAudioPadVoice(freq, velocity, duration, masterGain, voiceId) {
                        // Fallback to Web Audio API with proper reverb and effects
                        const audioContext = masterGain.context;
                        const now = audioContext.currentTime;
                        const preset = this.preset;
                        
                        console.log('ðŸŽµ Creating Web Audio pad voice:', preset.name, 'freq:', freq, 'osc1Type:', preset.osc1Type, 'osc2Type:', preset.osc2Type);
                        
                        const mixer = audioContext.createGain();
                        mixer.gain.value = 1.0;
                        
                        // Multiple oscillators with proper types
                        const osc1 = audioContext.createOscillator();
                        const osc2 = audioContext.createOscillator();
                        const osc3 = audioContext.createOscillator();
                        
                        osc1.type = preset.osc1Type || 'sawtooth';
                        osc2.type = preset.osc2Type || 'sawtooth';
                        osc3.type = 'triangle';
                        
                        // Detune in cents (not semitones) - convert to frequency ratio
                        const detune1Cents = (preset.detune1 || 0) * 100;
                        const detune2Cents = (preset.detune2 || 0) * 100;
                        osc1.frequency.value = freq * Math.pow(2, detune1Cents / 1200);
                        osc2.frequency.value = freq * Math.pow(2, detune2Cents / 1200);
                        osc3.frequency.value = freq * 0.5;
                        
                        const osc1Gain = audioContext.createGain();
                        const osc2Gain = audioContext.createGain();
                        const osc3Gain = audioContext.createGain();
                        
                        osc1Gain.gain.value = 0.4 * velocity;
                        osc2Gain.gain.value = 0.4 * velocity;
                        osc3Gain.gain.value = 0.2 * velocity;
                        
                        osc1.connect(osc1Gain);
                        osc2.connect(osc2Gain);
                        osc3.connect(osc3Gain);
                        osc1Gain.connect(mixer);
                        osc2Gain.connect(mixer);
                        osc3Gain.connect(mixer);
                        
                        // Low-pass filter with envelope
                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'lowpass';
                        const filterBaseFreq = preset.filterCutoff || 4000;
                        filter.Q.value = preset.filterQ || 1;
                        
                        // Filter envelope for movement
                        const filterAttack = preset.attack || 1.5;
                        const filterDecay = preset.decay || 3.0;
                        filter.frequency.setValueAtTime(filterBaseFreq * 0.7, now);
                        filter.frequency.linearRampToValueAtTime(filterBaseFreq * 1.1, now + filterAttack);
                        filter.frequency.setValueAtTime(filterBaseFreq * 1.05, now + filterAttack + filterDecay);
                        filter.frequency.linearRampToValueAtTime(filterBaseFreq * 0.9, now + duration * 0.6);
                        
                        // ADSR envelope
                        const envelope = audioContext.createGain();
                        const attack = preset.attack || 1.5;
                        const decay = preset.decay || 3.0;
                        const sustain = preset.sustain || 0.7;
                        const release = preset.release || 4.0;
                        
                        envelope.gain.setValueAtTime(0, now);
                        envelope.gain.linearRampToValueAtTime(velocity, now + attack);
                        envelope.gain.linearRampToValueAtTime(velocity * sustain, now + attack + decay);
                        envelope.gain.setValueAtTime(velocity * sustain, now + duration - release);
                        envelope.gain.linearRampToValueAtTime(0, now + duration);
                        
                        // Create reverb
                        const reverb = this.createReverb(audioContext);
                        
                        // Create delay
                        const delay = audioContext.createDelay(2.0);
                        const delayGain = audioContext.createGain();
                        const feedbackGain = audioContext.createGain();
                        const delayFilter = audioContext.createBiquadFilter();
                        
                        delay.delayTime.value = 0.5;
                        delayGain.gain.value = 0.3;
                        feedbackGain.gain.value = 0.25;
                        delayFilter.type = 'lowpass';
                        delayFilter.frequency.value = 2000;
                        delayFilter.Q.value = 1;
                        
                        // Connect: mixer -> filter -> envelope -> [dry path + delay path] -> reverb -> master
                        mixer.connect(filter);
                        filter.connect(envelope);
                        
                        // Dry signal path: envelope -> reverb dryGain
                        envelope.connect(reverb.dryGain);
                        
                        // Delay path: envelope -> delay -> delayGain -> reverb convolver
                        envelope.connect(delay);
                        delay.connect(delayFilter);
                        delayFilter.connect(feedbackGain);
                        feedbackGain.connect(delay); // Feedback
                        delay.connect(delayGain);
                        delayGain.connect(reverb.convolver);
                        
                        // Reverb output to master
                        reverb.output.connect(masterGain);
                        
                        osc1.start(now);
                        osc2.start(now);
                        osc3.start(now);
                        
                        const stopTime = now + duration + release;
                        osc1.stop(stopTime);
                        osc2.stop(stopTime);
                        osc3.stop(stopTime);
                        
                        const voice = {
                            stop: () => {
                                osc1.stop();
                                osc2.stop();
                                osc3.stop();
                            },
                            release: () => {
                                const now2 = audioContext.currentTime;
                                envelope.gain.cancelScheduledValues(now2);
                                envelope.gain.setValueAtTime(envelope.gain.value, now2);
                                envelope.gain.linearRampToValueAtTime(0, now2 + release);
                            }
                        };
                        
                        this.activeVoices.set(voiceId, voice);
                        return voice;
                    }
                }
                
                // ============================================================================
                // FLUTE-LIKE SYNTH PATCHES
                // ============================================================================
                class FlutePatch extends AmbientPatch {
                    createVoice(freq, velocity, duration, masterGain) {
                        const useTone = typeof Tone !== 'undefined' && toneInitialized;
                        const voiceId = `${freq}-${Date.now()}`;
                        
                        if (useTone) {
                            return this.createToneFluteVoice(freq, velocity, duration, masterGain, voiceId);
                        } else {
                            return this.createWebAudioFluteVoice(freq, velocity, duration, masterGain, voiceId);
                        }
                    }
                    
                    createToneFluteVoice(freq, velocity, duration, masterGain, voiceId) {
                        const preset = this.preset;
                        
                        // Main oscillator (triangle for warmth)
                        const osc = new Tone.Oscillator({
                            type: preset.osc1Type || 'triangle',
                            frequency: freq
                        });
                        
                        // Breath noise (filtered white noise)
                        const noise = new Tone.Noise('white');
                        const noiseFilter = new Tone.Filter({
                            type: 'bandpass',
                            frequency: 2000,
                            Q: 2
                        });
                        const noiseGain = new Tone.Gain(0.05 * velocity);
                        
                        // Noise envelope (only during attack)
                        const noiseEnv = new Tone.Envelope({
                            attack: 0.1,
                            decay: (preset.attack || 0.15) * 0.5,
                            sustain: 0,
                            release: 0
                        });
                        noiseEnv.connect(noiseGain.gain);
                        
                        noise.connect(noiseFilter);
                        noiseFilter.connect(noiseGain);
                        
                        // Vibrato LFO
                        const vibrato = new Tone.LFO({
                            frequency: preset.vibratoSpeed || 6,
                            min: -preset.vibratoDepth || -2,
                            max: preset.vibratoDepth || 2
                        });
                        vibrato.connect(osc.frequency);
                        vibrato.start();
                        
                        // Low-pass filter for warmth
                        const filter = new Tone.Filter({
                            type: 'lowpass',
                            frequency: preset.filterCutoff || 3500,
                            Q: preset.filterQ || 2
                        });
                        
                        // ADSR envelope
                        const envelope = new Tone.AmplitudeEnvelope({
                            attack: preset.attack || 0.15,
                            decay: preset.decay || 0.2,
                            sustain: preset.sustain || 0.75,
                            release: preset.release || 1.2
                        });
                        
                        // Reverb
                        const reverb = new Tone.Reverb({
                            roomSize: 0.7,
                            dampening: 4000,
                            wet: 0.4
                        });
                        reverb.generate();
                        
                        // Connect: osc + noise -> filter -> envelope -> reverb -> master
                        osc.connect(filter);
                        noiseGain.connect(filter);
                        filter.connect(envelope);
                        envelope.connect(reverb);
                        reverb.connect(masterGain || Tone.Destination);
                        
                        osc.start();
                        noise.start();
                        
                        noiseEnv.triggerAttack();
                        envelope.triggerAttack(velocity);
                        
                        const stopTime = Tone.now() + duration;
                        Tone.Transport.schedule(() => {
                            noiseEnv.triggerRelease();
                            envelope.triggerRelease();
                            setTimeout(() => {
                                osc.stop();
                                noise.stop();
                                vibrato.stop();
                                osc.dispose();
                                noise.dispose();
                                vibrato.dispose();
                                filter.dispose();
                                envelope.dispose();
                                reverb.dispose();
                                noiseFilter.dispose();
                                noiseGain.dispose();
                                noiseEnv.dispose();
                            }, (preset.release || 1.2) * 1000);
                        }, stopTime);
                        
                        const voice = {
                            stop: () => {
                                noiseEnv.triggerRelease();
                                envelope.triggerRelease();
                                osc.stop();
                                noise.stop();
                                vibrato.stop();
                            },
                            release: () => {
                                noiseEnv.triggerRelease();
                                envelope.triggerRelease();
                            }
                        };
                        
                        this.activeVoices.set(voiceId, voice);
                        return voice;
                    }
                    
                    createWebAudioFluteVoice(freq, velocity, duration, masterGain, voiceId) {
                        // Web Audio fallback with reverb
                        const audioContext = masterGain.context;
                        const now = audioContext.currentTime;
                        const preset = this.preset;
                        
                        console.log('ðŸŽµ Creating Web Audio flute voice:', preset.name);
                        
                        const osc = audioContext.createOscillator();
                        osc.type = preset.osc1Type || 'triangle';
                        osc.frequency.value = freq;
                        
                        // Vibrato
                        const lfo = audioContext.createOscillator();
                        const lfoGain = audioContext.createGain();
                        lfo.type = 'sine';
                        lfo.frequency.value = preset.vibratoSpeed || 6;
                        lfoGain.gain.value = (preset.vibratoDepth || 2) * freq / 100;
                        lfo.connect(lfoGain);
                        lfoGain.connect(osc.frequency);
                        
                        // Breath noise
                        const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
                        const noiseData = noiseBuffer.getChannelData(0);
                        for (let i = 0; i < noiseData.length; i++) {
                            noiseData[i] = Math.random() * 2 - 1;
                        }
                        const noise = audioContext.createBufferSource();
                        noise.buffer = noiseBuffer;
                        noise.loop = true;
                        const noiseFilter = audioContext.createBiquadFilter();
                        noiseFilter.type = 'bandpass';
                        noiseFilter.frequency.value = 2000;
                        noiseFilter.Q.value = 2;
                        const noiseGain = audioContext.createGain();
                        noiseGain.gain.setValueAtTime(0.05 * velocity, now);
                        noiseGain.gain.linearRampToValueAtTime(0, now + (preset.attack || 0.15) * 0.5);
                        
                        const mixer = audioContext.createGain();
                        osc.connect(mixer);
                        noise.connect(noiseFilter);
                        noiseFilter.connect(noiseGain);
                        noiseGain.connect(mixer);
                        
                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = preset.filterCutoff || 3500;
                        filter.Q.value = preset.filterQ || 2;
                        
                        const envelope = audioContext.createGain();
                        const attack = preset.attack || 0.15;
                        const decay = preset.decay || 0.2;
                        const sustain = preset.sustain || 0.75;
                        const release = preset.release || 1.2;
                        
                        envelope.gain.setValueAtTime(0, now);
                        envelope.gain.linearRampToValueAtTime(velocity, now + attack);
                        envelope.gain.linearRampToValueAtTime(velocity * sustain, now + attack + decay);
                        envelope.gain.setValueAtTime(velocity * sustain, now + duration - release);
                        envelope.gain.linearRampToValueAtTime(0, now + duration);
                        
                        // Create reverb
                        const reverb = this.createReverb(audioContext);
                        
                        mixer.connect(filter);
                        filter.connect(envelope);
                        envelope.connect(reverb.dryGain);
                        envelope.connect(reverb.convolver);
                        reverb.output.connect(masterGain);
                        
                        osc.start(now);
                        lfo.start(now);
                        noise.start(now);
                        
                        const stopTime = now + duration + release;
                        osc.stop(stopTime);
                        lfo.stop(stopTime);
                        noise.stop(stopTime);
                        
                        const voice = {
                            stop: () => {
                                osc.stop();
                                lfo.stop();
                                noise.stop();
                            },
                            release: () => {
                                const now2 = audioContext.currentTime;
                                envelope.gain.cancelScheduledValues(now2);
                                envelope.gain.setValueAtTime(envelope.gain.value, now2);
                                envelope.gain.linearRampToValueAtTime(0, now2 + release);
                            }
                        };
                        
                        this.activeVoices.set(voiceId, voice);
                        return voice;
                    }
                }
                
                // ============================================================================
                // MEDITATIVE DRONE PATCHES
                // ============================================================================
                class DronePatch extends AmbientPatch {
                    createVoice(freq, velocity, duration, masterGain) {
                        const useTone = typeof Tone !== 'undefined' && toneInitialized;
                        const voiceId = `${freq}-${Date.now()}`;
                        
                        if (useTone) {
                            return this.createToneDroneVoice(freq, velocity, duration, masterGain, voiceId);
                        } else {
                            return this.createWebAudioDroneVoice(freq, velocity, duration, masterGain, voiceId);
                        }
                    }
                    
                    createToneDroneVoice(freq, velocity, duration, masterGain, voiceId) {
                        const preset = this.preset;
                        
                        // Multiple oscillators for rich drone
                        const osc1 = new Tone.Oscillator({
                            type: 'sine',
                            frequency: freq
                        });
                        const osc2 = new Tone.Oscillator({
                            type: 'sine',
                            frequency: freq * 2, // Octave
                            detune: -5
                        });
                        const osc3 = new Tone.Oscillator({
                            type: 'triangle',
                            frequency: freq * 0.5, // Sub-octave
                            detune: 3
                        });
                        
                        const mixer = new Tone.Gain(1);
                        osc1.connect(mixer);
                        osc2.connect(mixer);
                        osc3.connect(mixer);
                        
                        // Very slow filter movement
                        const filter = new Tone.Filter({
                            type: 'lowpass',
                            frequency: preset.filterCutoff || 2000,
                            Q: 0.5
                        });
                        
                        const filterLFO = new Tone.LFO({
                            frequency: 0.05, // Very slow
                            min: preset.filterCutoff * 0.7 || 1400,
                            max: preset.filterCutoff * 1.1 || 2200
                        });
                        filterLFO.connect(filter.frequency);
                        filterLFO.start();
                        
                        // Minimal attack, long sustain
                        const envelope = new Tone.AmplitudeEnvelope({
                            attack: preset.attack || 2.0,
                            decay: preset.decay || 1.2,
                            sustain: preset.sustain || 0.99,
                            release: preset.release || 5.0
                        });
                        
                        // Deep reverb
                        const reverb = new Tone.Reverb({
                            roomSize: 0.95,
                            dampening: 2000,
                            wet: 0.7
                        });
                        reverb.generate();
                        
                        mixer.connect(filter);
                        filter.connect(envelope);
                        envelope.connect(reverb);
                        reverb.connect(masterGain || Tone.Destination);
                        
                        osc1.start();
                        osc2.start();
                        osc3.start();
                        envelope.triggerAttack(velocity);
                        
                        const stopTime = Tone.now() + duration;
                        Tone.Transport.schedule(() => {
                            envelope.triggerRelease();
                            setTimeout(() => {
                                osc1.stop();
                                osc2.stop();
                                osc3.stop();
                                filterLFO.stop();
                                osc1.dispose();
                                osc2.dispose();
                                osc3.dispose();
                                mixer.dispose();
                                filter.dispose();
                                envelope.dispose();
                                reverb.dispose();
                                filterLFO.dispose();
                            }, (preset.release || 5.0) * 1000);
                        }, stopTime);
                        
                        const voice = {
                            stop: () => {
                                envelope.triggerRelease();
                                osc1.stop();
                                osc2.stop();
                                osc3.stop();
                                filterLFO.stop();
                            },
                            release: () => {
                                envelope.triggerRelease();
                            }
                        };
                        
                        this.activeVoices.set(voiceId, voice);
                        return voice;
                    }
                    
                    createWebAudioDroneVoice(freq, velocity, duration, masterGain, voiceId) {
                        // Web Audio fallback with reverb
                        const audioContext = masterGain.context;
                        const now = audioContext.currentTime;
                        const preset = this.preset;
                        
                        console.log('ðŸŽµ Creating Web Audio drone voice:', preset.name);
                        
                        const osc1 = audioContext.createOscillator();
                        const osc2 = audioContext.createOscillator();
                        const osc3 = audioContext.createOscillator();
                        
                        osc1.type = preset.osc1Type || 'sine';
                        osc2.type = preset.osc2Type || 'sine';
                        osc3.type = 'triangle';
                        
                        osc1.frequency.value = freq;
                        osc2.frequency.value = freq * 2;
                        osc3.frequency.value = freq * 0.5;
                        
                        const osc1Gain = audioContext.createGain();
                        const osc2Gain = audioContext.createGain();
                        const osc3Gain = audioContext.createGain();
                        
                        osc1Gain.gain.value = 0.4 * velocity;
                        osc2Gain.gain.value = 0.3 * velocity;
                        osc3Gain.gain.value = 0.3 * velocity;
                        
                        const mixer = audioContext.createGain();
                        osc1.connect(osc1Gain);
                        osc2.connect(osc2Gain);
                        osc3.connect(osc3Gain);
                        osc1Gain.connect(mixer);
                        osc2Gain.connect(mixer);
                        osc3Gain.connect(mixer);
                        
                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = preset.filterCutoff || 2000;
                        filter.Q.value = 0.5;
                        
                        const envelope = audioContext.createGain();
                        const attack = preset.attack || 2.0;
                        const decay = preset.decay || 1.2;
                        const sustain = preset.sustain || 0.99;
                        const release = preset.release || 5.0;
                        
                        envelope.gain.setValueAtTime(0, now);
                        envelope.gain.linearRampToValueAtTime(velocity, now + attack);
                        envelope.gain.linearRampToValueAtTime(velocity * sustain, now + attack + decay);
                        envelope.gain.setValueAtTime(velocity * sustain, now + duration - release);
                        envelope.gain.linearRampToValueAtTime(0, now + duration);
                        
                        // Create reverb
                        const reverb = this.createReverb(audioContext);
                        
                        mixer.connect(filter);
                        filter.connect(envelope);
                        envelope.connect(reverb.dryGain);
                        envelope.connect(reverb.convolver);
                        reverb.output.connect(masterGain);
                        
                        osc1.start(now);
                        osc2.start(now);
                        osc3.start(now);
                        
                        const stopTime = now + duration + release;
                        osc1.stop(stopTime);
                        osc2.stop(stopTime);
                        osc3.stop(stopTime);
                        
                        const voice = {
                            stop: () => {
                                osc1.stop();
                                osc2.stop();
                                osc3.stop();
                            },
                            release: () => {
                                const now2 = audioContext.currentTime;
                                envelope.gain.cancelScheduledValues(now2);
                                envelope.gain.setValueAtTime(envelope.gain.value, now2);
                                envelope.gain.linearRampToValueAtTime(0, now2 + release);
                            }
                        };
                        
                        this.activeVoices.set(voiceId, voice);
                        return voice;
                    }
                }
                
                // ============================================================================
                // BOWL / BELL-LIKE PATCHES (FM Synthesis)
                // ============================================================================
                class BowlPatch extends AmbientPatch {
                    createVoice(freq, velocity, duration, masterGain) {
                        const useTone = typeof Tone !== 'undefined' && toneInitialized;
                        const voiceId = `${freq}-${Date.now()}`;
                        
                        if (useTone) {
                            return this.createToneBowlVoice(freq, velocity, duration, masterGain, voiceId);
                        } else {
                            return this.createWebAudioBowlVoice(freq, velocity, duration, masterGain, voiceId);
                        }
                    }
                    
                    createToneBowlVoice(freq, velocity, duration, masterGain, voiceId) {
                        const preset = this.preset;
                        
                        // FM synthesis for bell-like tones
                        const carrier = new Tone.Oscillator({
                            type: 'sine',
                            frequency: freq
                        });
                        
                        const modulator = new Tone.Oscillator({
                            type: 'sine',
                            frequency: freq * 2.5 // Creates bell-like harmonics
                        });
                        
                        const modGain = new Tone.Gain(200); // Modulation index
                        modulator.connect(modGain);
                        modGain.connect(carrier.frequency);
                        
                        // Additive harmonics for richness
                        const harmonic2 = new Tone.Oscillator({
                            type: 'sine',
                            frequency: freq * 2
                        });
                        const harmonic3 = new Tone.Oscillator({
                            type: 'sine',
                            frequency: freq * 3
                        });
                        
                        const mixer = new Tone.Gain(1);
                        carrier.connect(mixer);
                        harmonic2.connect(mixer);
                        harmonic3.connect(mixer);
                        
                        // Bright filter
                        const filter = new Tone.Filter({
                            type: 'lowpass',
                            frequency: preset.filterCutoff || 6000,
                            Q: preset.filterQ || 4
                        });
                        
                        // Short attack, long decay
                        const envelope = new Tone.AmplitudeEnvelope({
                            attack: preset.attack || 0.01,
                            decay: preset.decay || 0.05,
                            sustain: preset.sustain || 0.4,
                            release: preset.release || 6.0
                        });
                        
                        // Long reverb
                        const reverb = new Tone.Reverb({
                            roomSize: 0.95,
                            dampening: 5000,
                            wet: 0.8
                        });
                        reverb.generate();
                        
                        mixer.connect(filter);
                        filter.connect(envelope);
                        envelope.connect(reverb);
                        reverb.connect(masterGain || Tone.Destination);
                        
                        carrier.start();
                        modulator.start();
                        harmonic2.start();
                        harmonic3.start();
                        envelope.triggerAttack(velocity);
                        
                        const stopTime = Tone.now() + duration;
                        Tone.Transport.schedule(() => {
                            envelope.triggerRelease();
                            setTimeout(() => {
                                carrier.stop();
                                modulator.stop();
                                harmonic2.stop();
                                harmonic3.stop();
                                carrier.dispose();
                                modulator.dispose();
                                harmonic2.dispose();
                                harmonic3.dispose();
                                modGain.dispose();
                                mixer.dispose();
                                filter.dispose();
                                envelope.dispose();
                                reverb.dispose();
                            }, (preset.release || 6.0) * 1000);
                        }, stopTime);
                        
                        const voice = {
                            stop: () => {
                                envelope.triggerRelease();
                                carrier.stop();
                                modulator.stop();
                                harmonic2.stop();
                                harmonic3.stop();
                            },
                            release: () => {
                                envelope.triggerRelease();
                            }
                        };
                        
                        this.activeVoices.set(voiceId, voice);
                        return voice;
                    }
                    
                    createWebAudioBowlVoice(freq, velocity, duration, masterGain, voiceId) {
                        // Web Audio fallback with additive synthesis and reverb
                        const audioContext = masterGain.context;
                        const now = audioContext.currentTime;
                        const preset = this.preset;
                        
                        console.log('ðŸŽµ Creating Web Audio bowl voice:', preset.name);
                        
                        const harmonics = [
                            { freqRatio: 1.0, amplitude: 0.6 },
                            { freqRatio: 2.0, amplitude: 0.4 },
                            { freqRatio: 3.0, amplitude: 0.25 },
                            { freqRatio: 4.0, amplitude: 0.15 },
                            { freqRatio: 5.0, amplitude: 0.1 }
                        ];
                        
                        const mixer = audioContext.createGain();
                        const oscillators = [];
                        
                        harmonics.forEach(harmonic => {
                            const osc = audioContext.createOscillator();
                            osc.type = 'sine';
                            osc.frequency.value = freq * harmonic.freqRatio;
                            const oscGain = audioContext.createGain();
                            oscGain.gain.value = harmonic.amplitude * velocity;
                            osc.connect(oscGain);
                            oscGain.connect(mixer);
                            osc.start(now);
                            oscillators.push(osc);
                        });
                        
                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = preset.filterCutoff || 6000;
                        filter.Q.value = preset.filterQ || 4;
                        
                        const envelope = audioContext.createGain();
                        const attack = preset.attack || 0.01;
                        const decay = preset.decay || 0.05;
                        const sustain = preset.sustain || 0.4;
                        const release = preset.release || 6.0;
                        
                        envelope.gain.setValueAtTime(0, now);
                        envelope.gain.linearRampToValueAtTime(velocity, now + attack);
                        envelope.gain.linearRampToValueAtTime(velocity * sustain, now + attack + decay);
                        envelope.gain.setValueAtTime(velocity * sustain, now + duration - release);
                        envelope.gain.linearRampToValueAtTime(0, now + duration);
                        
                        // Create reverb
                        const reverb = this.createReverb(audioContext);
                        
                        mixer.connect(filter);
                        filter.connect(envelope);
                        envelope.connect(reverb.dryGain);
                        envelope.connect(reverb.convolver);
                        reverb.output.connect(masterGain);
                        
                        const stopTime = now + duration + release;
                        oscillators.forEach(osc => osc.stop(stopTime));
                        
                        const voice = {
                            stop: () => {
                                oscillators.forEach(osc => osc.stop());
                            },
                            release: () => {
                                const now2 = audioContext.currentTime;
                                envelope.gain.cancelScheduledValues(now2);
                                envelope.gain.setValueAtTime(envelope.gain.value, now2);
                                envelope.gain.linearRampToValueAtTime(0, now2 + release);
                            }
                        };
                        
                        this.activeVoices.set(voiceId, voice);
                        return voice;
                    }
                }
                
                // ============================================================================
                // NOISE BED / NATURE-LIKE PATCHES
                // ============================================================================
                class NoiseBedPatch extends AmbientPatch {
                    createVoice(freq, velocity, duration, masterGain) {
                        const useTone = typeof Tone !== 'undefined' && toneInitialized;
                        const voiceId = `${freq}-${Date.now()}`;
                        
                        if (useTone) {
                            return this.createToneNoiseBedVoice(freq, velocity, duration, masterGain, voiceId);
                        } else {
                            return this.createWebAudioNoiseBedVoice(freq, velocity, duration, masterGain, voiceId);
                        }
                    }
                    
                    createToneNoiseBedVoice(freq, velocity, duration, masterGain, voiceId) {
                        const preset = this.preset;
                        
                        // Pink noise (more natural than white)
                        const noise = new Tone.Noise('pink');
                        
                        // Multiple bandpass filters for texture
                        const filter1 = new Tone.Filter({
                            type: 'bandpass',
                            frequency: freq || 500,
                            Q: 2
                        });
                        
                        const filter2 = new Tone.Filter({
                            type: 'bandpass',
                            frequency: (freq || 500) * 1.5,
                            Q: 1.5
                        });
                        
                        // Slow filter movement
                        const filterLFO1 = new Tone.LFO({
                            frequency: 0.1,
                            min: (freq || 500) * 0.7,
                            max: (freq || 500) * 1.3
                        });
                        filterLFO1.connect(filter1.frequency);
                        filterLFO1.start();
                        
                        const filterLFO2 = new Tone.LFO({
                            frequency: 0.15,
                            min: (freq || 500) * 1.2,
                            max: (freq || 500) * 1.8
                        });
                        filterLFO2.connect(filter2.frequency);
                        filterLFO2.start();
                        
                        const mixer = new Tone.Gain(1);
                        noise.connect(filter1);
                        noise.connect(filter2);
                        filter1.connect(mixer);
                        filter2.connect(mixer);
                        
                        // Low-pass to keep it gentle
                        const lowpass = new Tone.Filter({
                            type: 'lowpass',
                            frequency: 2000,
                            Q: 1
                        });
                        
                        // Very gentle envelope
                        const envelope = new Tone.AmplitudeEnvelope({
                            attack: preset.attack || 3.0,
                            decay: preset.decay || 2.0,
                            sustain: preset.sustain || 0.8,
                            release: preset.release || 4.0
                        });
                        
                        // Soft reverb
                        const reverb = new Tone.Reverb({
                            roomSize: 0.8,
                            dampening: 4000,
                            wet: 0.5
                        });
                        reverb.generate();
                        
                        mixer.connect(lowpass);
                        lowpass.connect(envelope);
                        envelope.connect(reverb);
                        reverb.connect(masterGain || Tone.Destination);
                        
                        noise.start();
                        envelope.triggerAttack(velocity * 0.3); // Lower volume for noise beds
                        
                        const stopTime = Tone.now() + duration;
                        Tone.Transport.schedule(() => {
                            envelope.triggerRelease();
                            setTimeout(() => {
                                noise.stop();
                                filterLFO1.stop();
                                filterLFO2.stop();
                                noise.dispose();
                                filter1.dispose();
                                filter2.dispose();
                                mixer.dispose();
                                lowpass.dispose();
                                envelope.dispose();
                                reverb.dispose();
                                filterLFO1.dispose();
                                filterLFO2.dispose();
                            }, (preset.release || 4.0) * 1000);
                        }, stopTime);
                        
                        const voice = {
                            stop: () => {
                                envelope.triggerRelease();
                                noise.stop();
                                filterLFO1.stop();
                                filterLFO2.stop();
                            },
                            release: () => {
                                envelope.triggerRelease();
                            }
                        };
                        
                        this.activeVoices.set(voiceId, voice);
                        return voice;
                    }
                    
                    createWebAudioNoiseBedVoice(freq, velocity, duration, masterGain, voiceId) {
                        // Web Audio fallback with reverb
                        const audioContext = masterGain.context;
                        const now = audioContext.currentTime;
                        const preset = this.preset;
                        
                        console.log('ðŸŽµ Creating Web Audio noise bed voice:', preset.name);
                        
                        // Generate pink noise buffer
                        const bufferSize = audioContext.sampleRate * 2;
                        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                        const data = buffer.getChannelData(0);
                        let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                        for (let i = 0; i < bufferSize; i++) {
                            const white = Math.random() * 2 - 1;
                            b0 = 0.99886 * b0 + white * 0.0555179;
                            b1 = 0.99332 * b1 + white * 0.0750759;
                            b2 = 0.96900 * b2 + white * 0.1538520;
                            b3 = 0.86650 * b3 + white * 0.3104856;
                            b4 = 0.55000 * b4 + white * 0.5329522;
                            b5 = -0.7616 * b5 - white * 0.0168980;
                            const pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                            b6 = white * 0.115926;
                            data[i] = pink * 0.11;
                        }
                        
                        const noise = audioContext.createBufferSource();
                        noise.buffer = buffer;
                        noise.loop = true;
                        
                        const filter1 = audioContext.createBiquadFilter();
                        filter1.type = 'bandpass';
                        filter1.frequency.value = freq || 500;
                        filter1.Q.value = 2;
                        
                        const filter2 = audioContext.createBiquadFilter();
                        filter2.type = 'bandpass';
                        filter2.frequency.value = (freq || 500) * 1.5;
                        filter2.Q.value = 1.5;
                        
                        const mixer = audioContext.createGain();
                        noise.connect(filter1);
                        noise.connect(filter2);
                        filter1.connect(mixer);
                        filter2.connect(mixer);
                        
                        const lowpass = audioContext.createBiquadFilter();
                        lowpass.type = 'lowpass';
                        lowpass.frequency.value = 2000;
                        lowpass.Q.value = 1;
                        
                        const envelope = audioContext.createGain();
                        const attack = preset.attack || 3.0;
                        const decay = preset.decay || 2.0;
                        const sustain = preset.sustain || 0.8;
                        const release = preset.release || 4.0;
                        
                        envelope.gain.setValueAtTime(0, now);
                        envelope.gain.linearRampToValueAtTime(velocity * 0.3, now + attack);
                        envelope.gain.linearRampToValueAtTime(velocity * 0.3 * sustain, now + attack + decay);
                        envelope.gain.setValueAtTime(velocity * 0.3 * sustain, now + duration - release);
                        envelope.gain.linearRampToValueAtTime(0, now + duration);
                        
                        // Create reverb
                        const reverb = this.createReverb(audioContext);
                        
                        mixer.connect(lowpass);
                        lowpass.connect(envelope);
                        envelope.connect(reverb.dryGain);
                        envelope.connect(reverb.convolver);
                        reverb.output.connect(masterGain);
                        
                        noise.start(now);
                        
                        const stopTime = now + duration + release;
                        noise.stop(stopTime);
                        
                        const voice = {
                            stop: () => {
                                noise.stop();
                            },
                            release: () => {
                                const now2 = audioContext.currentTime;
                                envelope.gain.cancelScheduledValues(now2);
                                envelope.gain.setValueAtTime(envelope.gain.value, now2);
                                envelope.gain.linearRampToValueAtTime(0, now2 + release);
                            }
                        };
                        
                        this.activeVoices.set(voiceId, voice);
                        return voice;
                    }
                }
                
                // ============================================================================
                // AMBIENT ENGINE - Public API
                // ============================================================================
                const AmbientEngine = {
                    initialized: false,
                    currentPatch: null,
                    patches: new Map(),
                    globalReverb: null,
                    globalDelay: null,
                    masterGain: null,
                    
                    // Initialize Tone.js and global effects
                    async init(masterGainNode) {
                        if (this.initialized) return;
                        
                        this.masterGain = masterGainNode;
                        
                        if (typeof Tone !== 'undefined') {
                            const toneReady = await initTone();
                            if (toneReady) {
                                // Global reverb bus
                                this.globalReverb = new Tone.Reverb({
                                    roomSize: 0.9,
                                    dampening: 3000,
                                    wet: 0.4
                                });
                                await this.globalReverb.generate();
                                
                                // Global delay bus
                                this.globalDelay = new Tone.FeedbackDelay({
                                    delayTime: '0.4',
                                    feedback: 0.2,
                                    wet: 0.15
                                });
                                
                                // Connect global effects
                                this.globalReverb.connect(Tone.Destination);
                                this.globalDelay.connect(Tone.Destination);
                            }
                        }
                        
                        this.initialized = true;
                        console.log('âœ… AmbientEngine initialized, Tone.js:', toneInitialized);
                    },
                    
                    // List all available presets
                    listPresets() {
                        return Array.from(this.patches.keys());
                    },
                    
                    // Load a preset by name
                    loadPreset(presetName) {
                        const patch = this.patches.get(presetName);
                        if (!patch) {
                            console.warn('Preset not found:', presetName);
                            return false;
                        }
                        this.currentPatch = patch;
                        console.log('âœ… Loaded preset:', presetName);
                        return true;
                    },
                    
                    // Set global parameter (maps to multiple internal params)
                    setParameter(name, value) {
                        // Clamp value to 0-1
                        value = Math.max(0, Math.min(1, value));
                        
                        switch (name) {
                            case 'brightness':
                                // Adjust filter cutoffs globally
                                // This would need to be implemented per-patch
                                break;
                            case 'warmth':
                                // Adjust filter Q and resonance
                                break;
                            case 'space':
                                // Adjust reverb/delay mix
                                if (this.globalReverb) {
                                    this.globalReverb.wet.value = value * 0.6;
                                }
                                if (this.globalDelay) {
                                    this.globalDelay.wet.value = value * 0.3;
                                }
                                break;
                            case 'vibratoDepth':
                                // Adjust vibrato depth in flute patches
                                break;
                            case 'droneLevel':
                                // Adjust drone volume
                                break;
                        }
                    },
                    
                    // Start a continuous pad/drone
                    startPad(presetName) {
                        // For continuous playback (not implemented in current note-based system)
                        console.log('startPad called for:', presetName);
                    },
                    
                    // Stop continuous pad/drone
                    stopPad() {
                        console.log('stopPad called');
                    },
                    
                    // Play a note (main API for this app)
                    noteOn(freq, velocity, duration, presetName) {
                        if (!this.initialized) {
                            console.warn('AmbientEngine not initialized');
                            return null;
                        }
                        
                        const patch = this.patches.get(presetName);
                        if (!patch) {
                            console.warn('Preset not found for noteOn:', presetName);
                            return null;
                        }
                        
                        const masterGain = this.masterGain || (typeof Tone !== 'undefined' ? Tone.Destination : null);
                        if (!masterGain) {
                            console.warn('No master gain available');
                            return null;
                        }
                        
                        const voice = patch.createVoice(freq, velocity, duration, masterGain);
                        return voice;
                    },
                    
                    // Stop a note
                    noteOff(voice) {
                        if (voice && voice.release) {
                            voice.release();
                        }
                    },
                    
                    // Register a patch
                    registerPatch(name, patchClass, presetConfig) {
                        const patch = new patchClass(presetConfig, this.masterGain);
                        this.patches.set(name, patch);
                        console.log('âœ… Registered patch:', name);
                    }
                };
                
                // ============================================================================
                // PRESET DEFINITIONS - Complete Sound Library
                // ============================================================================
                
                // Warm Ambient Pads
                const padPresets = [
                    { name: 'Soft Innato Pad', osc1Type: 'sawtooth', osc2Type: 'sawtooth', detune1: 0.05, detune2: -0.05, attack: 1.5, decay: 3.0, sustain: 0.7, release: 4.0, filterCutoff: 4500, filterQ: 1.0 },
                    { name: 'Ethereal Cloud', osc1Type: 'sawtooth', osc2Type: 'triangle', detune1: 0.07, detune2: -0.07, attack: 2.0, decay: 4.0, sustain: 0.75, release: 5.0, filterCutoff: 4000, filterQ: 0.8 },
                    { name: 'Warm Embrace', osc1Type: 'triangle', osc2Type: 'sawtooth', detune1: 0.03, detune2: -0.03, attack: 1.2, decay: 2.5, sustain: 0.8, release: 3.5, filterCutoff: 5000, filterQ: 1.2 },
                    { name: 'Meditative Space', osc1Type: 'sawtooth', osc2Type: 'sawtooth', detune1: 0.06, detune2: -0.06, attack: 1.8, decay: 3.5, sustain: 0.72, release: 4.5, filterCutoff: 4200, filterQ: 0.9 }
                ];
                
                // Flute-like Synth Voices
                const flutePresets = [
                    { name: 'Breath Flute', osc1Type: 'triangle', detune1: 0, detune2: 0, attack: 0.15, decay: 0.2, sustain: 0.75, release: 1.2, filterCutoff: 3500, filterQ: 2.5, vibratoSpeed: 6, vibratoDepth: 2 },
                    { name: 'Warm Flute', osc1Type: 'triangle', detune1: 0.005, detune2: -0.005, attack: 0.18, decay: 0.25, sustain: 0.7, release: 1.5, filterCutoff: 3200, filterQ: 2.2, vibratoSpeed: 5.5, vibratoDepth: 1.8 },
                    { name: 'Shakuhachi Flute', osc1Type: 'sine', detune1: 0.004, detune2: -0.004, attack: 0.2, decay: 0.3, sustain: 0.65, release: 1.8, filterCutoff: 3000, filterQ: 2.0, vibratoSpeed: 7, vibratoDepth: 2.5 },
                    { name: 'Bamboo Flute', osc1Type: 'triangle', detune1: 0.006, detune2: -0.006, attack: 0.16, decay: 0.22, sustain: 0.72, release: 1.3, filterCutoff: 3400, filterQ: 2.3, vibratoSpeed: 6.5, vibratoDepth: 2.2 }
                ];
                
                // Meditative Drones
                const dronePresets = [
                    { name: 'Deep Earth Drone', osc1Type: 'sine', osc2Type: 'sine', detune1: 0, detune2: 0, attack: 2.5, decay: 1.5, sustain: 0.99, release: 6.0, filterCutoff: 1500, filterQ: 0.5 },
                    { name: 'Expansive Sky', osc1Type: 'sine', osc2Type: 'triangle', detune1: 0.01, detune2: -0.01, attack: 2.0, decay: 1.2, sustain: 0.98, release: 5.5, filterCutoff: 2500, filterQ: 0.6 },
                    { name: 'Grounding Tone', osc1Type: 'sine', osc2Type: 'sine', detune1: 0, detune2: 0, attack: 3.0, decay: 2.0, sustain: 0.99, release: 7.0, filterCutoff: 1200, filterQ: 0.4 },
                    { name: 'Celestial Drone', osc1Type: 'triangle', osc2Type: 'sine', detune1: 0.008, detune2: -0.008, attack: 1.8, decay: 1.0, sustain: 0.97, release: 5.0, filterCutoff: 2800, filterQ: 0.7 }
                ];
                
                // Bowl / Bell-like Tones
                const bowlPresets = [
                    { name: 'Crystal Bowl', osc1Type: 'sine', osc2Type: 'sine', detune1: 0, detune2: 0, attack: 0.01, decay: 0.05, sustain: 0.4, release: 6.0, filterCutoff: 6000, filterQ: 4.0 },
                    { name: 'Tibetan Singing Bowl', osc1Type: 'sine', osc2Type: 'sine', detune1: 0, detune2: 0, attack: 0.02, decay: 0.08, sustain: 0.5, release: 7.0, filterCutoff: 4500, filterQ: 3.5 },
                    { name: 'Temple Bell', osc1Type: 'sine', osc2Type: 'sine', detune1: 0, detune2: 0, attack: 0.005, decay: 0.03, sustain: 0.35, release: 5.5, filterCutoff: 5500, filterQ: 3.8 },
                    { name: 'Golden Gong', osc1Type: 'sine', osc2Type: 'sine', detune1: 0, detune2: 0, attack: 0.03, decay: 0.1, sustain: 0.45, release: 8.0, filterCutoff: 3000, filterQ: 2.2 }
                ];
                
                // Noise Beds / Nature-like
                const noiseBedPresets = [
                    { name: 'Wind Breath', osc1Type: 'noise', detune1: 0, detune2: 0, attack: 3.0, decay: 2.0, sustain: 0.8, release: 4.0, filterCutoff: 1500, filterQ: 1.0 },
                    { name: 'Distant Water', osc1Type: 'noise', detune1: 0, detune2: 0, attack: 2.5, decay: 1.8, sustain: 0.75, release: 3.5, filterCutoff: 2000, filterQ: 0.8 },
                    { name: 'Gentle Air', osc1Type: 'noise', detune1: 0, detune2: 0, attack: 4.0, decay: 3.0, sustain: 0.85, release: 5.0, filterCutoff: 1800, filterQ: 1.2 },
                    { name: 'Soft Texture', osc1Type: 'noise', detune1: 0, detune2: 0, attack: 3.5, decay: 2.5, sustain: 0.82, release: 4.5, filterCutoff: 2200, filterQ: 0.9 }
                ];
                
                // Register all patches
                padPresets.forEach(preset => {
                    AmbientEngine.registerPatch(preset.name, PadPatch, preset);
                });
                
                flutePresets.forEach(preset => {
                    AmbientEngine.registerPatch(preset.name, FlutePatch, preset);
                });
                
                dronePresets.forEach(preset => {
                    AmbientEngine.registerPatch(preset.name, DronePatch, preset);
                });
                
                bowlPresets.forEach(preset => {
                    AmbientEngine.registerPatch(preset.name, BowlPatch, preset);
                });
                
                noiseBedPresets.forEach(preset => {
                    AmbientEngine.registerPatch(preset.name, NoiseBedPatch, preset);
                });
                
                // ============================================================================
                // WARM SYNTH VOICE - Direct Web Audio API Implementation
                // Simple, reliable, warm ambient sounds with proper reverb and space
                // ============================================================================
                class WarmSynthVoice {
                    constructor(audioContext, preset, freq, velocity, duration, masterGain) {
                        this.audioContext = audioContext;
                        this.preset = preset;
                        this.freq = freq;
                        this.velocity = velocity;
                        this.duration = duration;
                        this.masterGain = masterGain;
                        this.nodes = [];
                        this.oscillators = [];
                        this.startTime = audioContext.currentTime;
                        
                        console.log('ðŸŽµ Creating warm synth voice:', preset.name, 'freq:', freq, 'type:', preset.osc1Type, preset.osc2Type);
                        this.createVoice();
                    }
                    
                    createVoice() {
                        const now = this.startTime;
                        const preset = this.preset;
                        const audioContext = this.audioContext;
                        
                        // Create mixer
                        const mixer = audioContext.createGain();
                        mixer.gain.value = 1.0;
                        this.nodes.push(mixer);
                        
                        // Determine synthesis approach based on preset name
                        if (preset.name.includes('Bowl') || preset.name.includes('Bell') || preset.name.includes('Gong') || preset.name.includes('Temple')) {
                            // Bowl/Bell: Additive synthesis with multiple harmonics
                            this.createBowlSound(mixer, preset, now);
                        } else if (preset.name.includes('Wind') || preset.name.includes('Water') || preset.name.includes('Air') || preset.name.includes('Texture')) {
                            // Noise beds: Filtered noise
                            this.createNoiseBed(mixer, preset, now);
                        } else if (preset.name.includes('Flute')) {
                            // Flute: Oscillator + breath noise + vibrato
                            this.createFluteSound(mixer, preset, now);
                        } else if (preset.name.includes('Drone')) {
                            // Drone: Multiple oscillators for richness
                            this.createDroneSound(mixer, preset, now);
                        } else {
                            // Pads: Rich detuned oscillators
                            this.createPadSound(mixer, preset, now);
                        }
                        
                        // Apply filter - SOFT CLOUD-LIKE (very gentle, no definition)
                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'lowpass';
                        // Very low cutoff for soft cloud-like sound - remove most high frequencies
                        const filterBaseFreq = Math.min(preset.filterCutoff || 4000, 1800); // Much lower - cap at 1.8kHz for soft clouds
                        filter.Q.value = Math.min(preset.filterQ || 1, 0.3); // Very low Q for soft, diffused response
                        
                        // Filter envelope for gentle cloud-like movement (very soft, no sharp changes)
                        const filterAttack = preset.attack || 1.5;
                        const filterDecay = preset.decay || 3.0;
                        // Start very low, open very gently, stay soft
                        filter.frequency.setValueAtTime(filterBaseFreq * 0.4, now); // Start very closed
                        filter.frequency.linearRampToValueAtTime(filterBaseFreq * 0.7, now + filterAttack); // Very gentle open
                        filter.frequency.setValueAtTime(filterBaseFreq * 0.65, now + filterAttack + filterDecay);
                        filter.frequency.linearRampToValueAtTime(filterBaseFreq * 0.5, now + this.duration * 0.7); // Close very gently
                        
                        mixer.connect(filter);
                        this.nodes.push(filter);
                        
                        // ADSR envelope - VERY SOFT CLOUD-LIKE fade (no clicks, very gentle)
                        const envelope = audioContext.createGain();
                        // Much longer attack/release for soft cloud-like fade
                        const attack = Math.max(preset.attack || 1.5, 3.0); // Minimum 3 seconds for soft fade in
                        const decay = preset.decay || 3.0;
                        const sustain = preset.sustain || 0.7;
                        const release = Math.max(preset.release || 4.0, 5.0); // Minimum 5 seconds for soft fade out
                        
                        // Calculate stop time
                        this.stopTime = now + this.duration + release;
                        
                        // Use exponential curves with VERY gentle fade - NO CLICKS, smooth transitions
                        const minGain = 0.00001; // Extremely low to avoid clicks
                        envelope.gain.setValueAtTime(minGain, now); // Start from extremely low value
                        // VERY smooth exponential attack - very long, very gentle, NO CLICKS
                        envelope.gain.exponentialRampToValueAtTime(this.velocity * 0.2, now + attack * 0.3); // Very slow start
                        envelope.gain.exponentialRampToValueAtTime(this.velocity * 0.5, now + attack * 0.6); // Gradual rise
                        envelope.gain.exponentialRampToValueAtTime(this.velocity, now + attack); // Full fade in
                        // Gentle decay with smooth transition
                        envelope.gain.exponentialRampToValueAtTime(this.velocity * sustain, now + attack + decay);
                        // Sustain phase - hold steady
                        envelope.gain.setValueAtTime(this.velocity * sustain, now + this.duration - release);
                        // VERY smooth exponential release - very long, very gentle fade out, NO CLICKS
                        envelope.gain.exponentialRampToValueAtTime(this.velocity * sustain * 0.5, now + this.duration - release * 0.7); // Start fade early
                        envelope.gain.exponentialRampToValueAtTime(this.velocity * sustain * 0.2, now + this.duration - release * 0.4); // Continue fade
                        envelope.gain.exponentialRampToValueAtTime(minGain, this.stopTime); // Complete fade out
                        
                        filter.connect(envelope);
                        this.nodes.push(envelope);
                        
                        // STEREO PANNING for spatialization - random pan for each voice
                        const panner = audioContext.createStereoPanner();
                        // Random pan position (-1 to 1) for spatial spread
                        const panPosition = (Math.random() * 2 - 1) * 0.6; // Spread but not extreme
                        panner.pan.value = panPosition;
                        envelope.connect(panner);
                        this.nodes.push(panner);
                        
                        // Create and connect reverb (CRITICAL for ambient space)
                        const reverb = this.createReverb(audioContext);
                        
                        // Delay for ambient trails - CATHEDRAL delays with stereo spread
                        const delay = audioContext.createDelay(4.0); // Very long delay buffer for cathedral
                        const delayGain = audioContext.createGain();
                        const feedbackGain = audioContext.createGain();
                        const delayFilter = audioContext.createBiquadFilter();
                        const delayPanner = audioContext.createStereoPanner(); // Stereo delay panning
                        
                        delay.delayTime.value = 1.2; // Very long delay time (1200ms) for cathedral
                        delayGain.gain.value = 0.8; // Much more delay mix
                        feedbackGain.gain.value = 0.5; // More feedback for cathedral echoes
                        delayFilter.type = 'lowpass';
                        delayFilter.frequency.value = 1500; // Much darker for soft cloud-like sound
                        delayFilter.Q.value = 0.4; // Very soft filter
                        delayPanner.pan.value = -panPosition * 0.7; // Opposite pan for spatial width
                        
                        // Connect: envelope -> panner -> [single path to reverb] -> master
                        // IMPORTANT: Prevent double layers - send signal to reverb only once
                        // Create a splitter to send signal to dry and wet paths properly
                        const reverbInputGain = audioContext.createGain();
                        reverbInputGain.gain.value = 1.0;
                        panner.connect(reverbInputGain);
                        
                        // Send to reverb wet path (convolver) - this is the main reverb
                        reverbInputGain.connect(reverb.convolver);
                        
                        // Send to reverb dry path (for dry signal mix)
                        reverbInputGain.connect(reverb.dryGain);
                        
                        // Delay path for ambient trails (separate, goes to reverb wet only)
                        panner.connect(delay); // Delay path (panned)
                        delay.connect(delayFilter);
                        delayFilter.connect(delayPanner); // Pan the delay
                        delayPanner.connect(feedbackGain);
                        feedbackGain.connect(delay); // Feedback
                        delay.connect(delayGain);
                        delayGain.connect(reverb.convolver); // Delay trails go to reverb wet path only
                        
                        reverb.output.connect(this.masterGain);
                        
                        this.nodes.push(reverbInputGain);
                        
                        this.nodes.push(delayPanner);
                        
                        this.nodes.push(envelope, delay, delayGain, feedbackGain, delayFilter);
                        this.nodes.push(reverb.dryGain, reverb.convolver, reverb.output, reverb.reverbGain, reverb.reverbFilter);
                        
                        // Store for cleanup
                        this.envelope = envelope;
                        
                        // Schedule oscillators to stop smoothly at the correct time (after envelope fades out)
                        // Stop oscillators AFTER the envelope has fully faded to prevent clicks
                        setTimeout(() => {
                            const stopDelay = 0.1; // Small delay after envelope fade to ensure smooth stop
                            this.oscillators.forEach(osc => {
                                try {
                                    // Stop after envelope has fully faded
                                    osc.stop(this.stopTime + stopDelay);
                                } catch (e) {
                                    // If stop time is in the past, stop immediately but gently
                                    try {
                                        // Cancel any scheduled stops and stop now
                                        osc.stop();
                                    } catch (e2) {}
                                }
                            });
                        }, 0);
                    }
                    
                    createPadSound(mixer, preset, now) {
                        // Warm pad: Use triangle/sine instead of sawtooth for smoothness
                        const osc1 = this.audioContext.createOscillator();
                        const osc2 = this.audioContext.createOscillator();
                        const osc3 = this.audioContext.createOscillator();
                        
                        // Prefer triangle/sine over sawtooth for warmth (sawtooth has sharp edges)
                        const osc1Type = preset.osc1Type === 'sawtooth' ? 'triangle' : (preset.osc1Type || 'triangle');
                        const osc2Type = preset.osc2Type === 'sawtooth' ? 'triangle' : (preset.osc2Type || 'triangle');
                        osc1.type = osc1Type;
                        osc2.type = osc2Type;
                        osc3.type = 'triangle'; // Sub-octave for body
                        
                        // Gentle detune in cents (less detune = warmer)
                        const detune1Cents = (preset.detune1 || 0) * 80; // Slightly less detune
                        const detune2Cents = (preset.detune2 || 0) * 80;
                        osc1.frequency.value = this.freq * Math.pow(2, detune1Cents / 1200);
                        osc2.frequency.value = this.freq * Math.pow(2, detune2Cents / 1200);
                        osc3.frequency.value = this.freq * 0.5;
                        
                        const osc1Gain = this.audioContext.createGain();
                        const osc2Gain = this.audioContext.createGain();
                        const osc3Gain = this.audioContext.createGain();
                        
                        osc1Gain.gain.value = 0.35 * this.velocity;
                        osc2Gain.gain.value = 0.35 * this.velocity;
                        osc3Gain.gain.value = 0.3 * this.velocity;
                        
                        osc1.connect(osc1Gain);
                        osc2.connect(osc2Gain);
                        osc3.connect(osc3Gain);
                        osc1Gain.connect(mixer);
                        osc2Gain.connect(mixer);
                        osc3Gain.connect(mixer);
                        
                        osc1.start(now);
                        osc2.start(now);
                        osc3.start(now);
                        
                        this.oscillators.push(osc1, osc2, osc3);
                        this.nodes.push(osc1, osc2, osc3, osc1Gain, osc2Gain, osc3Gain);
                    }
                    
                    createFluteSound(mixer, preset, now) {
                        // Soft cloud flute: Sine oscillator only + very gentle breath noise
                        const osc = this.audioContext.createOscillator();
                        // Use ONLY sine for soft cloud-like sound
                        osc.type = 'sine';
                        osc.frequency.value = this.freq;
                        
                        // Very gentle vibrato (very soft, cloud-like)
                        if (preset.vibratoSpeed && preset.vibratoSpeed > 0) {
                            const lfo = this.audioContext.createOscillator();
                            const lfoGain = this.audioContext.createGain();
                            lfo.type = 'sine';
                            lfo.frequency.value = preset.vibratoSpeed || 6;
                            // Much reduced vibrato depth for soft clouds
                            lfoGain.gain.value = (preset.vibratoDepth || 2) * this.freq / 200; // Very soft vibrato
                            lfo.connect(lfoGain);
                            lfoGain.connect(osc.frequency);
                            lfo.start(now);
                            this.nodes.push(lfo, lfoGain);
                        }
                        
                        // Very gentle breath noise (very soft, heavily filtered)
                        const noiseBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.1, this.audioContext.sampleRate);
                        const noiseData = noiseBuffer.getChannelData(0);
                        for (let i = 0; i < noiseData.length; i++) {
                            noiseData[i] = (Math.random() * 2 - 1) * 0.5; // Much softer noise
                        }
                        const noise = this.audioContext.createBufferSource();
                        noise.buffer = noiseBuffer;
                        noise.loop = true;
                        const noiseFilter = this.audioContext.createBiquadFilter();
                        noiseFilter.type = 'bandpass';
                        noiseFilter.frequency.value = 1200; // Much lower frequency for softness
                        noiseFilter.Q.value = 0.8; // Very soft Q
                        const noiseGain = this.audioContext.createGain();
                        noiseGain.gain.setValueAtTime(0.03 * this.velocity, now); // Much less noise
                        noiseGain.gain.linearRampToValueAtTime(0, now + (preset.attack || 0.15) * 0.6);
                        
                        osc.connect(mixer);
                        noise.connect(noiseFilter);
                        noiseFilter.connect(noiseGain);
                        noiseGain.connect(mixer);
                        
                        osc.start(now);
                        noise.start(now);
                        
                        this.oscillators.push(osc);
                        this.nodes.push(osc, noise, noiseFilter, noiseGain);
                    }
                    
                    createDroneSound(mixer, preset, now) {
                        // Soft cloud drone: ONLY sine waves for maximum softness
                        const osc1 = this.audioContext.createOscillator();
                        const osc2 = this.audioContext.createOscillator();
                        const osc3 = this.audioContext.createOscillator();
                        
                        // Use ONLY sine waves for soft cloud-like sound
                        osc1.type = 'sine';
                        osc2.type = 'sine';
                        osc3.type = 'sine';
                        
                        osc1.frequency.value = this.freq;
                        osc2.frequency.value = this.freq * 2;
                        osc3.frequency.value = this.freq * 0.5;
                        
                        const osc1Gain = this.audioContext.createGain();
                        const osc2Gain = this.audioContext.createGain();
                        const osc3Gain = this.audioContext.createGain();
                        
                        // Softer levels for cloud-like sound
                        osc1Gain.gain.value = 0.35 * this.velocity;
                        osc2Gain.gain.value = 0.25 * this.velocity;
                        osc3Gain.gain.value = 0.25 * this.velocity;
                        
                        osc1.connect(osc1Gain);
                        osc2.connect(osc2Gain);
                        osc3.connect(osc3Gain);
                        osc1Gain.connect(mixer);
                        osc2Gain.connect(mixer);
                        osc3Gain.connect(mixer);
                        
                        osc1.start(now);
                        osc2.start(now);
                        osc3.start(now);
                        
                        this.oscillators.push(osc1, osc2, osc3);
                        this.nodes.push(osc1, osc2, osc3, osc1Gain, osc2Gain, osc3Gain);
                    }
                    
                    createBowlSound(mixer, preset, now) {
                        // Soft cloud bowl: Reduced harmonics for softness
                        const harmonics = [
                            { freqRatio: 1.0, amplitude: 0.6 },
                            { freqRatio: 2.0, amplitude: 0.25 },
                            { freqRatio: 3.0, amplitude: 0.1 },
                            { freqRatio: 4.0, amplitude: 0.05 }
                            // Removed higher harmonics for softness
                        ];
                        
                        harmonics.forEach(harmonic => {
                            const osc = this.audioContext.createOscillator();
                            osc.type = 'sine'; // Only sine waves
                            osc.frequency.value = this.freq * harmonic.freqRatio;
                            const oscGain = this.audioContext.createGain();
                            oscGain.gain.value = harmonic.amplitude * this.velocity;
                            osc.connect(oscGain);
                            oscGain.connect(mixer);
                            osc.start(now);
                            this.oscillators.push(osc);
                            this.nodes.push(osc, oscGain);
                        });
                    }
                    
                    createNoiseBed(mixer, preset, now) {
                        // Noise bed: Pink noise with filters
                        const bufferSize = this.audioContext.sampleRate * 2;
                        const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                        const data = buffer.getChannelData(0);
                        let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                        for (let i = 0; i < bufferSize; i++) {
                            const white = Math.random() * 2 - 1;
                            b0 = 0.99886 * b0 + white * 0.0555179;
                            b1 = 0.99332 * b1 + white * 0.0750759;
                            b2 = 0.96900 * b2 + white * 0.1538520;
                            b3 = 0.86650 * b3 + white * 0.3104856;
                            b4 = 0.55000 * b4 + white * 0.5329522;
                            b5 = -0.7616 * b5 - white * 0.0168980;
                            const pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                            b6 = white * 0.115926;
                            data[i] = pink * 0.11;
                        }
                        
                        const noise = this.audioContext.createBufferSource();
                        noise.buffer = buffer;
                        noise.loop = true;
                        
                        const filter1 = this.audioContext.createBiquadFilter();
                        filter1.type = 'bandpass';
                        filter1.frequency.value = this.freq || 500;
                        filter1.Q.value = 2;
                        
                        const filter2 = this.audioContext.createBiquadFilter();
                        filter2.type = 'bandpass';
                        filter2.frequency.value = (this.freq || 500) * 1.5;
                        filter2.Q.value = 1.5;
                        
                        noise.connect(filter1);
                        noise.connect(filter2);
                        filter1.connect(mixer);
                        filter2.connect(mixer);
                        
                        noise.start(now);
                        
                        this.nodes.push(noise, filter1, filter2);
                    }
                    
                    createReverb(audioContext) {
                        // Create shorter reverb - more controlled tail
                        const convolver = audioContext.createConvolver();
                        const reverbGain = audioContext.createGain();
                        const dryGain = audioContext.createGain();
                        const reverbFilter = audioContext.createBiquadFilter();
                        
                        const sampleRate = audioContext.sampleRate;
                        const length = sampleRate * 3.0; // Shorter reverb (3 seconds)
                        const impulse = audioContext.createBuffer(2, length, sampleRate);
                        
                        // Generate rich SPATIAL impulse response for CATHEDRAL/CHURCH with stereo width
                        // SMOOTHED to prevent clicks - fade in the impulse response
                        for (let channel = 0; channel < 2; channel++) {
                            const channelData = impulse.getChannelData(channel);
                            const channelPhase = channel === 0 ? 0 : Math.PI * 0.3; // Slight phase difference for stereo width
                            
                            // Smooth fade-in window for first 10ms to prevent clicks
                            const fadeInSamples = Math.floor(sampleRate * 0.01); // 10ms fade-in
                            
                            for (let i = 0; i < length; i++) {
                                const n = length - i;
                                const t = i / sampleRate;
                                
                                // Fade-in envelope to prevent clicks at start
                                const fadeIn = i < fadeInSamples ? i / fadeInSamples : 1.0;
                                
                                // Early reflections (first 300ms) - cathedral has distinct early reflections
                                let earlyReflections = 0;
                                if (t < 0.3) {
                                    const earlyTime = t * 3.33;
                                    // Multiple early reflection patterns for cathedral with stereo phase
                                    earlyReflections = (
                                        Math.sin(earlyTime * Math.PI * 3 + channelPhase) * Math.exp(-earlyTime * 2) * 0.6 +
                                        Math.sin(earlyTime * Math.PI * 6 + channelPhase * 1.5) * Math.exp(-earlyTime * 4) * 0.4 +
                                        Math.sin(earlyTime * Math.PI * 12 + channelPhase * 2) * Math.exp(-earlyTime * 8) * 0.2
                                    );
                                }
                                
                                // Main reverb tail - faster decay for shorter reverb
                                const decay = Math.pow(n / length, 1.2); // Faster decay for shorter tail
                                const noise = (Math.random() * 2 - 1) * 0.7; // More noise for spatial diffusion
                                const spatialMod = Math.sin(t * 0.5 + channelPhase) * 0.2; // Slow spatial modulation
                                const tail = decay * (1.0 + noise + spatialMod);
                                
                                // Combine with strong amplitude for VERY audible, SPATIAL reverb
                                // Apply fade-in to prevent clicks
                                channelData[i] = (earlyReflections + tail) * 1.6 * fadeIn;
                            }
                        }
                        
                        convolver.buffer = impulse;
                        reverbFilter.type = 'lowpass';
                        reverbFilter.frequency.value = 3000; // Much darker for soft cloud-like sound
                        reverbFilter.Q.value = 0.3; // Very soft filter
                        
                        // VERY strong reverb mix - SOFT CLOUD sound (mostly reverb, diffused)
                        reverbGain.gain.value = 2.5; // Strong reverb level for cloud-like diffusion
                        dryGain.gain.value = 0.15; // Very little dry signal - mostly soft reverb cloud (reduced to prevent doubling)
                        
                        const output = audioContext.createGain();
                        convolver.connect(reverbFilter);
                        reverbFilter.connect(reverbGain);
                        reverbGain.connect(output);
                        dryGain.connect(output);
                        
                        console.log('ðŸ›ï¸ Cathedral reverb created: length=', length/sampleRate, 's, reverbGain=', reverbGain.gain.value, 'dryGain=', dryGain.gain.value);
                        
                        return {
                            dryGain: dryGain,
                            convolver: convolver,
                            output: output,
                            reverbGain: reverbGain,
                            reverbFilter: reverbFilter
                        };
                    }
                    
                    release() {
                        const now = this.audioContext.currentTime;
                        const releaseTime = this.preset.release || 1.5;
                        if (this.envelope && now < this.stopTime) {
                            this.envelope.gain.cancelScheduledValues(now);
                            this.envelope.gain.setValueAtTime(this.envelope.gain.value, now);
                            this.envelope.gain.linearRampToValueAtTime(0, now + releaseTime);
                        }
                    }
                    
                    stop() {
                        const now = this.audioContext.currentTime;
                        // Stop all oscillators immediately
                        this.oscillators.forEach(osc => {
                            try {
                                if (osc.stop) {
                                    osc.stop(now);
                                }
                            } catch (e) {
                                // Already stopped or error, try without time
                                try {
                                    osc.stop();
                                } catch (e2) {}
                            }
                        });
                        // Disconnect all nodes
                        this.nodes.forEach(node => {
                            try {
                                if (node.stop) {
                                    try {
                                        node.stop(now);
                                    } catch (e) {
                                        node.stop();
                                    }
                                }
                                if (node.disconnect) {
                                    node.disconnect();
                                }
                            } catch (e) {}
                        });
                        // Mark as disposed
                        this.isDisposed = true;
                    }
                }
                
                // Load function for synth presets
                const loadSynthPresetByName = (presetName, skipSlaveUpdate = false) => {
                    const preset = synthPresets.find(p => p.name === presetName);
                    if (!preset) {
                        console.warn('Preset not found:', presetName);
                        return;
                    }
                    const oldPresetName = currentPresetName.value;
                    currentPresetName.value = presetName;
                    console.log('ðŸŽµ Loaded sound preset:', presetName, 'Type:', preset.type);
                    
                    // If master and not skipping update, send preset update to slaves
                    if (!isSlave && !skipSlaveUpdate) {
                        if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                            sendPresetToSlaves();
                        } else {
                            // Retry when WebSocket becomes ready
                            const checkWs = setInterval(() => {
                                if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                    sendPresetToSlaves();
                                    clearInterval(checkWs);
                                }
                            }, 100);
                            setTimeout(() => clearInterval(checkWs), 5000);
                        }
                    }
                };
                
                // 10 Comprehensive Presets - Each includes sound, length, pause, scale, reference pitch
                const predefinedPresets = [
                    {
                        name: '1 â€¢ Original Sine â€¢ G Minor Pentatonic â€¢ 440Hz',
                        description: 'Default preset - G minor pentatonic scale',
                        settings: { noteLength: 5, pauseLength: 5, referencePitch: 440 },
                        soundPreset: 'Original Sine',
                        notes: [
                            { note: 'G3', freq: 196.00, color: '#1e3a8a', volume: 80, enabled: true, centsOffset: 0 },
                            { note: 'Bb3', freq: 233.08, color: '#4f46e5', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'C4', freq: 261.63, color: '#9333ea', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'Eb4', freq: 311.13, color: '#ec4899', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'F4', freq: 349.23, color: '#ef4444', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'G4', freq: 392.00, color: '#f97316', volume: 65, enabled: true, centsOffset: 0 },
                            { note: 'Bb4', freq: 466.16, color: '#f59e0b', volume: 65, enabled: true, centsOffset: 0 },
                            { note: 'C5', freq: 523.25, color: '#10b981', volume: 60, enabled: true, centsOffset: 0 },
                            { note: 'D5', freq: 587.33, color: '#06b6d4', volume: 60, enabled: true, centsOffset: 0 }
                        ]
                    },
                    {
                        name: '3 â€¢ Warm Flute â€¢ C Major â€¢ 440Hz',
                        description: 'Warm flute sound - C major scale, longer notes',
                        settings: { noteLength: 6, pauseLength: 4, referencePitch: 440 },
                        soundPreset: 'Warm Flute',
                        notes: [
                            { note: 'C4', freq: 261.63, color: '#3b82f6', volume: 85, enabled: true, centsOffset: 0 },
                            { note: 'D4', freq: 293.66, color: '#60a5fa', volume: 80, enabled: true, centsOffset: 0 },
                            { note: 'E4', freq: 329.63, color: '#93c5fd', volume: 80, enabled: true, centsOffset: 0 },
                            { note: 'F4', freq: 349.23, color: '#a5b4fc', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'G4', freq: 392.00, color: '#c7d2fe', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'A4', freq: 440.00, color: '#dbeafe', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'B4', freq: 493.88, color: '#e0e7ff', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'C5', freq: 523.25, color: '#ede9fe', volume: 65, enabled: true, centsOffset: 0 }
                        ]
                    },
                    {
                        name: '4 â€¢ Tibetan Singing Bowl â€¢ D Harmonic Minor â€¢ 432Hz',
                        description: 'Tibetan singing bowls - D harmonic minor, 432Hz tuning',
                        settings: { noteLength: 7, pauseLength: 6, referencePitch: 432 },
                        soundPreset: 'Tibetan Singing Bowl',
                        notes: [
                            { note: 'D4', freq: 290.20, color: '#dc2626', volume: 80, enabled: true, centsOffset: 0 },
                            { note: 'E4', freq: 325.63, color: '#ea580c', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'F4', freq: 345.00, color: '#f59e0b', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'G4', freq: 387.65, color: '#eab308', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'A4', freq: 432.00, color: '#84cc16', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'Bb4', freq: 460.25, color: '#22c55e', volume: 65, enabled: true, centsOffset: 0 },
                            { note: 'C#5', freq: 547.50, color: '#10b981', volume: 65, enabled: true, centsOffset: 0 },
                            { note: 'D5', freq: 580.40, color: '#14b8a6', volume: 60, enabled: true, centsOffset: 0 }
                        ]
                    },
                    {
                        name: '5 â€¢ Meditative Space â€¢ F Major â€¢ 440Hz',
                        description: 'Soft ambient pad - F major, slow and peaceful',
                        settings: { noteLength: 8, pauseLength: 7, referencePitch: 440 },
                        soundPreset: 'Meditative Space',
                        notes: [
                            { note: 'F3', freq: 174.61, color: '#0ea5e9', volume: 85, enabled: true, centsOffset: 0 },
                            { note: 'G3', freq: 196.00, color: '#38bdf8', volume: 80, enabled: true, centsOffset: 0 },
                            { note: 'A3', freq: 220.00, color: '#7dd3fc', volume: 80, enabled: true, centsOffset: 0 },
                            { note: 'Bb3', freq: 233.08, color: '#bae6fd', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'C4', freq: 261.63, color: '#dbeafe', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'D4', freq: 293.66, color: '#e0e7ff', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'E4', freq: 329.63, color: '#ede9fe', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'F4', freq: 349.23, color: '#f3e8ff', volume: 65, enabled: true, centsOffset: 0 }
                        ]
                    },
                    {
                        name: '6 â€¢ Breath Flute â€¢ A Minor â€¢ 440Hz',
                        description: 'Breathy flute - A minor scale, natural flow',
                        settings: { noteLength: 4, pauseLength: 3, referencePitch: 440 },
                        soundPreset: 'Breath Flute',
                        notes: [
                            { note: 'A3', freq: 220.00, color: '#7c3aed', volume: 80, enabled: true, centsOffset: 0 },
                            { note: 'B3', freq: 246.94, color: '#8b5cf6', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'C4', freq: 261.63, color: '#a78bfa', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'D4', freq: 293.66, color: '#c4b5fd', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'E4', freq: 329.63, color: '#ddd6fe', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'F4', freq: 349.23, color: '#ede9fe', volume: 65, enabled: true, centsOffset: 0 },
                            { note: 'G4', freq: 392.00, color: '#f3e8ff', volume: 65, enabled: true, centsOffset: 0 },
                            { note: 'A4', freq: 440.00, color: '#faf5ff', volume: 60, enabled: true, centsOffset: 0 }
                        ]
                    },
                    {
                        name: '7 â€¢ Deep Earth Drone â€¢ E Minor â€¢ 432Hz',
                        description: 'Deep ambient drone - E minor, 432Hz, very slow',
                        settings: { noteLength: 10, pauseLength: 8, referencePitch: 432 },
                        soundPreset: 'Deep Earth Drone',
                        notes: [
                            { note: 'E3', freq: 162.74, color: '#1e40af', volume: 85, enabled: true, centsOffset: 0 },
                            { note: 'F#3', freq: 182.67, color: '#1e3a8a', volume: 80, enabled: true, centsOffset: 0 },
                            { note: 'G3', freq: 193.57, color: '#312e81', volume: 80, enabled: true, centsOffset: 0 },
                            { note: 'A3', freq: 216.00, color: '#4c1d95', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'B3', freq: 243.00, color: '#581c87', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'C4', freq: 258.65, color: '#6b21a8', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'D4', freq: 290.20, color: '#7c2d12', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'E4', freq: 325.26, color: '#991b1b', volume: 65, enabled: true, centsOffset: 0 }
                        ]
                    },
                    {
                        name: '8 â€¢ Crystal Bowl â€¢ G Major â€¢ 440Hz',
                        description: 'Crystal singing bowls - G major, bright and clear',
                        settings: { noteLength: 5, pauseLength: 4, referencePitch: 440 },
                        soundPreset: 'Crystal Bowl',
                        notes: [
                            { note: 'G3', freq: 196.00, color: '#059669', volume: 85, enabled: true, centsOffset: 0 },
                            { note: 'A3', freq: 220.00, color: '#10b981', volume: 80, enabled: true, centsOffset: 0 },
                            { note: 'B3', freq: 246.94, color: '#34d399', volume: 80, enabled: true, centsOffset: 0 },
                            { note: 'C4', freq: 261.63, color: '#6ee7b7', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'D4', freq: 293.66, color: '#a7f3d0', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'E4', freq: 329.63, color: '#d1fae5', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'F#4', freq: 369.99, color: '#ecfdf5', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'G4', freq: 392.00, color: '#f0fdf4', volume: 65, enabled: true, centsOffset: 0 }
                        ]
                    },
                    {
                        name: '9 â€¢ Shakuhachi Flute â€¢ A Harmonic Minor â€¢ 432Hz',
                        description: 'Japanese shakuhachi - A harmonic minor, 432Hz',
                        settings: { noteLength: 6, pauseLength: 5, referencePitch: 432 },
                        soundPreset: 'Shakuhachi Flute',
                        notes: [
                            { note: 'A3', freq: 216.00, color: '#065f46', volume: 80, enabled: true, centsOffset: 0 },
                            { note: 'B3', freq: 243.00, color: '#047857', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'C4', freq: 258.65, color: '#059669', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'D4', freq: 290.20, color: '#10b981', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'E4', freq: 325.26, color: '#34d399', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'F4', freq: 345.00, color: '#6ee7b7', volume: 65, enabled: true, centsOffset: 0 },
                            { note: 'G#4', freq: 410.00, color: '#a7f3d0', volume: 65, enabled: true, centsOffset: 0 },
                            { note: 'A4', freq: 432.00, color: '#d1fae5', volume: 60, enabled: true, centsOffset: 0 }
                        ]
                    },
                    {
                        name: '10 â€¢ Ethereal Cloud â€¢ B Minor â€¢ 440Hz',
                        description: 'Soft cloud pad - B minor pentatonic, floating',
                        settings: { noteLength: 7, pauseLength: 6, referencePitch: 440 },
                        soundPreset: 'Ethereal Cloud',
                        notes: [
                            { note: 'B3', freq: 246.94, color: '#7c2d12', volume: 80, enabled: true, centsOffset: 0 },
                            { note: 'C#4', freq: 277.18, color: '#991b1b', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'D4', freq: 293.66, color: '#b91c1c', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'E4', freq: 329.63, color: '#dc2626', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'F#4', freq: 369.99, color: '#ef4444', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'G4', freq: 392.00, color: '#f87171', volume: 65, enabled: true, centsOffset: 0 },
                            { note: 'A4', freq: 440.00, color: '#fca5a5', volume: 65, enabled: true, centsOffset: 0 },
                            { note: 'B4', freq: 493.88, color: '#fecaca', volume: 60, enabled: true, centsOffset: 0 }
                        ]
                    },
                    {
                        name: '11 â€¢ Temple Bell â€¢ C# Harmonic Minor â€¢ 440Hz',
                        description: 'Temple bell tones - C# harmonic minor, mystical',
                        settings: { noteLength: 5, pauseLength: 4, referencePitch: 440 },
                        soundPreset: 'Temple Bell',
                        notes: [
                            { note: 'C#4', freq: 277.18, color: '#78350f', volume: 80, enabled: true, centsOffset: 0 },
                            { note: 'D#4', freq: 311.13, color: '#92400e', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'E4', freq: 329.63, color: '#a16207', volume: 75, enabled: true, centsOffset: 0 },
                            { note: 'F#4', freq: 369.99, color: '#ca8a04', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'G#4', freq: 415.30, color: '#eab308', volume: 70, enabled: true, centsOffset: 0 },
                            { note: 'A4', freq: 440.00, color: '#facc15', volume: 65, enabled: true, centsOffset: 0 },
                            { note: 'B#4', freq: 493.88, color: '#fde047', volume: 65, enabled: true, centsOffset: 0 },
                            { note: 'C#5', freq: 554.37, color: '#fef08a', volume: 60, enabled: true, centsOffset: 0 }
                        ]
                    },
                ];
                
                const currentNotePreset = ref('1 â€¢ Original Sine â€¢ G Minor Pentatonic â€¢ 440Hz');
                
                // Tutorial system
                const showTutorial = ref(false);
                const currentTutorialSection = ref('getting-started');
                
                // Update fade gradients on tutorial nav scroll
                const updateTutorialFade = () => {
                    const nav = document.getElementById('tutorial-nav');
                    const leftFade = document.getElementById('tutorial-left-fade');
                    if (nav && leftFade) {
                        const scrollLeft = nav.scrollLeft;
                        leftFade.style.opacity = scrollLeft > 10 ? '1' : '0';
                    }
                };
                
                // Tutorial Sections
                const tutorialSections = [
                    {
                        id: 'getting-started',
                        title: 'Getting Started',
                        content: `
                            <h2 class="text-white text-lg font-semibold mb-3 mt-6" style="font-size: 18px;">Welcome to Soundflakes</h2>
                            <p style="font-size: 14px;">Soundflakes is a collaborative sound installation app that allows multiple devices to work together to create ambient, meditative soundscapes.</p>
                            
                            <h3 class="text-white font-semibold mb-2 mt-4" style="font-size: 16px;">Basic Concepts</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li><strong>Master Device:</strong> The main device that controls the sound generation and distributes notes to slave devices</li>
                                <li><strong>Slave Devices:</strong> Additional devices that play assigned notes, creating a distributed soundscape</li>
                                <li><strong>Notes:</strong> Individual musical notes that can be enabled/disabled and have adjustable volume</li>
                                <li><strong>Presets:</strong> Pre-configured sets of notes, scales, and sound settings</li>
                            </ul>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Quick Start</h3>
                            <ol class="list-decimal list-inside space-y-2 ml-4">
                                <li>Open the app on your master device</li>
                                <li>Click the <strong>Play</strong> button (â–¶) to start generating sounds</li>
                                <li>Adjust the <strong>Length</strong> and <strong>Pause</strong> knobs to control timing</li>
                                <li>Use the <strong>Volume</strong> knob to adjust overall volume</li>
                                <li>Select different sound presets from the dropdown</li>
                            </ol>
                            <div class="mt-4 apple-input p-4 rounded-lg">
                                <img src="tutorial-screenshots/main-interface.png" alt="Main interface showing Play button, knobs, and controls" 
                                     class="w-full rounded border border-gray-600" 
                                     onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                                <div class="w-full h-48 rounded flex items-center justify-center text-gray-500" style="display: none; background: rgba(255, 255, 255, 0.05);">
                                    <p class="text-gray-400 text-sm">ðŸ“¸ Screenshot: Main interface showing Play button, knobs, and controls</p>
                                </div>
                            </div>
                        `
                    },
                    {
                        id: 'master-device',
                        title: 'Master Device',
                        content: `
                            <h2 class="text-white text-xl font-semibold mb-3 mt-6">Master Device Setup</h2>
                            <p>The master device is the central controller for your Soundflakes installation.</p>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Master Controls</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li><strong>Play Button:</strong> Starts/stops the sound generation</li>
                                <li><strong>Length Knob:</strong> Controls how long each note plays (default: 5 seconds Â± 2 seconds randomness)</li>
                                <li><strong>Pause Knob:</strong> Controls the pause between notes (default: 5 seconds Â± 2 seconds randomness)</li>
                                <li><strong>Volume Knob:</strong> Master volume control (0-100%)</li>
                                <li><strong>QR Code Button:</strong> Shows QR code for slave devices to connect</li>
                            </ul>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Note Distribution</h3>
                            <p>When slave devices connect, the master automatically distributes notes among all devices (including itself if "Include master in note distribution" is enabled).</p>
                            <p class="mt-2">Each device plays only its assigned notes, creating a distributed soundscape where different devices contribute different parts of the musical pattern.</p>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Master Volume Control</h3>
                            <p>You can control the volume of each connected slave device individually using the "Sound Flakes Volumes" section. Adjust sliders to balance the sound across all devices.</p>
                            <div class="mt-4 apple-input p-4 rounded-lg">
                                <img src="tutorial-screenshots/master-controls.png" alt="Master controls menu" 
                                     class="w-full rounded border border-gray-600" 
                                     onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                                <div class="w-full h-48 rounded flex items-center justify-center text-gray-500" style="display: none; background: rgba(255, 255, 255, 0.05);">
                                    <p class="text-gray-400 text-sm">ðŸ“¸ Screenshot: Master controls menu showing Play button, Length/Pause knobs, Volume knob, and QR Code button</p>
                                </div>
                            </div>
                        `
                    },
                    {
                        id: 'slave-devices',
                        title: 'Slave Devices',
                        content: `
                            <h2 class="text-white text-xl font-semibold mb-3 mt-6">Connecting Slave Devices</h2>
                            <p>Slave devices connect to the master and play assigned notes, creating a collaborative soundscape.</p>
                            <p class="mt-2"><strong>Any device with an internet browser can function as a slave device:</strong> phones, tablets, laptops, smart TVs, and more. As long as the device can access the web and has audio output, it can participate in the sound installation.</p>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">How to Connect</h3>
                            <ol class="list-decimal list-inside space-y-2 ml-4">
                                <li>On the master device, click the <strong>QR Code</strong> button</li>
                                <li>Scan the QR code with your slave device's camera</li>
                                <li>The slave device will automatically open the app and connect</li>
                                <li>Wait for the connection indicator to turn green</li>
                                <li>The slave will receive assigned notes and start playing</li>
                            </ol>
                            <div class="mt-4 apple-input p-4 rounded-lg">
                                <img src="tutorial-screenshots/qr-code-display.png" alt="QR Code overlay" 
                                     class="w-full rounded border border-gray-600" 
                                     onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                                <div class="w-full h-48 rounded flex items-center justify-center text-gray-500" style="display: none; background: rgba(255, 255, 255, 0.05);">
                                    <p class="text-gray-400 text-sm">ðŸ“¸ Screenshot: QR Code overlay showing the QR code for slave devices to scan</p>
                                </div>
                            </div>
                            <div class="mt-4 apple-input p-4 rounded-lg">
                                <img src="tutorial-screenshots/slave-status-indicator.png" alt="Slave device status indicator" 
                                     class="w-full rounded border border-gray-600" 
                                     onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                                <div class="w-full h-32 rounded flex items-center justify-center text-gray-500" style="display: none; background: rgba(255, 255, 255, 0.05);">
                                    <p class="text-gray-400 text-sm">ðŸ“¸ Screenshot: Slave device status indicator showing connection status</p>
                                </div>
                            </div>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Slave Device Features</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li><strong>Status Indicator:</strong> Shows connection status (red = disconnected, green = connected with notes)</li>
                                <li><strong>Assigned Notes Display:</strong> Shows which notes this device is playing</li>
                                <li><strong>Volume Control:</strong> Individual volume control for the slave device</li>
                                <li><strong>Auto-play:</strong> Automatically starts playing when connected and notes are assigned</li>
                            </ul>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Network Requirements</h3>
                            <p>All devices must be on the same Wi-Fi network. The master device's IP address is embedded in the QR code.</p>
                            <p class="mt-2 text-yellow-300">âš ï¸ Make sure your firewall allows connections on port 3000</p>
                        `
                    },
                    {
                        id: 'sound-presets',
                        title: 'Sound Presets',
                        content: `
                            <h2 class="text-white text-xl font-semibold mb-3 mt-6">Sound Presets</h2>
                            <p>Sound presets control the timbre and character of the sounds being generated.</p>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Available Presets</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li><strong>Original Sine:</strong> Pure sine wave - clean, simple tone</li>
                                <li><strong>Warm Flute:</strong> Warm, organic flute-like sound</li>
                                <li><strong>Breath Flute:</strong> Breathy, airy texture</li>
                                <li><strong>Shakuhachi Flute:</strong> Japanese shakuhachi-style sound</li>
                                <li><strong>Meditative Space:</strong> Long-evolving ambient pad</li>
                                <li><strong>Tibetan Singing Bowl:</strong> Resonant singing bowl tone</li>
                                <li><strong>Crystal Bowl:</strong> Bright, clear crystal bowl sound</li>
                                <li><strong>Deep Earth Drone:</strong> Deep, sustained ambient drone</li>
                                <li>And more...</li>
                            </ul>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Selecting a Preset</h3>
                            <p>Use the "Sound Options" dropdown to select different sound presets. The change applies immediately to all devices.</p>
                            <div class="mt-4 apple-input p-4 rounded-lg">
                                <img src="tutorial-screenshots/sound-preset-selector.png" alt="Sound Options dropdown" 
                                     class="w-full rounded border border-gray-600" 
                                     onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                                <div class="w-full h-32 rounded flex items-center justify-center text-gray-500" style="display: none; background: rgba(255, 255, 255, 0.05);">
                                    <p class="text-gray-400 text-sm">ðŸ“¸ Screenshot: Sound Options dropdown showing available sound presets</p>
                                </div>
                            </div>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Preset Characteristics</h3>
                            <p>Each preset has unique characteristics:</p>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li><strong>Attack:</strong> How quickly the sound starts</li>
                                <li><strong>Decay/Sustain:</strong> How the sound holds</li>
                                <li><strong>Release:</strong> How the sound fades out</li>
                                <li><strong>Filter:</strong> Tone shaping and brightness</li>
                                <li><strong>Reverb:</strong> Spatial depth and ambience</li>
                            </ul>
                        `
                    },
                    {
                        id: 'note-presets',
                        title: 'Note Presets',
                        content: `
                            <h2 class="text-white text-xl font-semibold mb-3 mt-6">Note Presets</h2>
                            <p>Note presets configure which notes are played, their scales, timing, and reference pitch.</p>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Preset Format</h3>
                            <p>Each preset name follows this format: <code class="bg-gray-800 px-2 py-1 rounded">[Number] â€¢ [Sound] â€¢ [Scale] â€¢ [Pitch]</code></p>
                            <p class="mt-2">Example: <code class="bg-gray-800 px-2 py-1 rounded">1 â€¢ Original Sine â€¢ G Minor Pentatonic â€¢ 440Hz</code></p>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">What Presets Include</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li><strong>Sound Preset:</strong> Which sound to use (e.g., Original Sine, Warm Flute)</li>
                                <li><strong>Note Length:</strong> Base duration for notes (with Â±2 seconds randomness)</li>
                                <li><strong>Pause Length:</strong> Base pause between notes (with Â±2 seconds randomness)</li>
                                <li><strong>Scale/Key:</strong> Musical scale and key (e.g., G Minor Pentatonic, C Major)</li>
                                <li><strong>Reference Pitch:</strong> 440Hz (standard) or 432Hz (alternative tuning)</li>
                                <li><strong>Assigned Notes:</strong> Specific notes with volumes and colors</li>
                            </ul>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Loading Presets</h3>
                            <p>Select a preset from the "Presets" dropdown. The app will automatically:</p>
                            <ol class="list-decimal list-inside space-y-2 ml-4">
                                <li>Update the sound preset</li>
                                <li>Set note and pause lengths</li>
                                <li>Configure the reference pitch</li>
                                <li>Load the assigned notes</li>
                            </ol>
                            <div class="mt-4 apple-input p-4 rounded-lg">
                                <img src="tutorial-screenshots/note-preset-selector.png" alt="Presets dropdown" 
                                     class="w-full rounded border border-gray-600" 
                                     onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                                <div class="w-full h-32 rounded flex items-center justify-center text-gray-500" style="display: none; background: rgba(255, 255, 255, 0.05);">
                                    <p class="text-gray-400 text-sm">ðŸ“¸ Screenshot: Presets dropdown showing available note presets</p>
                                </div>
                            </div>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Saving Custom Presets</h3>
                            <p>After editing notes, you can save your configuration:</p>
                            <ol class="list-decimal list-inside space-y-2 ml-4">
                                <li>Click the <strong>Edit</strong> button</li>
                                <li>Make your changes to notes, volumes, etc.</li>
                                <li>Click <strong>Save Preset</strong> at the bottom</li>
                                <li>Enter a name for your preset</li>
                            </ol>
                        `
                    },
                    {
                        id: 'editing-notes',
                        title: 'Editing Notes',
                        content: `
                            <h2 class="text-white text-xl font-semibold mb-3 mt-6">Editing Notes</h2>
                            <p>The Edit mode allows you to customize your note configuration.</p>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Entering Edit Mode</h3>
                            <p>Click the <strong>Edit</strong> button next to the Presets dropdown. The button will change to <strong>Hide</strong> when edit mode is active.</p>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Editing Features</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li><strong>Note Name:</strong> Click on the note name field to edit (e.g., G3, C4)</li>
                                <li><strong>Frequency:</strong> In Advanced mode, edit the frequency in Hz</li>
                                <li><strong>Volume:</strong> Adjust the volume slider (0-100%)</li>
                                <li><strong>Enable/Disable:</strong> Toggle notes ON/OFF</li>
                                <li><strong>Remove:</strong> Click the Ã— button to remove a note</li>
                                <li><strong>Add Note:</strong> Click "+ insert new key" to add new notes</li>
                            </ul>
                            <div class="mt-4 apple-input p-4 rounded-lg">
                                <img src="tutorial-screenshots/edit-mode-interface.png" alt="Edit mode interface" 
                                     class="w-full rounded border border-gray-600" 
                                     onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                                <div class="w-full h-64 rounded flex items-center justify-center text-gray-500" style="display: none; background: rgba(255, 255, 255, 0.05);">
                                    <p class="text-gray-400 text-sm">ðŸ“¸ Screenshot: Edit mode showing editable note fields, remove buttons, and "insert new key" button</p>
                                </div>
                            </div>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Adding Notes</h3>
                            <ol class="list-decimal list-inside space-y-2 ml-4">
                                <li>Click the <strong>+ insert new key</strong> button</li>
                                <li>Enter a note name (e.g., E4, F#5, Bb3)</li>
                                <li>The frequency will auto-calculate</li>
                                <li>Optionally adjust the frequency manually</li>
                                <li>Click <strong>Add</strong> to add the note</li>
                            </ol>
                            <p class="mt-2">Notes are automatically sorted from low to high frequency.</p>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Advanced Settings</h3>
                            <p>Click the <strong>Advanced</strong> button to access:</p>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li><strong>Frequency Display:</strong> See exact frequencies in Hz</li>
                                <li><strong>Cents Adjustment:</strong> Fine-tune pitch using +/- buttons (Â±1 cent per click)</li>
                                <li><strong>Frequency Editing:</strong> Direct frequency input when in Edit mode</li>
                            </ul>
                        `
                    },
                    {
                        id: 'settings',
                        title: 'Settings & Options',
                        content: `
                            <h2 class="text-white text-xl font-semibold mb-3 mt-6">Settings & Options</h2>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Sound Options</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li><strong>Sound Preset:</strong> Select the sound character/timbre</li>
                                <li><strong>Transpose:</strong> Raise or lower all notes by a semitone</li>
                                <li><strong>Reference Pitch:</strong> Toggle between 440Hz (standard) and 432Hz (alternative)</li>
                                <li><strong>Advanced:</strong> Toggle advanced settings (frequency display, cents adjustment)</li>
                            </ul>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Master Included Toggle</h3>
                            <p>When enabled, the master device participates in note distribution. When disabled, only slave devices play notes.</p>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Sound Flakes Volumes</h3>
                            <p>Control the volume of each connected slave device individually. Adjust sliders to balance the soundscape.</p>
                            <div class="mt-4 apple-input p-4 rounded-lg">
                                <img src="tutorial-screenshots/sound-flakes-volumes.png" alt="Sound Flakes Volumes section" 
                                     class="w-full rounded border border-gray-600" 
                                     onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                                <div class="w-full h-48 rounded flex items-center justify-center text-gray-500" style="display: none; background: rgba(255, 255, 255, 0.05);">
                                    <p class="text-gray-400 text-sm">ðŸ“¸ Screenshot: Sound Flakes Volumes section showing individual volume sliders for each slave device</p>
                                </div>
                            </div>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Timing Controls</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li><strong>Length:</strong> Base duration for each note (default: 5 seconds)</li>
                                <li><strong>Pause:</strong> Base pause between notes (default: 5 seconds)</li>
                                <li>Both have Â±2 seconds randomness for natural variation</li>
                            </ul>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Reference Pitch</h3>
                            <p>The reference pitch determines the base frequency for note calculations:</p>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li><strong>440Hz:</strong> Standard concert pitch (A4 = 440Hz)</li>
                                <li><strong>432Hz:</strong> Alternative tuning (A4 = 432Hz), sometimes called "natural" or "healing" frequency</li>
                            </ul>
                            <p class="mt-2">Changing the reference pitch affects all note frequencies proportionally.</p>
                        `
                    },
                    {
                        id: 'limitations',
                        title: 'Limitations & Notes',
                        content: `
                            <h2 class="text-white text-xl font-semibold mb-3 mt-6">Limitations & Important Notes</h2>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Network Requirements</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li>All devices must be on the same Wi-Fi network</li>
                                <li>Firewall must allow connections on port 3000</li>
                                <li>For best results, use a stable network connection</li>
                            </ul>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Browser Compatibility</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li>Works best in modern browsers (Chrome, Safari, Firefox)</li>
                                <li>Requires Web Audio API support</li>
                                <li>iOS devices may require user interaction to start audio</li>
                            </ul>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">iOS Device Notes</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li>iOS devices may go to sleep - disable auto-lock in Settings</li>
                                <li>Audio may require a tap to activate</li>
                                <li>Keep devices plugged in for long sessions</li>
                            </ul>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Performance Considerations</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li>Each device handles its own audio processing</li>
                                <li>Complex presets may use more CPU</li>
                                <li>Limit the number of simultaneous notes for best performance</li>
                            </ul>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Known Limitations</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li>Maximum recommended: 10-15 slave devices</li>
                                <li>Network latency may cause slight timing differences</li>
                                <li>Presets are stored locally in browser storage</li>
                                <li>QR code contains hardcoded IP address (update if network changes)</li>
                            </ul>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Tips for Best Results</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li>Place devices in different physical locations for spatial effect</li>
                                <li>Use headphones on some devices for immersive experience</li>
                                <li>Experiment with different sound presets for variety</li>
                                <li>Adjust individual device volumes to create depth</li>
                                <li>Try different scales and reference pitches for different moods</li>
                            </ul>
                        `
                    },
                    {
                        id: 'troubleshooting',
                        title: 'Troubleshooting',
                        content: `
                            <h2 class="text-white text-xl font-semibold mb-3 mt-6">Troubleshooting</h2>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Slave Devices Not Connecting</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li>Check that all devices are on the same Wi-Fi network</li>
                                <li>Verify firewall allows port 3000</li>
                                <li>Make sure the master device's server is running</li>
                                <li>Try refreshing the slave device page</li>
                            </ul>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">No Sound Playing</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li>Check device volume settings</li>
                                <li>Verify the Play button is active (showing pause icon)</li>
                                <li>Ensure at least one note is enabled</li>
                                <li>On iOS, tap the screen to activate audio</li>
                                <li>Check browser console for errors</li>
                            </ul>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">QR Code Not Working</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li>Make sure QR code library is loaded</li>
                                <li>Check that the IP address in the QR code matches your network</li>
                                <li>Try manually entering the URL: <code class="bg-gray-800 px-2 py-1 rounded">http://[IP]:3000?slave=true</code></li>
                            </ul>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Notes Not Respecting Timing</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li>Check Length and Pause settings</li>
                                <li>Verify randomness is working (Â±2 seconds)</li>
                                <li>Ensure no notes are overlapping (check console logs)</li>
                                <li>Try increasing pause duration</li>
                            </ul>
                            
                            <h3 class="text-white text-lg font-semibold mb-2 mt-4">Performance Issues</h3>
                            <ul class="list-disc list-inside space-y-2 ml-4">
                                <li>Reduce number of enabled notes</li>
                                <li>Use simpler sound presets</li>
                                <li>Close other browser tabs/applications</li>
                                <li>Check device CPU usage</li>
                            </ul>
                        `
                    }
                ];
                
                const loadNotePreset = (presetName) => {
                    // Try to find preset in predefined presets first
                    let preset = predefinedPresets.find(p => p.name === presetName);
                    
                    // If not found in predefined, check saved presets
                    if (!preset) {
                        const savedPresets = JSON.parse(localStorage.getItem('soundmarbles-presets') || '[]');
                        preset = savedPresets.find(p => p.name === presetName);
                    }
                    
                    if (!preset) {
                        console.warn('Preset not found:', presetName);
                        return;
                    }
                    
                    // Update settings
                    if (preset.settings) {
                        if (preset.settings.noteLength !== undefined) settings.noteLength = preset.settings.noteLength;
                        if (preset.settings.pauseLength !== undefined) settings.pauseLength = preset.settings.pauseLength;
                        if (preset.settings.referencePitch !== undefined) settings.referencePitch = preset.settings.referencePitch;
                    }
                    
                    // Update sound preset (if synth preset system exists)
                    if (preset.soundPreset && typeof loadSynthPresetByName === 'function') {
                        currentPresetName.value = preset.soundPreset;
                        loadSynthPresetByName(preset.soundPreset);
                    }
                    
                    // Update notes - clear and add new ones
                    if (preset.notes) {
                        noteData.splice(0, noteData.length);
                        preset.notes.forEach(note => {
                            noteData.push({ ...note });
                        });
                    }
                    
                    // Update current preset name
                    currentNotePreset.value = presetName;
                    
                    console.log('Loaded preset:', presetName);
                };
                
                
                const noteToFrequency = (noteName) => {
                    if (!noteName || noteName.length < 2) return null;
                    
                    // Parse note name (e.g., "E4", "C#5", "Bb3")
                    const match = noteName.match(/^([A-G])([#b]?)(\d+)$/i);
                    if (!match) return null;
                    
                    const [, note, accidental, octave] = match;
                    const octaveNum = parseInt(octave);
                    
                    // Just Intonation tuning - pure frequency ratios from C
                    // Reference pitch is A4 (440 Hz or 432 Hz)
                    // In just intonation, A is 5/3 relative to C
                    // So C4 = A4 / (5/3) = A4 * 3/5
                    const a4Freq = settings.referencePitch || 440;
                    const rootFreq = a4Freq * (3/5); // C4 frequency from A4 using just intonation ratio
                    const rootOctave = 4;
                    
                    // Just intonation ratios relative to C (in C major scale)
                    // Using pure intervals: 1/1, 9/8, 5/4, 4/3, 3/2, 5/3, 15/8
                    const justIntonationRatios = {
                        'C': 1/1,      // Unison: 1:1
                        'C#': 16/15,   // Minor second: 16:15
                        'Db': 16/15,   // Minor second: 16:15
                        'D': 9/8,      // Major second: 9:8
                        'D#': 6/5,     // Minor third: 6:5
                        'Eb': 6/5,     // Minor third: 6:5
                        'E': 5/4,      // Major third: 5:4
                        'F': 4/3,      // Perfect fourth: 4:3
                        'F#': 45/32,   // Augmented fourth: 45:32
                        'Gb': 45/32,   // Augmented fourth: 45:32
                        'G': 3/2,      // Perfect fifth: 3:2
                        'G#': 8/5,     // Minor sixth: 8:5
                        'Ab': 8/5,     // Minor sixth: 8:5
                        'A': 5/3,      // Major sixth: 5:3
                        'A#': 16/9,    // Minor seventh: 16:9
                        'Bb': 16/9,    // Minor seventh: 16:9
                        'B': 15/8      // Major seventh: 15:8
                    };
                    
                    const noteKey = accidental ? note.toUpperCase() + accidental : note.toUpperCase();
                    const ratio = justIntonationRatios[noteKey];
                    if (ratio === undefined) return null;
                    
                    // Calculate frequency: rootFreq * ratio * 2^(octave difference)
                    const octaveDiff = octaveNum - rootOctave;
                    const frequency = rootFreq * ratio * Math.pow(2, octaveDiff);
                    
                    return Math.round(frequency * 100) / 100; // Round to 2 decimal places
                };
                
                const calculateFrequency = () => {
                    if (newNoteName.value) {
                        const freq = noteToFrequency(newNoteName.value);
                        if (freq !== null) {
                            newNoteFreq.value = freq;
                        }
                    }
                };
                
                // Sort notes by frequency (low to high)
                const sortNotes = () => {
                    noteData.sort((a, b) => a.freq - b.freq);
                };
                
                const updateNoteFrequency = (idx) => {
                    if (idx < 0 || idx >= noteData.length) return;
                    const note = noteData[idx];
                    // If note name is changed, try to recalculate frequency
                    if (note.note) {
                        const freq = noteToFrequency(note.note);
                        if (freq !== null) {
                            note.freq = freq;
                            // Reset cents offset when note name changes
                            if (note.centsOffset === undefined) {
                                note.centsOffset = 0;
                            } else {
                                note.centsOffset = 0;
                            }
                        }
                    }
                    // Sort notes after frequency update
                    sortNotes();
                };

                // Adjust note frequency by cents (Â±1 cent per click)
                const adjustNoteFrequency = (idx, cents) => {
                    if (idx < 0 || idx >= noteData.length) return;
                    const note = noteData[idx];
                    if (!note.note) return;
                    
                    // Get base frequency for this note
                    const baseFreq = noteToFrequency(note.note);
                    if (baseFreq === null) return;
                    
                    // Initialize centsOffset if not set
                    if (note.centsOffset === undefined) {
                        // Calculate current offset from base frequency
                        note.centsOffset = Math.round(1200 * Math.log2(note.freq / baseFreq));
                    }
                    
                    // Update cents offset
                    note.centsOffset = (note.centsOffset || 0) + cents;
                    
                    // Calculate new frequency from base + cents offset
                    const centRatio = Math.pow(2, note.centsOffset / 1200);
                    const newFreq = baseFreq * centRatio;
                    
                    // Clamp to reasonable range (50-2000 Hz)
                    note.freq = Math.max(50, Math.min(2000, newFreq));
                    
                    // If playing, send updated preset to slaves
                    if (isPlaying.value && ws.value && ws.value.readyState === WebSocket.OPEN) {
                        sendPresetToSlaves();
                    }
                };
                
                // Calculate cents offset for display
                const getCentsOffset = (note) => {
                    if (!note.note) return 0;
                    
                    // If centsOffset is already set, use it
                    if (note.centsOffset !== undefined) {
                        return note.centsOffset;
                    }
                    
                    // Otherwise calculate and store it
                    const baseFreq = noteToFrequency(note.note);
                    if (baseFreq === null || baseFreq <= 0 || note.freq <= 0) {
                        note.centsOffset = 0;
                        return 0;
                    }
                    
                    const calculatedOffset = Math.round(1200 * Math.log2(note.freq / baseFreq));
                    // Round very small offsets to 0 (within 0.5 cents to account for floating point precision)
                    const roundedOffset = Math.abs(calculatedOffset) < 0.5 ? 0 : calculatedOffset;
                    note.centsOffset = roundedOffset;
                    return roundedOffset;
                };

                // Transpose all notes by a semitone
                const transposeAllNotes = (direction) => {
                    if (!direction || (direction !== 'up' && direction !== 'down')) return;
                    
                    // Note name mapping for semitone transposition
                    const noteSequence = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                    const noteSequenceFlat = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
                    
                    noteData.forEach((note) => {
                        if (!note.note) return;
                        
                        // Parse note name
                        const match = note.note.match(/^([A-G])([#b]?)(\d+)$/i);
                        if (!match) return;
                        
                        const [, noteLetter, accidental, octave] = match;
                        const octaveNum = parseInt(octave);
                        
                        // Find current semitone index
                        const noteKey = accidental ? noteLetter.toUpperCase() + accidental : noteLetter.toUpperCase();
                        let semitoneIndex = noteSequence.indexOf(noteKey);
                        if (semitoneIndex === -1) {
                            semitoneIndex = noteSequenceFlat.indexOf(noteKey);
                        }
                        if (semitoneIndex === -1) return;
                        
                        // Transpose semitone
                        let newSemitoneIndex, newOctave;
                        if (direction === 'up') {
                            newSemitoneIndex = semitoneIndex + 1;
                            if (newSemitoneIndex >= 12) {
                                newSemitoneIndex = 0;
                                newOctave = octaveNum + 1;
                            } else {
                                newOctave = octaveNum;
                            }
                        } else {
                            newSemitoneIndex = semitoneIndex - 1;
                            if (newSemitoneIndex < 0) {
                                newSemitoneIndex = 11;
                                newOctave = octaveNum - 1;
                            } else {
                                newOctave = octaveNum;
                            }
                        }
                        
                        // Get new note name (prefer sharps)
                        const newNoteName = noteSequence[newSemitoneIndex] + newOctave;
                        
                        // Update note
                        note.note = newNoteName;
                        
                        // Recalculate frequency
                        const newFreq = noteToFrequency(newNoteName);
                        if (newFreq !== null) {
                            note.freq = newFreq;
                            // Reset cents offset after transposition
                            note.centsOffset = 0;
                        }
                    });
                    
                    // If playing, send updated preset to slaves
                    if (isPlaying.value && ws.value && ws.value.readyState === WebSocket.OPEN) {
                        sendPresetToSlaves();
                    }
                };
                
                const addNote = () => {
                    if (!newNoteName.value) return;
                    // Auto-calculate frequency if not set
                    if (!newNoteFreq.value) {
                        const freq = noteToFrequency(newNoteName.value);
                        if (freq === null) {
                            alert('Invalid note format. Use format like: E4, C#5, Bb3');
                            return;
                        }
                        newNoteFreq.value = freq;
                    }
                    
                    const color = colors[noteData.length % colors.length];
                    noteData.push({
                        note: newNoteName.value,
                        freq: newNoteFreq.value,
                        color: color,
                        volume: 70,
                        enabled: true,
                        centsOffset: 0
                    });
                    // Sort notes after adding
                    sortNotes();
                    newNoteName.value = '';
                    newNoteFreq.value = null;
                };

                const addNoteAndClose = () => {
                    addNote();
                    showAddNoteInput.value = false;
                };
                
                const removeNote = (idx) => {
                    noteData.splice(idx, 1);
                };
                
                const createNewPalette = () => {
                    const name = prompt('Enter palette name:') || 'Untitled';
                    currentPaletteName.value = name;
                    noteData.length = 0; // Clear current notes
                    newNoteName.value = '';
                    newNoteFreq.value = null;
                };
                
                const saveCurrentPalette = () => {
                    const name = prompt('Save palette as:', currentPaletteName.value) || currentPaletteName.value;
                    if (!name) return;
                    
                    const palette = {
                        name: name,
                        notes: noteData.map(n => ({
                            note: n.note,
                            freq: n.freq,
                            color: n.color,
                            volume: n.volume,
                            enabled: n.enabled
                        }))
                    };
                    
                    const palettes = JSON.parse(localStorage.getItem('soundmarbles-palettes') || '[]');
                    // Remove existing palette with same name if exists
                    const existingIndex = palettes.findIndex(p => p.name === name);
                    if (existingIndex >= 0) {
                        palettes[existingIndex] = palette;
                    } else {
                        palettes.push(palette);
                    }
                    localStorage.setItem('soundmarbles-palettes', JSON.stringify(palettes));
                    currentPaletteName.value = name;
                    alert(`Palette "${name}" saved!`);
                };
                
                const loadPalette = () => {
                    const palettes = JSON.parse(localStorage.getItem('soundmarbles-palettes') || '[]');
                    if (palettes.length === 0) {
                        alert('No saved palettes found. Create and save a palette first.');
                        return;
                    }
                    
                    const names = palettes.map((p, i) => `${i + 1}: ${p.name}`).join('\n');
                    const input = prompt(`Select palette:\n${names}\n\nEnter number:`);
                    if (input === null || !input.trim()) return;
                    
                    const index = parseInt(input) - 1;
                    if (isNaN(index) || index < 0 || index >= palettes.length) {
                        alert('Invalid selection');
                        return;
                    }
                    
                    const palette = palettes[index];
                    currentPaletteName.value = palette.name;
                    noteData.length = 0;
                    palette.notes.forEach(n => {
                        noteData.push({
                            note: n.note,
                            freq: n.freq,
                            color: n.color,
                            volume: n.volume,
                            enabled: n.enabled,
                            centsOffset: n.centsOffset || 0
                        });
                    });
                    
                    // Restart generators if playing
                    if (isPlaying.value) {
                        startAllGenerators();
                    }
                };
                
                // Watch for numGenerators changes and restart if playing
                watch(() => settings.numGenerators, () => {
                    if (isPlaying.value) {
                        startAllGenerators();
                    }
                });
                
                const resizeCanvas = () => {
                    const c = canvas.value;
                    if (!c) return;
                    const dpr = window.devicePixelRatio || 1;
                    // Use window dimensions directly for more reliable sizing
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    c.width = width * dpr;
                    c.height = height * dpr;
                    c.style.width = width + 'px';
                    c.style.height = height + 'px';
                    if (ctx.value) {
                        ctx.value.setTransform(1, 0, 0, 1, 0, 0);
                        ctx.value.scale(dpr, dpr);
                    }
                };
                
                // Detect if this is a slave device
                const urlParams = new URLSearchParams(window.location.search);
                const isSlave = urlParams.get('slave') === 'true';
                console.log('ðŸ” Device detection:', {
                    url: window.location.href,
                    search: window.location.search,
                    isSlave: isSlave,
                    slaveParam: urlParams.get('slave')
                });
                
                // WebSocket connection for master-slave communication
                const ws = ref(null);
                const wsConnected = ref(false); // Track if we've successfully connected
                const wsReceivedWelcome = ref(false); // Track if we've received welcome message
                const wsError = ref(null); // Track WebSocket errors for display
                const slaveStatus = ref(''); // Status message for slaves
                const slaveId = isSlave ? `slave-${Date.now()}-${Math.random().toString(36).substr(2, 9)}` : null;
                const assignedNotes = ref([]); // For slaves - when master is included, masterAssignedNotes is used instead
                const noteRotationIndex = ref(0); // Track which note to play next (for rotation)
                const shuffledNoteIndices = ref([]); // Shuffled array of note indices to ensure all notes are played
                
                const getServerUrl = () => {
                    const hostname = window.location.hostname;
                    const port = window.location.port || '3000';
                    
                    // If accessing via localhost, try to get the actual IP
                    if (hostname === 'localhost' || hostname === '127.0.0.1') {
                        // For mobile devices scanning, we need the actual IP
                        // The server is running on the Mac, so we'll use the IP we found earlier
                        // In a real scenario, you'd want to detect this dynamically
                        // For now, we'll construct it from the current connection
                        return `http://192.168.2.34:${port}`;
                    }
                    
                    // Otherwise use the current hostname
                    return `${window.location.protocol}//${hostname}${port ? ':' + port : ''}${window.location.pathname}`;
                };
                
                const getWebSocketUrl = () => {
                    // Use same port as HTTP (3000) - WebSocket is now on same port
                    const wsPort = 3000;
                    const hostname = window.location.hostname;
                    const port = window.location.port || wsPort;
                    
                    // Determine WebSocket URL to use
                    let wsHost;
                    
                    // For slaves accessing via QR code, they'll be on the IP address
                    // For external devices (like iPhone), always use the IP from the URL
                    if (hostname === 'localhost' || hostname === '127.0.0.1') {
                        // If accessing via localhost, use localhost for WebSocket too (for same-device connections)
                        wsHost = 'localhost';
                    } else if (hostname.match(/^\d+\.\d+\.\d+\.\d+$/)) {
                        // If accessing via IP address (like 192.168.2.34), use that same IP
                        wsHost = hostname;
                    } else {
                        // For any other hostname (like domain names), use as-is
                        wsHost = hostname;
                    }
                    
                    // Use ws:// protocol (wss:// only if page is loaded via https://)
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    // For HTTPS (Railway/production), don't include port (uses default 443)
                    // For HTTP (localhost), include port
                    const wsUrl = protocol === 'wss:' 
                        ? `${protocol}//${wsHost}` 
                        : `${protocol}//${wsHost}:${port}`;
                    
                    console.log('getWebSocketUrl() called - returning:', wsUrl);
                    console.log('Current window.location:', {
                        hostname: window.location.hostname,
                        port: window.location.port,
                        href: window.location.href,
                        protocol: window.location.protocol
                    });
                    console.log('Using WebSocket host:', wsHost);
                    console.log('Using WebSocket protocol:', protocol);
                    console.log('Is slave:', isSlave);
                    console.log('User-Agent:', navigator.userAgent);
                    
                    return wsUrl;
                };
                
                const connectWebSocket = () => {
                    console.log('=== connectWebSocket() called ===');
                    console.log('Is slave:', isSlave);
                    const wsUrl = getWebSocketUrl();
                    console.log('WebSocket URL from getWebSocketUrl():', wsUrl);
                    // Validate URL before creating WebSocket
                    if (!wsUrl || wsUrl.includes('undefined')) {
                        console.error('Invalid WebSocket URL:', wsUrl);
                        if (isSlave) {
                            alert('Error: Invalid WebSocket URL. Please refresh the page.');
                        }
                        return;
                    }
                    console.log('=== WebSocket Connection Debug ===');
                    console.log('Connecting to WebSocket:', wsUrl);
                    console.log('Current hostname:', window.location.hostname);
                    console.log('Current port:', window.location.port);
                    console.log('Current URL:', window.location.href);
                    console.log('Is slave:', isSlave);
                    console.log('WebSocket port should be: 3000 (same as HTTP)');
                    console.log('URL validation:', wsUrl.includes(':3000') ? 'âœ“ Correct port' : 'âœ— Wrong port!');
                    console.log('Full WebSocket URL:', wsUrl);
                    
                    // Double-check URL is correct
                    if (!wsUrl.startsWith('ws://') && !wsUrl.startsWith('wss://')) {
                        console.error('ERROR: WebSocket URL must start with ws:// or wss://');
                        alert('Error: Invalid WebSocket protocol. URL: ' + wsUrl);
                        return;
                    }
                    // Port validation - should be 3000, but allow for flexibility
                    const urlMatch = wsUrl.match(/ws:\/\/[^:]+:(\d+)/);
                    if (urlMatch && urlMatch[1] !== '3000') {
                        console.warn('Warning: WebSocket URL port is', urlMatch[1], 'expected 3000');
                    }
                    
                    try {
                        console.log('Creating WebSocket with URL:', wsUrl);
                        const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);
                        console.log('Is iOS device:', isIOS);
                        if (isIOS) {
                            console.log('iOS device detected - WebSocket connection may require retries');
                            console.log('User-Agent:', navigator.userAgent);
                        }
                        
                        const websocket = new WebSocket(wsUrl);
                        ws.value = websocket;
                        console.log('WebSocket object created, initial state:', websocket.readyState);
                        
                        // Add connection timeout - increased to 20 seconds for network issues
                        let connectionTimeout = setTimeout(() => {
                            // Only timeout if still connecting (not if already opened and closed)
                            if (websocket.readyState === WebSocket.CONNECTING || websocket.readyState === 0) {
                                console.error('âœ— WebSocket connection timeout after 20 seconds');
                                console.error('URL attempted:', wsUrl);
                                console.error('ReadyState:', websocket.readyState);
                                console.error('WebSocket state:', {
                                    CONNECTING: WebSocket.CONNECTING,
                                    OPEN: WebSocket.OPEN,
                                    CLOSING: WebSocket.CLOSING,
                                    CLOSED: WebSocket.CLOSED,
                                    current: websocket.readyState
                                });
                                websocket.close();
                                ws.value = null;
                                if (isSlave) {
                                    const currentUrl = window.location.href;
                                    const errorMsg = 'WebSocket connection timeout.\n\n' +
                                        'Trying to connect to: ' + wsUrl + '\n' +
                                        'Current page: ' + currentUrl + '\n\n' +
                                        'HTTP works but WebSocket times out.\n\n' +
                                        'Possible causes:\n' +
                                        '1. Router firewall blocking WebSocket\n' +
                                        '2. iOS Safari WebSocket restrictions\n' +
                                        '3. Wi-Fi AP isolation enabled\n' +
                                        '4. Devices on different networks\n\n' +
                                        'To diagnose:\n' +
                                        '1. Check if http://' + window.location.hostname + ':3000 loads\n' +
                                        '2. Check router settings for WebSocket/firewall\n' +
                                        '3. Try a different Wi-Fi network\n' +
                                        '4. Check server logs for connection attempts';
                                    alert(errorMsg);
                                    console.error(errorMsg);
                                    console.error('WebSocket URL:', wsUrl);
                                    console.error('Current hostname:', window.location.hostname);
                                    console.error('Current port:', window.location.port);
                                }
                            } else {
                                console.log('Connection timeout check skipped - WebSocket state:', websocket.readyState);
                            }
                        }, 20000);
                        
                        websocket.onopen = () => {
                            clearTimeout(connectionTimeout);
                            wsConnected.value = true;
                            wsError.value = null; // Clear any previous errors
                            ws.value = websocket; // Update ws ref immediately
                            console.log('âœ“ WebSocket connected successfully!');
                            console.log('WebSocket readyState:', websocket.readyState);
                            console.log('WebSocket protocol:', websocket.protocol);
                            console.log('WebSocket extensions:', websocket.extensions);
                            console.log('wsConnected set to:', wsConnected.value);
                            
                            // Send registration immediately - don't wait for anything
                            // iOS Safari can close connections quickly if idle
                            if (isSlave) {
                                // Register as slave immediately - iOS Safari can close connections quickly
                                console.log('Registering as slave:', slaveId);
                                try {
                                    // Send immediately without setTimeout - iOS Safari needs fast registration
                                    const registerMessage = JSON.stringify({
                                        type: 'slave',
                                        id: slaveId
                                    });
                                    console.log('Sending registration immediately:', registerMessage);
                                    websocket.send(registerMessage);
                                    console.log('Registration message sent successfully');
                                } catch (e) {
                                    console.error('Error sending registration:', e);
                                    wsError.value = 'Registration failed: ' + e.message;
                                    // Try again after a short delay if first attempt failed
                                    setTimeout(() => {
                                        try {
                                            if (websocket.readyState === WebSocket.OPEN) {
                                                const registerMessage = JSON.stringify({
                                                    type: 'slave',
                                                    id: slaveId
                                                });
                                                websocket.send(registerMessage);
                                                console.log('Registration retry successful');
                                            }
                                        } catch (e2) {
                                            console.error('Registration retry failed:', e2);
                                        }
                                    }, 100);
                                }
                                
                                // Initialize audio context immediately for slaves
                                initAudio().then(() => {
                                    console.log('Slave audio context initialized');
                                }).catch(e => {
                                    console.error('Error initializing audio:', e);
                                });
                            } else {
                                // Register as master
                                console.log('Registering as master');
                                setTimeout(() => {
                                    try {
                                        if (websocket.readyState === WebSocket.OPEN) {
                                            websocket.send(JSON.stringify({
                                                type: 'master'
                                            }));
                                            console.log('Master registration sent');
                                        }
                                    } catch (e) {
                                        console.error('Error sending master registration:', e);
                                    }
                                }, 0);
                            }
                        };
                    
                    websocket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            console.log('=== WebSocket message received ===', data.type);
                            
                            // Special logging for volume_update messages
                            if (data.type === 'volume_update') {
                                console.log('ðŸ”ŠðŸ”ŠðŸ”Š VOLUME_UPDATE MESSAGE DETECTED!');
                                console.log('  Volume:', data.volume);
                                console.log('  Is slave:', isSlave);
                                console.log('  masterGain exists:', !!masterGain);
                            }
                            
                            if (isSlave) {
                                // Handle slave messages
                                console.log('Processing slave message:', data.type);
                                if (data.type === 'welcome') {
                                    wsReceivedWelcome.value = true;
                                    wsConnected.value = true; // Ensure connected flag is set
                                    ws.value = websocket; // Update ws ref
                                    // Store slave name - ensure it's a string, use totalSlaves as fallback
                                    if (data.slaveName !== undefined && data.slaveName !== null) {
                                        slaveName.value = String(data.slaveName);
                                    } else if (data.totalSlaves !== undefined) {
                                        // Fallback: use totalSlaves count as the number
                                        slaveName.value = String(data.totalSlaves);
                                    } else {
                                        slaveName.value = null;
                                    }
                                    console.log('âœ“ Slave registered:', data.slaveId, `(Name: ${data.slaveName || 'unnamed'})`);
                                    console.log('Total slaves:', data.totalSlaves);
                                    
                                    // After receiving welcome, wait a moment for notes_assigned
                                    // If no notes arrive, request current state from master
                                    setTimeout(() => {
                                        if (assignedNotes.value.length === 0) {
                                            console.log('âš ï¸ No notes assigned after welcome message');
                                            console.log('Requesting current state from master...');
                                            // Request current preset from master
                                            if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                                ws.value.send(JSON.stringify({
                                                    type: 'request_preset'
                                                }));
                                                console.log('âœ“ Request preset message sent');
                                            } else {
                                                console.log('âœ— WebSocket not ready, cannot request preset');
                                            }
                                        } else {
                                            console.log('âœ“ Notes received after reconnect:', assignedNotes.value.length);
                                        }
                                    }, 1000); // Wait 1 second for notes to arrive
                                    
                                } else if (data.type === 'preset_update' && isSlave) {
                                    // Slave received preset update from master
                                    console.log('ðŸ“¥ Slave received preset_update');
                                    
                                    // Update sound preset if provided
                                    if (data.preset?.soundPreset) {
                                        console.log('  ðŸŽµ Updating sound preset to:', data.preset.soundPreset);
                                        loadSynthPresetByName(data.preset.soundPreset, true); // Skip slave update since we ARE the slave
                                    } else {
                                        console.warn('  âš ï¸ preset_update message missing soundPreset field!');
                                    }
                                    
                                    // Update settings from master
                                    if (data.preset) {
                                        settings.noteLength = data.preset.noteLength;
                                        settings.pauseLength = data.preset.pauseLength;
                                        settings.masterVolume = data.preset.masterVolume;
                                        // Slaves always use 1 generator - don't override numGenerators
                                        // settings.numGenerators should remain 1 for slaves
                                    }
                                    
                                    // Note: notes_assigned will be sent separately by server
                                } else if (data.type === 'notes_assigned') {
                                    console.log('Notes assigned:', data.notes);
                                    console.log('Assigned notes count:', data.notes.length);
                                    assignedNotes.value = data.notes;
                                    // Reset note rotation when new notes are assigned
                                    noteRotationIndex.value = 0;
                                    shuffledNoteIndices.value = [];
                                    console.log('Reset note rotation for new assignment');
                                    
                                    // Notify master about assigned notes
                                    if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                        try {
                                            const message = {
                                                type: 'slave_notes_assigned',
                                                notes: data.notes
                                            };
                                            ws.value.send(JSON.stringify(message));
                                            console.log('âœ“ Sent slave_notes_assigned to server');
                                        } catch (e) {
                                            console.error('Error sending slave_notes_assigned message:', e);
                                        }
                                    } else {
                                        console.warn('âš ï¸ Cannot send slave_notes_assigned - WebSocket not ready:', ws.value?.readyState);
                                    }
                                    
                                    // Update slave name if provided
                                    if (data.slaveName !== undefined && data.slaveName !== null) {
                                        slaveName.value = String(data.slaveName);
                                        console.log('  âœ“ Slave name updated from notes_assigned:', data.slaveName);
                                    } else {
                                        // Fallback: try to infer name from slaveId or use a default
                                        if (!slaveName.value && data.slaveId) {
                                            // This is a fallback - server should send slaveName
                                            console.log('  âš ï¸ Using fallback - slaveName not received from server');
                                        }
                                    }
                                    // Update settings from master (also check preset for soundPreset)
                                    if (data.preset) {
                                        settings.noteLength = data.preset.noteLength;
                                        settings.pauseLength = data.preset.pauseLength;
                                        settings.masterVolume = data.preset.masterVolume;
                                        // Update sound preset if provided
                                        if (data.preset.soundPreset) {
                                            console.log('  ðŸŽµ Updating sound preset from notes_assigned to:', data.preset.soundPreset);
                                            loadSynthPresetByName(data.preset.soundPreset, true); // Skip slave update
                                            console.log('  âœ… Sound preset updated from notes_assigned');
                                        } else {
                                            console.warn('  âš ï¸ notes_assigned preset missing soundPreset field!');
                                            // Request preset update from master
                                            if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                                console.log('  ðŸ“¤ Requesting preset update from master...');
                                                ws.value.send(JSON.stringify({ type: 'slave_requested_preset' }));
                                            }
                                        }
                                        // Slaves always use 1 generator - don't override numGenerators
                                        // settings.numGenerators should remain 1 for slaves
                                    }
                                    // Apply per-slave volume to masterGain if provided
                                    if (data.slaveVolume !== undefined && data.slaveVolume !== null && isSlave) {
                                        const slaveVolumePercent = parseInt(data.slaveVolume);
                                        if (!isNaN(slaveVolumePercent) && slaveVolumePercent >= 0 && slaveVolumePercent <= 100) {
                                            // Store the per-slave volume
                                            slaveVolume.value = slaveVolumePercent;
                                            
                                            console.log(`  ðŸ”Š Stored per-slave volume from notes_assigned: ${slaveVolumePercent}% (will be applied via volume_update to prevent conflicts)`);
                                            // Don't apply volume here - let volume_update message handle it to prevent conflicts
                                        }
                                    }
                                    
                                    // When master volume changes in preset, update settings but don't recalculate slave gain here
                                    // The volume_update message will handle the actual gain update
                                    if (data.preset?.masterVolume !== undefined && isSlave) {
                                        settings.masterVolume = data.preset.masterVolume;
                                        console.log(`  ðŸ“Š Master volume updated in settings: ${data.preset.masterVolume}% (will be applied via volume_update)`);
                                    }
                                    // Force Vue to update UI
                                    wsConnected.value = true;
                                    wsReceivedWelcome.value = true;
                                    ws.value = websocket;
                                    console.log('Status after notes assigned - wsConnected:', wsConnected.value, 'wsReceivedWelcome:', wsReceivedWelcome.value, 'notes:', assignedNotes.value.length);
                                    
                                    // Don't start automatically - wait for 'play' command from master
                                    console.log('Notes assigned, waiting for master play command...');
                                    
                                    // Prepare audio context and check if already unlocked
                                    initAudio().then(() => {
                                        const audioState = audioContext ? audioContext.state : 'unknown';
                                        console.log('Audio context prepared, state:', audioState);
                                        console.log('masterGain:', !!masterGain);
                                        
                                        if (audioContext && audioContext.state === 'running') {
                                            // Audio already unlocked from first interaction
                                            slaveStatus.value = 'Ready';
                                            console.log('âœ“ Audio already unlocked, ready to play');
                                            // Start drone note to keep audio context active
                                            startDroneNote();
                                        } else {
                                            // Audio not unlocked yet - will need first tap
                                            slaveStatus.value = 'Waiting for master...';
                                            console.log('Audio not unlocked yet, will need interaction');
                                            console.log('Audio context state:', audioContext?.state);
                                        }
                                    }).catch(e => {
                                        console.error('Error initializing audio:', e);
                                        slaveStatus.value = 'Waiting for master...';
                                    });
                                } else if (data.type === 'play') {
                                    console.log('âœ“âœ“âœ“ Master play command received by slave');
                                    console.log('Current state - isPlaying:', isPlaying.value, 'assignedNotes:', assignedNotes.value.length);
                                    
                                    if (assignedNotes.value.length === 0) {
                                        console.warn('No notes assigned yet, cannot start playback');
                                        return;
                                    }
                                    
                                    if (isPlaying.value) {
                                        console.log('Already playing, ignoring play command');
                                        return;
                                    }
                                    
                                    // Start playing when master sends play command
                                    console.log('Initializing audio and starting playback...');
                                    slaveStatus.value = 'Starting...';
                                    
                                    // Ensure audio context exists
                                    if (!audioContext) {
                                        console.log('Audio context not initialized, creating...');
                                    }
                                    
                                    console.log('About to call initAudio...');
                                    initAudio().then((ctx) => {
                                        console.log('initAudio promise resolved!');
                                        console.log('Returned ctx:', !!ctx);
                                        const audioState = ctx ? ctx.state : (audioContext ? audioContext.state : 'unknown');
                                        console.log('Audio context state after init:', audioState);
                                        console.log('Audio context exists:', !!audioContext);
                                        console.log('Master gain exists:', !!masterGain);
                                        
                                        // Check if audio context and master gain are ready
                                        if (!audioContext || !masterGain) {
                                            console.error('Audio context or master gain not ready!');
                                            console.error('audioContext:', !!audioContext, 'masterGain:', !!masterGain);
                                            slaveStatus.value = 'Audio not ready';
                                            wsError.value = 'Audio not ready';
                                            return;
                                        }
                                        
                                        if (audioContext.state === 'running') {
                                            // Audio is already unlocked, start immediately
                                            console.log('âœ“ Audio already unlocked, starting playback');
                                            isPlaying.value = true;
                                            slaveStatus.value = 'Playing';
                                            console.log('isPlaying set to:', isPlaying.value);
                                            startSlavePlayback();
                                        } else if (audioContext.state === 'suspended') {
                                            // Audio is suspended, try to resume automatically
                                            console.log('Audio suspended, attempting to resume automatically...');
                                            slaveStatus.value = 'Resuming audio...';
                                            
                                            // Try to resume - this should work if user has interacted with page
                                            // Use a small delay to ensure we're in a user gesture context
                                            setTimeout(() => {
                                                console.log('About to call audioContext.resume()...');
                                                const resumePromise = audioContext.resume();
                                                const timeoutPromise = new Promise((_, reject) => 
                                                    setTimeout(() => reject(new Error('Resume timeout')), 2000)
                                                );
                                                Promise.race([resumePromise, timeoutPromise]).then(() => {
                                                    console.log('âœ“âœ“âœ“ Audio context resumed automatically, state:', audioContext.state);
                                                    console.log('About to start playback...');
                                                    isPlaying.value = true;
                                                    slaveStatus.value = 'Playing';
                                                    console.log('isPlaying set to:', isPlaying.value);
                                                    console.log('Calling startSlavePlayback()...');
                                                    startSlavePlayback();
                                                    console.log('startSlavePlayback() called');
                                                }).catch(e => {
                                                    console.log('Resume failed/timed out, but audio might still work - starting playback anyway');
                                                    // Resume failed or timed out - try to start anyway (might work)
                                                    console.log('Audio resume failed/timed out, but trying to start playback anyway:', e.message);
                                                    isPlaying.value = true;
                                                    slaveStatus.value = 'Playing';
                                                    console.log('Calling startSlavePlayback() despite resume failure...');
                                                    startSlavePlayback();
                                                    
                                                    // Also show tap message as fallback
                                                    slaveStatus.value = 'Tap if no sound';
                                                    
                                                    // Add one-time handler to resume on next interaction
                                                    const resumeOnTap = () => {
                                                        slaveStatus.value = 'Starting...';
                                                        wsError.value = null;
                                                        audioContext.resume().then(() => {
                                                            isPlaying.value = true;
                                                            slaveStatus.value = 'Playing';
                                                            startSlavePlayback();
                                                        });
                                                        document.removeEventListener('touchstart', resumeOnTap, { capture: true });
                                                        document.removeEventListener('click', resumeOnTap, { capture: true });
                                                    };
                                                    document.addEventListener('touchstart', resumeOnTap, { capture: true, passive: true });
                                                    document.addEventListener('click', resumeOnTap, { capture: true, passive: true });
                                                });
                                            }, 100);
                                        } else {
                                            // Unknown state, try to start anyway
                                            console.log('Starting playback (unknown audio state:', audioContext.state, ')');
                                            isPlaying.value = true;
                                            slaveStatus.value = 'Playing';
                                            console.log('isPlaying set to:', isPlaying.value);
                                            startSlavePlayback();
                                        }
                                    }).catch(e => {
                                        console.error('âœ—âœ—âœ— Error initializing audio:', e);
                                        console.error('Error stack:', e.stack);
                                        // Try to start anyway - audio might still work
                                        console.log('Attempting to start playback despite error...');
                                        // Ensure audio context exists even if init failed
                                        if (!audioContext) {
                                            try {
                                                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                                                masterGain = audioContext.createGain();
                                                masterGain.gain.value = settings.masterMuted ? 0 : settings.masterVolume / 100;
                                                masterGain.connect(audioContext.destination);
                                                console.log('Created audio context in error handler');
                                            } catch (err) {
                                                console.error('Failed to create audio context in error handler:', err);
                                            }
                                        }
                                        isPlaying.value = true;
                                        slaveStatus.value = 'Playing';
                                        startSlavePlayback();
                                    });
                                } else if (data.type === 'volume_update') {
                                    // Master sent volume update for this slave
                                    console.log(`ðŸ”ŠðŸ”ŠðŸ”ŠðŸ”ŠðŸ”Š SLAVE RECEIVED VOLUME UPDATE: ${data.volume}%`);
                                    console.log(`  masterGain exists:`, !!masterGain);
                                    console.log(`  audioContext exists:`, !!audioContext);
                                    console.log(`  Current masterGain.value:`, masterGain?.gain?.value);
                                    console.log(`  audioContext.state:`, audioContext?.state);
                                    
                                    if (!masterGain) {
                                        console.error('  âœ—âœ—âœ— masterGain is null/undefined! Cannot apply volume update');
                                        return;
                                    }
                                    
                                    if (!audioContext) {
                                        console.error('  ERROR: audioContext is null/undefined! Cannot apply volume update');
                                        return;
                                    }
                                    
                                    // Store the per-slave volume
                                    slaveVolume.value = data.volume || 100;
                                    
                                    // Calculate target gain: slave volume * master volume
                                    // Both are percentages, so: (slaveVolume / 100) * (masterVolume / 100)
                                    const masterVolumePercent = settings.masterVolume || 70; // Default to 70% if not set
                                    const slaveVolumePercent = slaveVolume.value;
                                    const targetGain = (slaveVolumePercent / 100) * (masterVolumePercent / 100);
                                    const now = audioContext.currentTime;
                                    
                                    // Get current gain value, accounting for any scheduled changes
                                    let currentGain = masterGain.gain.value;
                                    // Cancel any scheduled changes and get the actual current value
                                    masterGain.gain.cancelScheduledValues(now);
                                    currentGain = masterGain.gain.value; // Re-read after cancellation
                                    
                                    console.log(`  ðŸ“Š Per-slave volume update:`);
                                    console.log(`    Slave volume: ${slaveVolumePercent}%`);
                                    console.log(`    Master volume: ${masterVolumePercent}%`);
                                    console.log(`    Combined gain: ${currentGain} â†’ ${targetGain}`);
                                    
                                    // Use setTargetAtTime for smoother transitions
                                    const epsilon = 0.0001;
                                    const targetGainSafe = Math.max(targetGain, epsilon);
                                    
                                    // Cancel scheduled changes and use setTargetAtTime for smooth transition
                                    masterGain.gain.cancelScheduledValues(now);
                                    masterGain.gain.setTargetAtTime(targetGainSafe, now, 0.15);
                                    
                                    console.log(`  âœ“ Applied per-slave volume update: ${slaveVolumePercent}% â†’ gain ${targetGain.toFixed(4)}`);
                                    
                                    // Note: setTargetAtTime uses exponential approach, so it asymptotically approaches the target
                                    // This is expected behavior - the gain will smoothly approach the target over time
                                } else if (data.type === 'stop') {
                                    console.log('Master stop command received - graceful stop with smooth fade-out');
                                    isPlaying.value = false;
                                    slaveStatus.value = 'Waiting for master...';
                                    // Clear all scheduled timeouts to prevent new notes
                                    generatorTimeouts.forEach(timeout => {
                                        if (timeout) clearTimeout(timeout);
                                    });
                                    generatorTimeouts.length = 0;
                                    
                                    // Smoothly fade out all currently playing oscillators
                                    if (audioContext && activeOscillators.size > 0) {
                                        // Define fade-out function
                                        const performSlaveFadeOut = () => {
                                            if (!audioContext || activeOscillators.size === 0) return;
                                            
                                            const now = audioContext.currentTime;
                                            const fadeOutDuration = 0.25; // 250ms fade-out for smooth stop (longer for iOS)
                                            
                                            console.log(`Slave: Fading out ${activeOscillators.size} oscillators over ${fadeOutDuration}s`);
                                            
                                            activeOscillators.forEach(osc => {
                                                try {
                                                    // Calculate when this oscillator was supposed to stop naturally
                                                    const naturalStopTime = osc._startTime ? (osc._startTime + osc._duration) : (now + 1);
                                                    const timeUntilNaturalStop = naturalStopTime - now;
                                                    
                                                    // Fade out the gain node smoothly
                                                    if (osc._oscGain) {
                                                        // Get current gain value - use scheduled value if available
                                                        let currentGain;
                                                        try {
                                                            currentGain = osc._oscGain.gain.value;
                                                            // If gain is already very low or zero, use a small value to ensure smooth fade
                                                            if (currentGain < 0.001) {
                                                                currentGain = 0.01; // Use small value to ensure fade is audible
                                                            }
                                                        } catch (e) {
                                                            currentGain = 0.01; // Fallback
                                                        }
                                                        
                                                        console.log(`Slave: Fading oscillator, current gain: ${currentGain}, natural stop in: ${timeUntilNaturalStop.toFixed(3)}s`);
                                                        
                                                        // Cancel any scheduled values and start fresh fade-out
                                                        osc._oscGain.gain.cancelScheduledValues(now);
                                                        osc._oscGain.gain.setValueAtTime(currentGain, now);
                                                        
                                                        // Use the shorter of: fade-out duration or time until natural stop
                                                        const actualFadeTime = Math.min(fadeOutDuration, Math.max(0.05, timeUntilNaturalStop));
                                                        osc._oscGain.gain.linearRampToValueAtTime(0, now + actualFadeTime);
                                                        
                                                        // Stop oscillator after fade completes
                                                        const stopTime = now + actualFadeTime + 0.01;
                                                        osc.stop(stopTime);
                                                        
                                                        console.log(`Slave: Scheduled fade-out over ${actualFadeTime.toFixed(3)}s, stop at ${stopTime.toFixed(3)}`);
                                                    } else {
                                                        // Oscillator doesn't have metadata - try to let it finish naturally
                                                        console.log('Slave: Oscillator missing metadata, letting it finish naturally');
                                                        if (timeUntilNaturalStop > 0 && timeUntilNaturalStop < 5) {
                                                            // Only if it's supposed to stop soon, let it finish
                                                            // Otherwise schedule a quick fade
                                                            osc.stop(Math.min(naturalStopTime, now + fadeOutDuration));
                                                        }
                                                    }
                                                } catch (e) {
                                                    console.error('Slave: Error fading out oscillator:', e);
                                                    // Fallback: schedule a gentle stop
                                                    try {
                                                        const gentleStop = now + fadeOutDuration;
                                                        osc.stop(gentleStop);
                                                    } catch (e2) {
                                                        console.error('Slave: Could not schedule gentle stop:', e2);
                                                    }
                                                }
                                            });
                                        };
                                        
                                        // Ensure audio context is running (especially important for iOS)
                                        if (audioContext.state === 'suspended') {
                                            console.log('Slave: Audio context suspended, attempting to resume before fade-out...');
                                            audioContext.resume().then(() => {
                                                console.log('Slave: Audio context resumed, proceeding with fade-out');
                                                performSlaveFadeOut();
                                            }).catch(e => {
                                                console.error('Slave: Could not resume audio context:', e);
                                                // Try fade-out anyway
                                                performSlaveFadeOut();
                                            });
                                        } else {
                                            performSlaveFadeOut();
                                        }
                                    } else {
                                        console.log('Slave: No active oscillators to fade out');
                                    }
                                    
                                    // Clear the set after fade-out completes
                                    setTimeout(() => {
                                        activeOscillators.clear();
                                    }, 300); // Wait for fade-out to complete
                                    
                                    // Keep drone note running even when stopped (for slaves)
                                    // This ensures audio context stays active
                                    if (audioContext && audioContext.state === 'running' && !droneOscillator) {
                                        startDroneNote();
                                    }
                                }
                            } else {
                                // Handle master messages
                                if (data.type === 'slaves') {
                                    // Initial message from server with current slave count
                                    console.log('ðŸ“¡ Master received initial slaves list');
                                    console.log('  Slave count:', data.count);
                                    console.log('  Slave IDs:', data.slaves);
                                    
                                    // Update total slaves count
                                    totalSlaves.value = data.count || 0;
                                    
                                    // Populate connectedSlaves array with initial slave list
                                    // This is the authoritative list from the server - always use it to sync
                                    if (data.slaves && Array.isArray(data.slaves)) {
                                        console.log(`  ðŸ“‹ Server sent ${data.slaves.length} slaves:`, data.slaves);
                                        
                                        // Preserve existing settings for slaves that are still connected
                                        const settingsMap = new Map();
                                        connectedSlaves.forEach(slave => {
                                            settingsMap.set(slave.id, {
                                                volume: slave.volume,
                                                assignedNotes: slave.assignedNotes || [],
                                                currentlyPlayingNote: slave.currentlyPlayingNote
                                            });
                                        });
                                        
                                        // Clear existing and repopulate from server's authoritative list
                                        connectedSlaves.length = 0;
                                        data.slaves.forEach(slaveInfo => {
                                            // Handle both old format (string IDs) and new format (objects with id and name)
                                            const slaveId = typeof slaveInfo === 'string' ? slaveInfo : slaveInfo.id;
                                            const slaveName = typeof slaveInfo === 'string' ? null : slaveInfo.name;
                                            const serverAssignedNotes = typeof slaveInfo === 'object' ? (slaveInfo.assignedNotes || []) : [];
                                            
                                            if (slaveId) { // Only add valid IDs
                                                const existingSettings = settingsMap.get(slaveId);
                                                
                                                // Priority: server's assignedNotes > existing > pending
                                                let assignedNotes = [];
                                                if (serverAssignedNotes.length > 0) {
                                                    assignedNotes = serverAssignedNotes;
                                                    console.log(`  âœ“ Using server's assigned notes for slave ${slaveId}:`, assignedNotes.map(n => n.note));
                                                } else if (existingSettings?.assignedNotes && existingSettings.assignedNotes.length > 0) {
                                                    assignedNotes = existingSettings.assignedNotes;
                                                    console.log(`  âœ“ Using existing assigned notes for slave ${slaveId}:`, assignedNotes.map(n => n.note));
                                                } else if (window.pendingSlaveNotes && window.pendingSlaveNotes[slaveId]) {
                                                    assignedNotes = window.pendingSlaveNotes[slaveId];
                                                    console.log(`  âœ“ Applied pending notes for slave ${slaveId}:`, assignedNotes.map(n => n.note));
                                                    delete window.pendingSlaveNotes[slaveId];
                                                }
                                                
                                                connectedSlaves.push({
                                                    id: slaveId,
                                                    name: slaveName || String(connectedSlaves.length + 1), // Use name if provided, otherwise use index
                                                    volume: existingSettings?.volume !== undefined ? existingSettings.volume : 100, // Preserve volume or default to 100
                                                    assignedNotes: assignedNotes, // Use server's notes, existing, or pending
                                                    currentlyPlayingNote: existingSettings?.currentlyPlayingNote || null // Preserve currently playing note
                                                });
                                                console.log(`  âœ“ Added slave ${slaveId} from slaves list, sending preset update`);
                                                // Send preset update to ensure sound preset is synced
                                                if (!isSlave && ws.value && ws.value.readyState === WebSocket.OPEN) {
                                                    setTimeout(() => {
                                                        sendPresetToSlaves();
                                                    }, 100);
                                                }
                                            }
                                        });
                                        
                                        console.log(`  âœ“ Synced connectedSlaves with server: ${connectedSlaves.length} unique slaves`);
                                        console.log(`  Slaves:`, connectedSlaves.map(s => `${s.name} (${s.id})`));
                                        
                                        // Send preset update to all slaves after syncing list to ensure sound preset is synced
                                        if (!isSlave && ws.value && ws.value.readyState === WebSocket.OPEN && connectedSlaves.length > 0) {
                                            setTimeout(() => {
                                                console.log(`  ðŸ“¤ Sending preset update to all ${connectedSlaves.length} slaves after sync`);
                                                sendPresetToSlaves();
                                            }, 200);
                                        }
                                        
                                        // Calculate assigned notes for all slaves (master knows the distribution logic)
                                        const enabledNotes = noteData.filter(n => n.enabled);
                                        if (enabledNotes.length > 0 && connectedSlaves.length > 0) {
                                            console.log(`  ðŸ“Š Calculating assigned notes for ${connectedSlaves.length} slaves...`);
                                            distributeNotesToSlaves(enabledNotes, settings.masterIncluded);
                                            console.log(`  âœ“ Assigned notes calculated for all slaves`);
                                        }
                                        
                                        // Also send preset to server to ensure slaves receive it
                                        const slavesWithoutNotes = connectedSlaves.filter(slave => !slave.assignedNotes || slave.assignedNotes.length === 0);
                                        if (slavesWithoutNotes.length > 0) {
                                            console.log(`  âš ï¸ ${slavesWithoutNotes.length} slaves still have no assigned notes after calculation`);
                                        }
                                        
                                        // Send preset to server to ensure slaves receive notes
                                        if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                            setTimeout(() => {
                                                sendPresetToSlaves();
                                                console.log(`  âœ“ Preset sent to server for slave distribution`);
                                            }, 100);
                                        } else {
                                            console.warn(`  âš ï¸ WebSocket not ready, notes calculated locally but not sent to server`);
                                        }
                                        
                                        // Verify count matches
                                        if (connectedSlaves.length !== data.count) {
                                            console.warn(`  âš ï¸ Count mismatch: connectedSlaves.length=${connectedSlaves.length}, data.count=${data.count}`);
                                        }
                                    }
                                    
                                    // Automatically update numGenerators to match number of slaves
                                    if (data.count !== undefined && data.count >= 0) {
                                        const newGeneratorCount = Math.max(1, data.count); // At least 1 generator
                                        if (settings.numGenerators !== newGeneratorCount) {
                                            console.log(`  ðŸ”„ Auto-updating generators: ${settings.numGenerators} â†’ ${newGeneratorCount} (matching ${data.count} slaves)`);
                                            settings.numGenerators = newGeneratorCount;
                                        }
                                    }
                                } else if (data.type === 'notes_assigned') {
                                    // Master received assigned notes from server
                                    console.log('âœ“âœ“âœ“ Master received assigned notes:', data.notes.length, 'notes');
                                    console.log('Notes:', data.notes.map(n => n.note));
                                    masterAssignedNotes.value = data.notes;
                                    console.log('masterAssignedNotes.value updated to:', masterAssignedNotes.value.length, 'notes');
                                    // Update settings from server
                                    if (data.preset) {
                                        settings.noteLength = data.preset.noteLength;
                                        settings.pauseLength = data.preset.pauseLength;
                                        settings.masterVolume = data.preset.masterVolume;
                                        // Don't override numGenerators - it's auto-managed based on slave count
                                        // settings.numGenerators is automatically set to match totalSlaves
                                    }
                                    // If already playing, restart generators with new notes
                                    if (isPlaying.value) {
                                        console.log('Master is playing, restarting generators with new notes...');
                                        startAllGenerators();
                                    } else {
                                        console.log('Master not playing, notes updated but not restarting');
                                    }
                                } else if (data.type === 'slave_notes_assigned') {
                                    // Slave reported its assigned notes
                                    console.log('ðŸ“¥ Master received slave_notes_assigned:', data);
                                    console.log('  Slave ID:', data.slaveId);
                                    console.log('  Notes count:', data.notes?.length);
                                    console.log('  All connected slaves:', connectedSlaves.map(s => `${s.name} (${s.id})`));
                                    
                                    if (!data.slaveId || !data.notes) {
                                        console.error(`  âœ— Invalid slave_notes_assigned message: missing slaveId or notes`);
                                        return;
                                    }
                                    
                                    // Try to find the slave by exact ID match
                                    let slave = connectedSlaves.find(s => s.id === data.slaveId);
                                    
                                    // If not found, try string comparison (in case of type mismatch)
                                    if (!slave) {
                                        console.log(`  Trying string comparison for slave ID...`);
                                        slave = connectedSlaves.find(s => String(s.id) === String(data.slaveId));
                                    }
                                    
                                    // If still not found, try partial match (in case IDs are truncated)
                                    if (!slave) {
                                        console.log(`  Trying partial match for slave ID...`);
                                        slave = connectedSlaves.find(s => 
                                            String(s.id).startsWith(String(data.slaveId)) || 
                                            String(data.slaveId).startsWith(String(s.id))
                                        );
                                    }
                                    
                                    if (slave) {
                                        if (data.notes && Array.isArray(data.notes)) {
                                            slave.assignedNotes = data.notes;
                                            console.log(`  âœ“âœ“âœ“ Updated assigned notes for slave ${slave.name} (${slave.id}):`, data.notes.map(n => n.note));
                                            console.log(`  Slave object after update:`, slave);
                                        } else {
                                            console.warn(`  âš ï¸ Invalid notes data for slave ${slave.name}:`, data.notes);
                                        }
                                    } else {
                                        console.warn(`  âš ï¸ Slave "${data.slaveId}" not found in connectedSlaves - storing notes for later`);
                                        console.warn(`  Available slave IDs:`, connectedSlaves.map(s => `"${s.id}"`));
                                        console.warn(`  Available slave names:`, connectedSlaves.map(s => `${s.name} (${s.id})`));
                                        
                                        // Store notes temporarily - they'll be matched when slave list syncs
                                        // Add a pending notes object that will be matched on next sync
                                        if (!window.pendingSlaveNotes) {
                                            window.pendingSlaveNotes = {};
                                        }
                                        window.pendingSlaveNotes[data.slaveId] = data.notes;
                                        console.log(`  âœ“ Stored pending notes for slave ${data.slaveId} (${data.notes.length} notes), will apply on next sync`);
                                        
                                        // Also try to match by checking if any slave ID contains this ID or vice versa
                                        const partialMatch = connectedSlaves.find(s => 
                                            String(s.id).includes(String(data.slaveId)) || 
                                            String(data.slaveId).includes(String(s.id))
                                        );
                                        if (partialMatch) {
                                            console.log(`  ðŸ” Found partial match! Applying notes to ${partialMatch.name} (${partialMatch.id})`);
                                            partialMatch.assignedNotes = data.notes;
                                            delete window.pendingSlaveNotes[data.slaveId];
                                        }
                                    }
                                } else if (data.type === 'note_playing') {
                                    // Slave reported currently playing note
                                    console.log('ðŸŽµ Master received note_playing:', data);
                                    console.log('  Slave ID:', data.slaveId);
                                    console.log('  Note:', data.note);
                                    
                                    if (!data.slaveId || !data.note) {
                                        console.error(`  âœ— Invalid note_playing message: missing slaveId or note`);
                                        return;
                                    }
                                    
                                    // Try to find the slave by exact ID match
                                    let slave = connectedSlaves.find(s => s.id === data.slaveId);
                                    
                                    // If not found, try string comparison (in case of type mismatch)
                                    if (!slave) {
                                        console.log(`  Trying string comparison for slave ID...`);
                                        slave = connectedSlaves.find(s => String(s.id) === String(data.slaveId));
                                    }
                                    
                                    // If still not found, try partial match (in case IDs are truncated)
                                    if (!slave) {
                                        console.log(`  Trying partial match for slave ID...`);
                                        slave = connectedSlaves.find(s => 
                                            String(s.id).startsWith(String(data.slaveId)) || 
                                            String(data.slaveId).startsWith(String(s.id)) ||
                                            String(s.id).includes(String(data.slaveId)) || 
                                            String(data.slaveId).includes(String(s.id))
                                        );
                                    }
                                    
                                    if (slave) {
                                        slave.currentlyPlayingNote = data.note;
                                        console.log(`  âœ“âœ“âœ“ Slave ${slave.name} (${slave.id}) is playing: ${data.note}`);
                                        
                                        // Clear currently playing note after note duration (for visual feedback)
                                        setTimeout(() => {
                                            if (slave.currentlyPlayingNote === data.note) {
                                                slave.currentlyPlayingNote = null;
                                                console.log(`  âœ“ Cleared playing note for slave ${slave.name}`);
                                            }
                                        }, (settings.noteLength * 1000) + 100); // Clear after note duration + small buffer
                                    } else {
                                        console.warn(`  âš ï¸ Slave "${data.slaveId}" not found in connectedSlaves for note_playing`);
                                        console.warn(`  Available slave IDs:`, connectedSlaves.map(s => `"${s.id}"`));
                                        
                                        // Add unknown slave to list (it might have reconnected with new ID)
                                        // This handles the case where slave_connected event was missed or delayed
                                        console.log(`  ðŸ“¥ Adding unknown slave ${data.slaveId} to connectedSlaves`);
                                        connectedSlaves.push({
                                            id: data.slaveId,
                                            name: String(connectedSlaves.length + 1), // Assign next number
                                            volume: 100, // Default volume
                                            assignedNotes: [], // Will be populated by next notes_assigned
                                            currentlyPlayingNote: data.note
                                        });
                                        console.log(`  âœ“ Added slave ${data.slaveId} to list (now ${connectedSlaves.length} slaves)`);
                                        
                                        // Request fresh slave list from server to ensure sync
                                        if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                            console.log(`  ðŸ“¤ Requesting fresh slave list from server...`);
                                            // The server will send 'slaves' list when master connects, but we can trigger it
                                            // by sending a message that causes server to respond with current state
                                            // Actually, just wait for next slave_connected/disconnected event or request preset
                                            sendPresetToSlaves(); // This will also sync the list via server response
                                        }
                                        
                                        // Clear currently playing note after note duration
                                        setTimeout(() => {
                                            const addedSlave = connectedSlaves.find(s => s.id === data.slaveId);
                                            if (addedSlave && addedSlave.currentlyPlayingNote === data.note) {
                                                addedSlave.currentlyPlayingNote = null;
                                                console.log(`  âœ“ Cleared playing note for added slave ${data.slaveId}`);
                                            }
                                        }, (settings.noteLength * 1000) + 100);
                                    }
                                } else if (data.type === 'slave_connected' || data.type === 'slave_disconnected') {
                                    // Always send preset to slaves when they connect/disconnect
                                    // This ensures new slaves get notes even if master isn't playing
                                    console.log('ðŸ“¡ Slave connected/disconnected event received');
                                    console.log('  Type:', data.type);
                                    console.log('  Slave ID:', data.slaveId);
                                    console.log('  Total slaves:', data.totalSlaves);
                                    
                                    // Update total slaves count
                                    totalSlaves.value = data.totalSlaves || 0;
                                    
                                    // Sync connectedSlaves array with server's actual count
                                    // If we have more slaves in our list than the server reports, request fresh list
                                    if (connectedSlaves.length > data.totalSlaves) {
                                        console.warn(`  âš ï¸ Mismatch: We have ${connectedSlaves.length} slaves but server reports ${data.totalSlaves}`);
                                        console.warn(`  Requesting fresh slave list from server...`);
                                        // Request fresh slave list by sending a dummy message that will trigger server to send slaves list
                                        // Actually, we'll just trim our list to match the count for now
                                        // The server will send a fresh 'slaves' message when master reconnects or we can request it
                                    }
                                    
                                    // Update connectedSlaves array
                                    if (data.type === 'slave_connected') {
                                        // Add new slave if not already in list
                                        if (!data.slaveId) {
                                            console.warn('  âš ï¸ slave_connected event missing slaveId');
                                            return;
                                        }
                                        const existingSlave = connectedSlaves.find(s => s.id === data.slaveId);
                                        if (!existingSlave) {
                                            // Always add new slaves - don't restrict by count to avoid race conditions
                                            connectedSlaves.push({
                                                id: data.slaveId,
                                                name: data.slaveName || String(connectedSlaves.length + 1), // Use name from server if provided
                                                volume: 100, // Default volume
                                                assignedNotes: [] // Initialize empty notes array
                                            });
                                            console.log(`  âœ“ Added new slave ${data.slaveId} to connectedSlaves`);
                                            // Immediately send current preset to new slave
                                            setTimeout(() => {
                                                if (!isSlave && ws.value && ws.value.readyState === WebSocket.OPEN) {
                                                    console.log(`  ðŸ“¤ Sending current preset to newly connected slave ${data.slaveId}`);
                                                    sendPresetToSlaves();
                                                }
                                            }, 100);
                                            console.log(`  âœ“ Added slave ${data.slaveId} (${data.slaveName || 'unnamed'}) to connectedSlaves (total: ${connectedSlaves.length}, server reports: ${data.totalSlaves})`);
                                            
                                            // Immediately distribute notes to the new slave
                                            const enabledNotes = noteData.filter(n => n.enabled);
                                            if (enabledNotes.length > 0) {
                                                console.log(`  ðŸ“Š Distributing notes to newly connected slave...`);
                                                distributeNotesToSlaves(enabledNotes, settings.masterIncluded);
                                            }
                                            
                                            // Warn if count doesn't match (but don't prevent adding)
                                            if (connectedSlaves.length > data.totalSlaves && data.totalSlaves > 0) {
                                                console.warn(`  âš ï¸ Slave count mismatch: We have ${connectedSlaves.length}, server reports ${data.totalSlaves}`);
                                            }
                                        } else {
                                            // Update name if provided
                                            if (data.slaveName && existingSlave.name !== data.slaveName) {
                                                existingSlave.name = data.slaveName;
                                                console.log(`  â„¹ï¸ Updated slave ${data.slaveId} name to ${data.slaveName}`);
                                            } else {
                                                console.log(`  â„¹ï¸ Slave ${data.slaveId} already in list, skipping`);
                                            }
                                        }
                                    } else if (data.type === 'slave_disconnected') {
                                        // Remove disconnected slave
                                        if (!data.slaveId) {
                                            console.warn('  âš ï¸ slave_disconnected event missing slaveId');
                                            return;
                                        }
                                        const index = connectedSlaves.findIndex(s => s.id === data.slaveId);
                                        if (index !== -1) {
                                            connectedSlaves.splice(index, 1);
                                            console.log(`  âœ“ Removed slave ${data.slaveId} from connectedSlaves (remaining: ${connectedSlaves.length}, server reports: ${data.totalSlaves})`);
                                        } else {
                                            console.log(`  â„¹ï¸ Slave ${data.slaveId} not found in list, already removed`);
                                        }
                                    }
                                    
                                    // Final check: if our list doesn't match server's count, trim to match
                                    if (connectedSlaves.length !== data.totalSlaves && data.totalSlaves >= 0) {
                                        console.warn(`  âš ï¸ Slave count mismatch: We have ${connectedSlaves.length}, server has ${data.totalSlaves}`);
                                        if (connectedSlaves.length > data.totalSlaves) {
                                            // We have too many - remove excess (keep first N)
                                            console.warn(`  Trimming excess slaves, keeping first ${data.totalSlaves}`);
                                            connectedSlaves.splice(data.totalSlaves);
                                        } else {
                                            console.warn(`  We have fewer slaves than server reports - this should be corrected by slave_connected events`);
                                        }
                                    }
                                    
                                    // Automatically update numGenerators to match number of slaves
                                    if (data.totalSlaves !== undefined && data.totalSlaves >= 0) {
                                        const newGeneratorCount = Math.max(1, data.totalSlaves); // At least 1 generator
                                        if (settings.numGenerators !== newGeneratorCount) {
                                            console.log(`  ðŸ”„ Auto-updating generators: ${settings.numGenerators} â†’ ${newGeneratorCount} (matching ${data.totalSlaves} slaves)`);
                                            settings.numGenerators = newGeneratorCount;
                                        }
                                    }
                                    
                                    console.log('  WebSocket ready:', ws.value && ws.value.readyState === WebSocket.OPEN);
                                    console.log('  Current enabled notes:', noteData.filter(n => n.enabled).length);
                                    console.log('  Sending preset to slaves...');
                                    sendPresetToSlaves();
                                    console.log('  âœ“ Preset send initiated');
                                } else if (data.type === 'slave_requested_preset') {
                                    // A slave requested the current preset (e.g., after reconnection)
                                    console.log('ðŸ“¡ Slave requested preset');
                                    console.log('  Slave ID:', data.slaveId);
                                    console.log('  Sending current preset...');
                                    sendPresetToSlaves();
                                    console.log('  âœ“ Preset sent to requesting slave');
                                }
                            }
                        } catch (e) {
                            console.error('Error parsing WebSocket message:', e);
                        }
                    };
                    
                    websocket.onerror = (error) => {
                        const errorMsg = `WebSocket error: ${error.type || 'unknown'} - ${error.message || 'Connection failed'}`;
                        wsError.value = errorMsg;
                        console.error('=== WebSocket Error ===');
                        console.error('Error:', error);
                        console.error('WebSocket URL was:', wsUrl);
                        console.error('WebSocket readyState:', websocket.readyState);
                        console.error('Error type:', error.type);
                        console.error('Error message:', error.message || 'No message');
                        console.error('Error target:', error.target);
                        console.error('Error currentTarget:', error.currentTarget);
                        // Update connection status
                        ws.value = websocket;
                        // Show helpful error message
                        if (isSlave) {
                            console.error('Slave WebSocket connection failed. Check:');
                            console.error('1. URL:', wsUrl);
                            console.error('2. Server running on port 3000');
                            console.error('3. Both devices on same network');
                            console.error('4. Check Safari console for more details');
                        }
                        // Clear error after 10 seconds
                        setTimeout(() => {
                            wsError.value = null;
                        }, 10000);
                    };
                    
                    websocket.onclose = (event) => {
                        clearTimeout(connectionTimeout); // Clear timeout when connection closes
                        wsConnected.value = false;
                        wsReceivedWelcome.value = false;
                        console.log('WebSocket disconnected, code:', event.code, 'reason:', event.reason || 'none');
                        console.log('Was clean:', event.wasClean);
                        console.log('Close event details:', {
                            code: event.code,
                            reason: event.reason,
                            wasClean: event.wasClean,
                            url: wsUrl
                        });
                        
                        // Stop drone note smoothly before closing connection
                        if (isSlave) {
                            console.log('Stopping drone note due to connection close...');
                            stopDroneNote();
                        }
                        
                        ws.value = null;
                        
                        // Show error for common error codes
                        if (event.code === 1006) {
                            const errorMsg = `Connection closed abnormally (code ${event.code}). Check network connection.`;
                            wsError.value = errorMsg;
                            console.error('WebSocket closed abnormally (connection refused or network error)');
                            if (isSlave) {
                                // Don't show alert, just show error in UI
                                console.error('Cannot connect to WebSocket server. URL:', wsUrl);
                            }
                            // Clear error after 10 seconds
                            setTimeout(() => {
                                wsError.value = null;
                            }, 10000);
                        } else if (event.code === 1001 && isSlave) {
                            // Code 1001 = going away - connection closed unexpectedly (common on iOS Safari)
                            console.warn('WebSocket closed unexpectedly (code 1001) - this is common on iOS Safari');
                            console.log('Will attempt to reconnect immediately...');
                            // Reconnect immediately for iOS Safari (don't wait)
                            setTimeout(() => {
                                console.log('Reconnecting after iOS Safari close (code 1001)...');
                                ws.value = null;
                                connectWebSocket();
                            }, 500);
                            return; // Exit early, don't continue with normal reconnection
                        }
                        
                        // Reconnect after delay (only if not a clean close)
                        // For iOS Safari, code 1001 is common when app goes to background, so always try to reconnect
                        if (!event.wasClean || event.code !== 1000 || event.code === 1001) {
                            setTimeout(() => {
                                console.log('Attempting to reconnect WebSocket...');
                                connectWebSocket();
                            }, 2000);
                        }
                    };
                    } catch (e) {
                        console.error('Failed to create WebSocket:', e);
                        if (isSlave) {
                            alert('Failed to create WebSocket connection: ' + e.message + '\nURL: ' + wsUrl);
                        }
                        // Retry after delay
                        setTimeout(() => {
                            connectWebSocket();
                        }, 3000);
                    }
                };
                
                const startSlavePlayback = () => {
                    console.log('=== startSlavePlayback called ===');
                    console.log('assignedNotes:', assignedNotes.value.length);
                    console.log('isPlaying:', isPlaying.value);
                    console.log('audioContext:', !!audioContext, 'state:', audioContext?.state);
                    console.log('masterGain:', !!masterGain);
                    
                    // Ensure we're marked as playing
                    if (!isPlaying.value) {
                        console.log('Setting isPlaying to true');
                        isPlaying.value = true;
                    }
                    
                    // Clear any existing timeouts FIRST
                    generatorTimeouts.forEach(timeout => {
                        if (timeout) clearTimeout(timeout);
                    });
                    generatorTimeouts.length = 0;
                    
                    // Stop ALL active oscillators before clearing arrays
                    generatorOscillators.forEach((oscSet, idx) => {
                        if (oscSet) {
                            oscSet.forEach(osc => {
                                if (osc && !osc._isPlaceholder && typeof osc.stop === 'function') {
                                    try {
                                        osc.stop();
                                    } catch (e) {
                                        console.warn('Error stopping oscillator:', e);
                                    }
                                }
                            });
                            oscSet.clear();
                        }
                    });
                    
                    // Clear arrays
                    generatorNoteEndTimes.length = 0;
                    generatorOscillators.length = 0;
                    lastNoteEndTime = 0;
                    isNotePlaying = false;
                    
                    if (assignedNotes.value.length === 0) {
                        console.log('No assigned notes, cannot start playback');
                        slaveStatus.value = 'No notes assigned';
                        return;
                    }
                    
                    // Initialize note rotation: create a shuffled array of indices to ensure all notes are played
                    const indices = Array.from({ length: assignedNotes.value.length }, (_, i) => i);
                    // Fisher-Yates shuffle
                    for (let i = indices.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [indices[i], indices[j]] = [indices[j], indices[i]];
                    }
                    shuffledNoteIndices.value = indices;
                    noteRotationIndex.value = 0;
                    console.log('Initialized note rotation with', assignedNotes.value.length, 'notes, shuffled order:', shuffledNoteIndices.value);
                    
                    if (!audioContext || !masterGain) {
                        console.log('Audio context not ready');
                        slaveStatus.value = 'Audio not ready';
                        return;
                    }
                    
                    // Ensure audio context is running - but don't block if suspended
                    if (audioContext.state === 'suspended') {
                        console.log('Audio context suspended, attempting to resume...');
                        // Try to resume, but don't wait - start playback anyway
                        audioContext.resume().then(() => {
                            console.log('Audio context resumed successfully');
                        }).catch(e => {
                            console.log('Audio resume failed, but continuing playback:', e.message);
                        });
                        // Continue with playback even if resume fails - might still work
                    }
                    
                    // Slaves always use 1 generator to prevent overlap within a single flake
                    // Each flake should play one note at a time
                    const numGenerators = 1;
                    console.log('Starting', numGenerators, 'generator(s) with', assignedNotes.value.length, 'notes');
                    slaveStatus.value = 'Playing';
                    
                    // CRITICAL: Ensure arrays are exactly the right size (no extra generators)
                    // Initialize generator arrays for independent tracking
                    generatorOscillators.length = numGenerators;
                    generatorNoteEndTimes.length = numGenerators;
                    generatorTimeouts.length = numGenerators;
                    
                    for (let i = 0; i < numGenerators; i++) {
                        generatorOscillators[i] = new Set(); // Always create fresh Set
                        generatorNoteEndTimes[i] = null; // Always reset to null
                        generatorTimeouts[i] = null; // Always reset to null
                    }
                    
                    // Start ONLY the first generator (index 0)
                    const startDelay = 0;
                    const timeout = setTimeout(() => {
                        console.log('Generator 0 timeout fired, isPlaying:', isPlaying.value);
                        if (isPlaying.value) {
                            console.log('Calling scheduleSlaveNote for generator 0');
                            scheduleSlaveNote(0);
                        } else {
                            console.log('Not playing, skipping generator 0');
                        }
                    }, startDelay);
                    generatorTimeouts[0] = timeout;
                    console.log('Scheduled generator 0 to start in', startDelay, 'ms');
                    console.log('Total generators initialized:', numGenerators, '(should be 1)');
                    console.log('=== startSlavePlayback complete ===');
                    console.log('Total generator timeouts:', generatorTimeouts.length);
                };
                
                const scheduleSlaveNote = (generatorId) => {
                    // CRITICAL: Slaves should ONLY use generator 0
                    // If somehow generatorId is not 0, force it to 0 and log a warning
                    if (generatorId !== 0) {
                        console.error('âš ï¸âš ï¸âš ï¸ WARNING: scheduleSlaveNote called with generatorId', generatorId, 'but slaves should only use generator 0! Forcing to 0.');
                        generatorId = 0;
                    }
                    
                    // Check if still playing and have notes
                    if (!isPlaying.value) {
                        console.log('scheduleSlaveNote: stopped playing, generator:', generatorId);
                        return;
                    }
                    
                    if (!audioContext || !masterGain) {
                        console.error('Audio context not ready in scheduleSlaveNote');
                        return;
                    }
                    
                    // Prevent overlap - check if THIS SPECIFIC GENERATOR is still playing
                    const now = audioContext.currentTime;
                    
                    // Initialize generator arrays if needed (but ensure we only use index 0)
                    if (!generatorOscillators[0]) {
                        generatorOscillators[0] = new Set();
                    }
                    if (generatorNoteEndTimes[0] === undefined) {
                        generatorNoteEndTimes[0] = null;
                    }
                    
                    // Force use of generator 0
                    const actualGeneratorId = 0;
                    
                    // Check if THIS generator has any oscillators actively playing (including placeholders)
                    const thisGeneratorOscillators = generatorOscillators[actualGeneratorId];
                    if (thisGeneratorOscillators && thisGeneratorOscillators.size > 0) {
                        // Count actual oscillators vs placeholders
                        const items = Array.from(thisGeneratorOscillators);
                        const actualOscillators = items.filter(osc => !osc._isPlaceholder);
                        const placeholders = items.filter(osc => osc._isPlaceholder);
                        
                        // Block if there are any oscillators OR placeholders (placeholders mean a note is starting)
                        if (actualOscillators.length > 0 || placeholders.length > 0) {
                            console.log('Generator', actualGeneratorId, ': BLOCKED - oscillator still playing (', actualOscillators.length, 'oscillators,', placeholders.length, 'placeholders), waiting...');
                            const timeout = setTimeout(() => scheduleSlaveNote(actualGeneratorId), 100);
                            generatorTimeouts[actualGeneratorId] = timeout;
                            return;
                        }
                    }
                    
                    // Check if THIS generator's note end time has passed
                    const thisGeneratorEndTime = generatorNoteEndTimes[actualGeneratorId];
                    if (thisGeneratorEndTime !== null && thisGeneratorEndTime !== undefined && now < thisGeneratorEndTime) {
                        // This generator's note is still playing based on timing, wait until it finishes
                        const waitTime = Math.max(50, (thisGeneratorEndTime - now) * 1000); // Minimum 50ms
                        console.log('Generator', actualGeneratorId, ': BLOCKED - note still playing, waiting', waitTime.toFixed(0), 'ms (end time:', thisGeneratorEndTime.toFixed(3), 's, now:', now.toFixed(3), 's, remaining:', (thisGeneratorEndTime - now).toFixed(3), 's)');
                        const timeout = setTimeout(() => scheduleSlaveNote(actualGeneratorId), waitTime);
                        generatorTimeouts[actualGeneratorId] = timeout;
                        return;
                    }
                    
                    // Double-check: if note end time exists but is in the past, clear it
                    if (thisGeneratorEndTime !== null && thisGeneratorEndTime !== undefined && now >= thisGeneratorEndTime) {
                        console.log('Generator', actualGeneratorId, ': clearing expired note end time (', thisGeneratorEndTime.toFixed(3), 's < now:', now.toFixed(3), 's)');
                        generatorNoteEndTimes[actualGeneratorId] = null;
                    }
                    
                    console.log('Generator', actualGeneratorId, ': âœ“ Overlap check PASSED - no active oscillators, proceeding to play note');
                    
                    // CRITICAL: Reserve this generator slot IMMEDIATELY after passing overlap check
                    // This prevents race conditions where multiple calls pass the check simultaneously
                    const placeholder = { _isPlaceholder: true, generatorId: actualGeneratorId, timestamp: now };
                    thisGeneratorOscillators.add(placeholder);
                    console.log('Generator', actualGeneratorId, ': reserved slot with placeholder, total active:', thisGeneratorOscillators.size);
                    
                    if (assignedNotes.value.length === 0) {
                        console.log('scheduleSlaveNote: no notes assigned, generator:', actualGeneratorId);
                        const timeout = setTimeout(() => scheduleSlaveNote(actualGeneratorId), settings.pauseLength * 1000);
                        generatorTimeouts[actualGeneratorId] = timeout;
                        return;
                    }
                    
                    // Check audio context state - resume if suspended
                    if (audioContext && audioContext.state === 'suspended') {
                        console.log('Audio context suspended during playback, resuming...');
                        audioContext.resume().then(() => {
                            console.log('Audio context resumed, continuing playback');
                        }).catch(e => {
                            console.error('Failed to resume audio context:', e);
                        });
                    }
                    
                    // Pick next note from rotation to ensure all notes are played
                    // Initialize shuffle if empty, or reshuffle if we've played all notes
                    if (shuffledNoteIndices.value.length === 0 || noteRotationIndex.value >= shuffledNoteIndices.value.length) {
                        if (shuffledNoteIndices.value.length === 0) {
                            console.log('Initializing note rotation...');
                        } else {
                            console.log('All notes played, reshuffling...');
                        }
                        const indices = Array.from({ length: assignedNotes.value.length }, (_, i) => i);
                        // Fisher-Yates shuffle
                        for (let i = indices.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [indices[i], indices[j]] = [indices[j], indices[i]];
                        }
                        shuffledNoteIndices.value = indices;
                        noteRotationIndex.value = 0;
                        console.log('Note order:', shuffledNoteIndices.value);
                    }
                    
                    const noteIndex = shuffledNoteIndices.value[noteRotationIndex.value];
                    const note = assignedNotes.value[noteIndex];
                    const currentNoteNumber = noteRotationIndex.value + 1;
                    noteRotationIndex.value++;
                    console.log('Playing note', currentNoteNumber, 'of', assignedNotes.value.length, ':', note.note, '(index', noteIndex, 'in assigned notes)');
                    
                    // Calculate note duration FIRST (with randomness: Â±2 seconds)
                    // Random between noteLength-2 and noteLength+2, but ensure minimum 0.1 seconds
                    const baseDuration = settings.noteLength + (Math.random() * 4 - 2); // Random between noteLength-2 and noteLength+2
                    const noteDuration = Math.max(0.1, baseDuration); // Ensure minimum 0.1 seconds (allows very short notes if noteLength is small)
                    console.log('Duration calculation: noteLength=', settings.noteLength, 'baseDuration=', baseDuration.toFixed(2), 'finalDuration=', noteDuration.toFixed(2));
                    // Note: 'now' is already declared above in the overlap prevention check
                    
                    // Get current preset to account for release time
                    const currentPreset = synthPresets.find(p => p.name === currentPresetName.value) || synthPresets[0];
                    // For warm synth voices, use preset release time (fade-out happens AFTER note duration)
                    // For simple sine, fade-out happens WITHIN note duration, so no extra time needed
                    const releaseTime = (currentPreset.type === 'warm' && currentPreset.release) ? currentPreset.release : 0; // Only add release time for warm synth voices
                    
                    console.log('=== Slave playing note ===');
                    console.log('Note:', note.note, note.freq, 'Hz, generator:', generatorId);
                    console.log('Base note length:', settings.noteLength, 's');
                    console.log('Calculated duration:', baseDuration.toFixed(2), 's');
                    console.log('Final note duration:', noteDuration.toFixed(2), 's');
                    console.log('Release time:', releaseTime.toFixed(2), 's');
                    console.log('Audio context state:', audioContext?.state);
                    console.log('Master gain:', !!masterGain);
                    console.log('isPlaying:', isPlaying.value);
                    console.log('Particles before:', particles.length);
                    
                    // CRITICAL: Get audio context time RIGHT BEFORE playing
                    // This ensures accurate timing calculation
                    const noteStartTime = audioContext.currentTime;
                    // Note end time: for warm synth, includes release phase; for simple sine, fade-out is already included in duration
                    const noteEndTime = noteStartTime + noteDuration + releaseTime;
                    generatorNoteEndTimes[actualGeneratorId] = noteEndTime;
                    console.log('Generator', actualGeneratorId, ': note starts at:', noteStartTime.toFixed(3), 's, will end at:', noteEndTime.toFixed(3), 's, duration:', noteDuration.toFixed(3), 's');
                    // Placeholder was already added above after overlap check passed
                    
                    // Notify master about currently playing note
                    if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                        try {
                            ws.value.send(JSON.stringify({
                                type: 'note_playing',
                                slaveId: slaveId, // Include slave ID so master knows which slave is playing
                                note: note.note,
                                freq: note.freq,
                                color: note.color
                            }));
                        } catch (e) {
                            console.error('Error sending note_playing message:', e);
                        }
                    }
                    
                    // Pass the calculated duration and actualGeneratorId to playNote so it uses the same value
                    // playNote will replace the placeholder with the actual oscillator
                    playNote(note.freq, note.volume, note.color, noteDuration, note.note, actualGeneratorId);
                    console.log('Particles after:', particles.length);
                    console.log('========================');
                    
                    // Calculate pause delay (with randomness: Â±2 seconds, minimum 0.1 seconds)
                    const basePauseDuration = settings.pauseLength + (Math.random() * 4 - 2); // Random between pauseLength-2 and pauseLength+2 seconds
                    const pauseDuration = Math.max(0.1, basePauseDuration); // Ensure minimum 0.1 seconds to prevent notes from jumping
                    
                    // CRITICAL: The pause starts AFTER the note ends, not after it starts
                    // So the next note should start at: noteEndTime + pauseDuration
                    const nextNoteStartTime = noteEndTime + pauseDuration;
                    
                    // Track when this generator's next note should start (for overlap prevention)
                    generatorNextNoteTimes[actualGeneratorId] = nextNoteStartTime;
                    if (nextNoteStartTime > lastNextNoteTime) {
                        lastNextNoteTime = nextNoteStartTime;
                    }
                    
                    // Get current audio context time RIGHT NOW for accurate delay calculation
                    const nowForScheduling = audioContext.currentTime;
                    
                    // Calculate delay in milliseconds from NOW until next note should start
                    const delayUntilNextNote = (nextNoteStartTime - nowForScheduling) * 1000;
                    
                    console.log('Generator', actualGeneratorId, 'scheduling next note:');
                    console.log('  Note duration:', noteDuration.toFixed(3), 's');
                    console.log('  Pause duration:', pauseDuration.toFixed(3), 's');
                    console.log('  Note started at:', noteStartTime.toFixed(3), 's');
                    console.log('  Note ends at:', noteEndTime.toFixed(3), 's');
                    console.log('  Pause ends at:', nextNoteStartTime.toFixed(3), 's (noteEnd + pause)');
                    console.log('  Current time (now):', nowForScheduling.toFixed(3), 's');
                    console.log('  Delay until next:', delayUntilNextNote.toFixed(0), 'ms');
                    console.log('  Time until note ends:', ((noteEndTime - nowForScheduling) * 1000).toFixed(0), 'ms');
                    console.log('  Time until pause ends:', ((nextNoteStartTime - nowForScheduling) * 1000).toFixed(0), 'ms');
                    
                    // Ensure delay is at least 50ms to prevent immediate scheduling
                    const finalDelay = Math.max(50, delayUntilNextNote);
                    if (finalDelay < delayUntilNextNote - 10) {
                        console.warn('Generator', actualGeneratorId, ': WARNING - delay was clamped from', delayUntilNextNote.toFixed(0), 'ms to', finalDelay, 'ms');
                    }
                    if (finalDelay < (pauseDuration * 1000) - 100) {
                        console.error('Generator', actualGeneratorId, ': ERROR - delay (', finalDelay, 'ms) is shorter than pause duration (', (pauseDuration * 1000).toFixed(0), 'ms)!');
                    }
                    const timeout = setTimeout(() => scheduleSlaveNote(actualGeneratorId), finalDelay);
                    generatorTimeouts[actualGeneratorId] = timeout;
                };
                
                // Handle tap to start audio (for iOS Safari autoplay policy)
                // This only unlocks audio - playback starts when master sends 'play' command
                const handleTapToStart = (e) => {
                    console.log('âœ“âœ“âœ“ handleTapToStart called', e.type);
                    e.preventDefault();
                    e.stopPropagation();
                    wsError.value = null;
                    
                    if (!audioUnlocked) {
                        audioUnlocked = true;
                        console.log('Audio unlocked flag set by handleTapToStart');
                    }
                    audioReady.value = true;
                    
                    initAudio().then(() => {
                        console.log('Audio initialized in handleTapToStart, state:', audioContext?.state);
                        
                        // Always try to resume if suspended
                        if (audioContext && audioContext.state === 'suspended') {
                            console.log('Resuming suspended audio context...');
                            const resumePromise = audioContext.resume();
                            const timeoutPromise = new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('Resume timeout')), 2000)
                            );
                            Promise.race([resumePromise, timeoutPromise]).then(() => {
                                console.log('âœ“âœ“âœ“ Audio context unlocked via tap, state:', audioContext.state);
                                slaveStatus.value = 'Ready';
                                // Don't start playback here - wait for master 'play' command
                                // Audio is now unlocked, so future play commands will work automatically
                                // Start drone note to keep audio context active
                                startDroneNote();
                            }).catch(e => {
                                console.log('Audio resume timed out, but audio might still work:', e.message);
                                slaveStatus.value = 'Ready';
                                startDroneNote();
                            });
                        } else {
                            console.log('âœ“ Audio context already ready, state:', audioContext?.state);
                            slaveStatus.value = 'Ready';
                            startDroneNote();
                        }
                        
                        // Ensure overlay can hide even if resume took too long
                        slaveStatus.value = 'Ready';
                        wsError.value = null;
                    }).catch(e => {
                        console.error('âœ— Error initializing audio on tap:', e);
                        slaveStatus.value = 'Ready';
                    });
                };
                
                const toggleMasterIncluded = () => {
                    const oldValue = settings.masterIncluded;
                    settings.masterIncluded = !settings.masterIncluded;
                    console.log('âœ“âœ“âœ“âœ“âœ“ TOGGLE BUTTON CLICKED âœ“âœ“âœ“âœ“âœ“');
                    console.log('Master included toggled from', oldValue, 'to', settings.masterIncluded);
                    console.log('WebSocket exists:', !!ws.value);
                    console.log('WebSocket state:', ws.value ? ws.value.readyState : 'null');
                    console.log('WebSocket OPEN state:', ws.value?.readyState === WebSocket.OPEN);
                    
                    // Force immediate send - don't rely on watch
                    if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                        console.log('âœ“âœ“âœ“ WebSocket ready, immediately calling sendPresetToSlaves()...');
                        sendPresetToSlaves();
                        console.log('âœ“âœ“âœ“ sendPresetToSlaves() called');
                    } else {
                        console.error('âœ—âœ—âœ— WebSocket not ready! State:', ws.value?.readyState);
                        console.error('âœ—âœ—âœ— Cannot send preset update - WebSocket not connected');
                        console.error('ws.value:', ws.value);
                        console.error('readyState:', ws.value?.readyState);
                        console.error('WebSocket.OPEN:', WebSocket.OPEN);
                    }
                };
                
                // Function to distribute notes to slaves (same logic as server)
                const distributeNotesToSlaves = (enabledNotes, includeMaster) => {
                    const totalDevices = includeMaster ? connectedSlaves.length + 1 : connectedSlaves.length;
                    
                    if (totalDevices === 0 || enabledNotes.length === 0) {
                        console.log('No devices or notes to distribute');
                        if (includeMaster) {
                            masterAssignedNotes.value = [];
                        }
                        return;
                    }
                    
                    const notesPerDevice = Math.ceil(enabledNotes.length / totalDevices);
                    
                    // Assign notes to master first if included
                    if (includeMaster) {
                        const masterStartIndex = 0;
                        const masterEndIndex = Math.min(masterStartIndex + notesPerDevice, enabledNotes.length);
                        const masterNotes = enabledNotes.slice(masterStartIndex, masterEndIndex);
                        
                        // If we've run out of notes, wrap around
                        if (masterNotes.length === 0) {
                            masterNotes.push(enabledNotes[0 % enabledNotes.length]);
                        }
                        
                        masterAssignedNotes.value = masterNotes;
                        console.log(`âœ“ Master assigned notes:`, masterNotes.map(n => n.note));
                    } else {
                        masterAssignedNotes.value = [];
                    }
                    
                    // Distribute notes to each slave
                    connectedSlaves.forEach((slave, index) => {
                        const deviceIndex = includeMaster ? index + 1 : index;
                        const startIndex = deviceIndex * notesPerDevice;
                        const endIndex = Math.min(startIndex + notesPerDevice, enabledNotes.length);
                        const assignedNotes = enabledNotes.slice(startIndex, endIndex);
                        
                        // If we've run out of notes, wrap around
                        if (assignedNotes.length === 0) {
                            assignedNotes.push(enabledNotes[deviceIndex % enabledNotes.length]);
                        }
                        
                        // Update slave's assigned notes
                        slave.assignedNotes = assignedNotes;
                        console.log(`âœ“ Master calculated notes for slave ${slave.name} (${slave.id}):`, assignedNotes.map(n => n.note));
                    });
                };
                
                const sendPresetToSlaves = () => {
                    if (!ws.value || ws.value.readyState !== WebSocket.OPEN) {
                        console.log('Cannot send preset: WebSocket not ready');
                        return;
                    }
                    
                    const enabledNotes = noteData.filter(n => n.enabled);
                    
                    // Calculate and update assigned notes for each slave
                    distributeNotesToSlaves(enabledNotes, settings.masterIncluded);
                    
                    // Build per-slave volume map
                    const slaveVolumes = {};
                    connectedSlaves.forEach(slave => {
                        slaveVolumes[slave.id] = slave.volume;
                    });
                    
                    const presetData = {
                        type: 'preset_update',
                        preset: {
                            noteLength: settings.noteLength,
                            pauseLength: settings.pauseLength,
                            masterVolume: settings.masterVolume,
                            numGenerators: settings.numGenerators,
                            masterIncluded: settings.masterIncluded,
                            soundPreset: currentPresetName.value // Include sound preset name
                        },
                        noteData: enabledNotes.map(n => ({
                            note: n.note,
                            freq: n.freq,
                            color: n.color,
                            volume: n.volume,
                            enabled: n.enabled
                        })),
                        slaveVolumes: slaveVolumes // Include per-slave volume multipliers
                    };
                    console.log('ðŸ“¤ Sending preset_update - Sound:', presetData.preset.soundPreset, 'Slaves:', Object.keys(slaveVolumes).length);
                    ws.value.send(JSON.stringify(presetData));
                };
                
                let qrGenerationTimeout = null;
                const scheduleQRCodeGeneration = (targetCanvas = null, delay = 200) => {
                    if (qrGenerationTimeout) {
                        clearTimeout(qrGenerationTimeout);
                    }
                    qrGenerationTimeout = setTimeout(() => {
                        qrGenerationTimeout = null;
                        generateQRCode(targetCanvas);
                    }, delay);
                };
                
                const generateQRCode = (targetCanvas = null) => {
                    // Determine which canvas to use: fullscreen if shown, otherwise regular
                    const canvasToUse = targetCanvas || (showQRCode.value && qrCanvasFullscreen.value ? qrCanvasFullscreen.value : qrCanvas.value);
                    
                    if (!canvasToUse) {
                        setTimeout(() => generateQRCode(targetCanvas), 100);
                        return;
                    }
                    
                    // Check if QRCode library is loaded
                    if (typeof QRCode === 'undefined') {
                        setTimeout(() => generateQRCode(targetCanvas), 200);
                        return;
                    }
                    
            // Get server URL - use current page URL for Railway/production
            // For QR code: use the current page's origin (works for both localhost and Railway)
            // This automatically adapts to domain changes (localhost, Railway, custom domains)
            const qrBaseUrl = window.location.origin;
                    const serverUrl = `${qrBaseUrl}?slave=true`;
                    debugLog('QR Code URL generated:', serverUrl);
                    
                    // Get container dimensions
                    const container = canvasToUse;
                    if (!container) {
                        setTimeout(() => generateQRCode(targetCanvas), 100);
                        return;
                    }
                    
                    // Check if QR code already exists - if URL changed (domain changed), regenerate it
                    const existingQR = container.querySelector('canvas');
                    if (existingQR && existingQR.dataset.qrUrl === serverUrl) {
                        return; // QR code already exists and matches current domain, don't regenerate
                    }
                    // If existing QR has different URL (domain changed), clear it to regenerate with new domain
                    if (existingQR && existingQR.dataset.qrUrl !== serverUrl) {
                        debugLog('Domain changed, regenerating QR code. Old:', existingQR.dataset.qrUrl, 'New:', serverUrl);
                        container.innerHTML = '';
                    }
                    
                    const containerWidth = container.clientWidth || 200;
                    const containerHeight = container.clientHeight || 200;
                    // Use larger size for fullscreen
                    const maxSize = showQRCode.value && qrCanvasFullscreen.value ? 600 : 300;
                    const size = Math.min(containerWidth - 16, containerHeight - 16, maxSize);
                    const finalSize = Math.max(150, size);
                    
                    // Clear container and create new QR code
                    container.innerHTML = '';
                    
                    // Generate QR code directly in the container
                    try {
                        new QRCode(container, {
                            text: serverUrl,
                            width: finalSize,
                            height: finalSize,
                            colorDark: '#000000', // Black QR code
                            colorLight: '#FFFFFF', // White background for visibility
                            correctLevel: QRCode.CorrectLevel.M
                        });
                        // Mark the canvas with the URL so we can check if it needs regeneration
                        const canvas = container.querySelector('canvas');
                        if (canvas) {
                            canvas.dataset.qrUrl = serverUrl;
                        }
                    } catch (e) {
                        console.error('QR Code generation exception:', e);
                    }
                };
                
                // Unlock audio context on first user interaction (for autoplay policy)
                let audioUnlocked = false;
                const unlockAudio = (e) => {
                    try {
                        if (audioUnlocked) {
                            console.log('Audio already unlocked, skipping');
                            audioReady.value = true;
                            return;
                        }
                        audioUnlocked = true;
                        audioReady.value = true;
                        console.log('âœ“âœ“âœ“ Unlocking audio context on first user interaction...', e.type);
                        console.log('Event details:', { type: e.type, target: e.target?.tagName });
                        
                        // Don't prevent default - let the event propagate normally
                        // e.preventDefault() might block audio unlock on iOS
                        
                        // Add timeout to prevent hanging
                        const initAudioWithTimeout = Promise.race([
                            initAudio(),
                            new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('initAudio timeout')), 2000)
                            )
                        ]);
                        
                        initAudioWithTimeout.then(() => {
                            console.log('initAudio completed, audioContext state:', audioContext?.state);
                            console.log('masterGain:', !!masterGain);
                            
                            if (audioContext && audioContext.state === 'suspended') {
                                // Try to resume - this will work if user has interacted
                                console.log('Attempting to resume suspended audio context...');
                                const resumeWithTimeout = Promise.race([
                                    audioContext.resume(),
                                    new Promise((_, reject) => 
                                        setTimeout(() => reject(new Error('Resume timeout')), 1000)
                                    )
                                ]);
                                resumeWithTimeout.then(() => {
                                    console.log('âœ“âœ“âœ“ Audio context unlocked and resumed successfully!');
                                    console.log('New state:', audioContext.state);
                                    if (isSlave) {
                                        slaveStatus.value = 'Ready';
                                        console.log('Slave status set to Ready');
                                    }
                                    
                                    // Start continuous inaudible drone note to keep audio context active
                                    // This prevents iOS Safari from suspending it and keeps device awake
                                    // Works for both master and slaves
                                    startDroneNote();
                                }).catch(err => {
                                    console.error('âœ— Audio context resume failed:', err);
                                    console.log('Audio context unlock attempted, will need interaction later');
                                });
                            } else {
                                console.log('âœ“ Audio context already unlocked, state:', audioContext?.state);
                                if (isSlave && audioContext?.state === 'running') {
                                    slaveStatus.value = 'Ready';
                                    console.log('Slave status set to Ready');
                                }
                            }
                        }).catch(err => {
                            console.error('âœ— initAudio failed/timed out:', err);
                            console.log('Audio unlock attempted, will need interaction later');
                            // Still try to create audio context if it doesn't exist
                            if (!audioContext) {
                                try {
                                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                                    masterGain = audioContext.createGain();
                                    masterGain.gain.value = settings.masterMuted ? 0 : settings.masterVolume / 100;
                                    masterGain.connect(audioContext.destination);
                                    console.log('Created audio context in unlockAudio error handler');
                                } catch (e) {
                                    console.error('Failed to create audio context:', e);
                                }
                            }
                        });
                    } catch (error) {
                        console.error('âœ— unlockAudio error:', error);
                    }
                };
                
                // Add one-time listeners to unlock audio on first interaction
                // Use capture phase and non-passive for better iOS support
                const unlockEvents = ['touchstart', 'touchend', 'click', 'mousedown'];
                unlockEvents.forEach(eventType => {
                    document.addEventListener(eventType, unlockAudio, { once: true, capture: true, passive: false });
                });
                
                // Also add to canvas for better coverage
                if (canvas.value) {
                    unlockEvents.forEach(eventType => {
                        canvas.value.addEventListener(eventType, unlockAudio, { once: true, capture: true, passive: false });
                    });
                }
                
                // Close preset menu when clicking outside
                const handleClickOutside = (event) => {
                    if (showPresetMenu.value && !event.target.closest('.preset-menu-container')) {
                        showPresetMenu.value = false;
                    }
                };
                
                // Watch for tutorial opening to set up scroll listeners
                watch(showTutorial, (isOpen) => {
                    if (isOpen) {
                        setTimeout(() => {
                            const nav = document.getElementById('tutorial-nav');
                            if (nav) {
                                nav.addEventListener('scroll', updateTutorialFade);
                                updateTutorialFade();
                            }
                        }, 100);
                    }
                });
                
                onMounted(() => {
                    document.addEventListener('click', handleClickOutside);
                    // Ensure menu is visible on master when app opens
                    if (!isSlave) {
                        showControls.value = true;
                    }
                    // Initialize QR code state
                    showQRCode.value = false;
                    
                    if (canvas.value) {
                        // Ensure canvas is properly sized before getting context
                    resizeCanvas();
                    ctx.value = canvas.value.getContext('2d');
                        // Resize again after context is set to ensure proper scaling
                        resizeCanvas();
                        // Small delay to ensure DOM is fully ready
                        setTimeout(() => {
                            resizeCanvas();
                    animate();
                        }, 10);
                        
                        // Add unlock listeners to canvas after it's ready
                        const unlockEvents = ['touchstart', 'touchend', 'click', 'mousedown'];
                        unlockEvents.forEach(eventType => {
                            canvas.value.addEventListener(eventType, unlockAudio, { once: true, capture: true, passive: false });
                        });
                    }
                    window.addEventListener('resize', resizeCanvas);
                    
                    // Connect WebSocket
                    console.log('onMounted: Connecting WebSocket...');
                    console.log('Is slave:', isSlave);
                    console.log('Current URL:', window.location.href);
                    connectWebSocket();
                    
                    // For slaves, also try connecting again after a short delay (iOS Safari sometimes needs this)
                    if (isSlave) {
                        setTimeout(() => {
                            if (!wsConnected.value || !ws.value || ws.value.readyState !== WebSocket.OPEN) {
                                console.log('Slave: Retrying WebSocket connection after delay...');
                                connectWebSocket();
                            }
                        }, 1000);
                        
                        // Request wake lock initially (if not already requested)
                        requestWakeLock();
                        
                        // For iOS: Enhanced drone note with higher frequency and volume
                        // iOS respects higher frequency audio more for keeping device awake
                        // We'll modify the drone note to be more effective on iOS
                        const enhanceDroneForIOS = () => {
                            if (!droneOscillator || !droneGain || !audioContext) return;
                            
                            try {
                                // Increase frequency slightly (still inaudible but iOS respects it more)
                                droneOscillator.frequency.value = 18; // Just below human hearing threshold
                                // Increase gain slightly (still inaudible but more "active")
                                droneGain.gain.value = 0.0005; // Slightly louder but still inaudible
                                console.log('âœ“ Enhanced drone note for iOS keep-alive');
                            } catch (e) {
                                console.log('Could not enhance drone:', e);
                            }
                        };
                        
                        // For iOS: Create hidden video element for keep-alive
                        // iOS Safari respects video playback more than audio for preventing sleep
                        // Using technique similar to NoSleep.js library
                        let keepAliveVideo = null;
                        const createKeepAliveVideo = () => {
                            if (keepAliveVideo) return keepAliveVideo;
                            
                            try {
                                keepAliveVideo = document.createElement('video');
                                keepAliveVideo.style.position = 'fixed';
                                keepAliveVideo.style.top = '-9999px';
                                keepAliveVideo.style.left = '-9999px';
                                keepAliveVideo.style.width = '1px';
                                keepAliveVideo.style.height = '1px';
                                keepAliveVideo.style.opacity = '0';
                                keepAliveVideo.style.pointerEvents = 'none';
                                keepAliveVideo.muted = true;
                                keepAliveVideo.playsInline = true;
                                keepAliveVideo.loop = true;
                                keepAliveVideo.autoplay = true;
                                keepAliveVideo.setAttribute('playsinline', 'true');
                                keepAliveVideo.setAttribute('webkit-playsinline', 'true');
                                
                                // Create a minimal video blob (1 frame, silent)
                                // Using a slightly larger canvas for better compatibility
                                const canvas = document.createElement('canvas');
                                canvas.width = 16;
                                canvas.height = 16;
                                const ctx = canvas.getContext('2d');
                                ctx.fillStyle = '#000';
                                ctx.fillRect(0, 0, 16, 16);
                                
                                // Convert to blob and create object URL
                                canvas.toBlob((blob) => {
                                    if (blob) {
                                        const url = URL.createObjectURL(blob);
                                        keepAliveVideo.src = url;
                                        document.body.appendChild(keepAliveVideo);
                                        
                                        // Play the video with multiple attempts
                                        const playVideo = () => {
                                            const playPromise = keepAliveVideo.play();
                                            if (playPromise !== undefined) {
                                                playPromise.catch(e => {
                                                    console.log('Keep-alive video play failed:', e);
                                                    // Retry after a short delay
                                                    setTimeout(() => {
                                                        if (keepAliveVideo && isPlaying.value) {
                                                            playVideo();
                                                        }
                                                    }, 1000);
                                                });
                                            }
                                        };
                                        playVideo();
                                        
                                        // Ensure video stays playing
                                        keepAliveVideo.addEventListener('ended', () => {
                                            if (isPlaying.value) {
                                                keepAliveVideo.play().catch(() => {});
                                            }
                                        });
                                        
                                        keepAliveVideo.addEventListener('pause', () => {
                                            if (isPlaying.value) {
                                                keepAliveVideo.play().catch(() => {});
                                            }
                                        });
                                        
                                        console.log('âœ“ iOS keep-alive video created');
                                    }
                                }, 'image/png');
                            } catch (e) {
                                console.log('Could not create keep-alive video:', e);
                            }
                            
                            return keepAliveVideo;
                        };
                        
                        let iosKeepAliveInterval = null;
                        const runIOSKeepAliveTick = () => {
                            if (!isPlaying.value || !isPageVisible) {
                                return;
                            }
                            // Multiple strategies to keep device awake:
                            // 1. Canvas activity (triggers repaint) - even if not visible
                            if (canvas.value) {
                                const _ = canvas.value.width;
                                const _2 = canvas.value.height;
                                if (ctx.value) {
                                    const _3 = ctx.value.canvas.width;
                                }
                            }
                            // 2. Request wake lock again (in case it was released)
                            requestWakeLock();
                            // 3. Ensure audio context is running (critical for iOS)
                            if (audioContext) {
                                if (audioContext.state === 'suspended') {
                                    console.log('âš ï¸ iOS: Audio context suspended, resuming...');
                                    audioContext.resume().catch(() => {});
                                }
                                const _ = audioContext.currentTime;
                                try {
                                    const buffer = audioContext.createBuffer(1, 1, 22050);
                                    const source = audioContext.createBufferSource();
                                    source.buffer = buffer;
                                    source.connect(audioContext.destination);
                                    source.start();
                                    source.stop(audioContext.currentTime + 0.001);
                                } catch (e) {
                                    // Ignore errors
                                }
                            }
                            // 4. Ensure drone note is running and enhanced for iOS (CRITICAL)
                            if (!droneOscillator && audioContext && audioContext.state === 'running') {
                                console.log('âš ï¸ iOS: Drone note stopped, restarting...');
                                startDroneNote();
                                setTimeout(() => enhanceDroneForIOS(), 100);
                            } else if (droneOscillator && droneGain) {
                                enhanceDroneForIOS();
                                try {
                                    const _ = droneOscillator.frequency.value;
                                    droneOscillator.frequency.value = 18 + Math.sin(Date.now() / 1000) * 0.1;
                                } catch (e) {
                                    console.log('âš ï¸ iOS: Drone oscillator disconnected, restarting...');
                                    startDroneNote();
                                }
                            }
                            // 5. Force audio context to stay active by touching masterGain
                            if (masterGain) {
                                const currentGain = masterGain.gain.value;
                                masterGain.gain.value = currentGain;
                            }
                            // 6. Ensure at least one oscillator is active
                            if (activeOscillators.size === 0 && audioContext && audioContext.state === 'running') {
                                if (!droneOscillator) {
                                    startDroneNote();
                                }
                            }
                            // 7. Keep video playing (iOS respects video playback)
                            if (!keepAliveVideo || keepAliveVideo.paused) {
                                createKeepAliveVideo();
                                if (keepAliveVideo) {
                                    keepAliveVideo.play().catch(() => {});
                                }
                            }
                            // 8. Trigger visibility API to keep page "active"
                            if (document.visibilityState === 'visible') {
                                document.title = document.title === 'Soundflakes' ? 'Soundflakes ' : 'Soundflakes';
                            }
                        };
                        
                        const startIOSKeepAliveLoop = () => {
                            if (iosKeepAliveInterval || !isIOSDevice || !isSlave) {
                                return;
                            }
                            iosKeepAliveInterval = setInterval(runIOSKeepAliveTick, 2000);
                        };
                        
                        const stopIOSKeepAliveLoop = () => {
                            if (iosKeepAliveInterval) {
                                clearInterval(iosKeepAliveInterval);
                                iosKeepAliveInterval = null;
                            }
                        };
                        
                        // Clean up interval and video on unmount
                        onUnmounted(() => {
                            document.removeEventListener('click', handleClickOutside);
                            stopIOSKeepAliveLoop();
                            if (keepAliveVideo) {
                                keepAliveVideo.pause();
                                keepAliveVideo.remove();
                                keepAliveVideo = null;
                            }
                        });
                        
                        // Comprehensive auto-resume function
                        const performAutoResume = async () => {
                            console.log('ðŸ”„ Performing auto-resume after device wake...');
                            
                            // 1. Re-request wake lock immediately
                            requestWakeLock();
                            
                            // 2. Restart keep-alive video
                            if (typeof createKeepAliveVideo === 'function') {
                                const video = createKeepAliveVideo();
                                if (video) {
                                    if (video.paused || video.ended) {
                                        video.play().catch(() => {
                                            // If play fails, recreate video
                                            if (video.parentNode) {
                                                video.remove();
                                            }
                                            createKeepAliveVideo();
                                        });
                                    }
                                } else {
                                    createKeepAliveVideo();
                                }
                            }
                            
                            // 3. Check and reconnect WebSocket if needed
                            if (!ws.value || ws.value.readyState !== WebSocket.OPEN) {
                                console.log('âš ï¸ WebSocket disconnected after wake, reconnecting...');
                                connectWebSocket();
                                // Wait for connection, then request preset if needed
                                setTimeout(() => {
                                    if (isSlave && assignedNotes.value.length === 0 && ws.value && ws.value.readyState === WebSocket.OPEN) {
                                        console.log('âš ï¸ No notes after reconnection, requesting preset...');
                                        ws.value.send(JSON.stringify({
                                            type: 'request_preset'
                                        }));
                                    }
                                }, 2000);
                            } else {
                                // WebSocket still connected
                                if (isSlave && assignedNotes.value.length === 0) {
                                    console.log('âš ï¸ No notes assigned, requesting current preset...');
                                    ws.value.send(JSON.stringify({
                                        type: 'request_preset'
                                    }));
                                }
                            }
                            
                            // 4. Resume audio context and restart playback
                            if (!audioContext) {
                                console.log('âš ï¸ Audio context missing, initializing...');
                                try {
                                    await initAudio();
                                } catch (e) {
                                    console.error('Failed to initialize audio:', e);
                                    return;
                                }
                            }
                            
                            if (audioContext) {
                                // Try to resume audio context
                                if (audioContext.state === 'suspended' || audioContext.state === 'interrupted') {
                                    console.log('âš ï¸ Audio context suspended/interrupted, attempting to resume...');
                                    try {
                                        const resumePromise = audioContext.resume();
                                        const timeoutPromise = new Promise((_, reject) => 
                                            setTimeout(() => reject(new Error('Resume timeout')), 3000)
                                        );
                                        await Promise.race([resumePromise, timeoutPromise]);
                                        console.log('âœ“ Audio context resumed, state:', audioContext.state);
                                    } catch (e) {
                                        console.log('âš ï¸ Audio resume failed:', e.message);
                                        // Try again after a short delay
                                        setTimeout(async () => {
                                            try {
                                                await audioContext.resume();
                                                console.log('âœ“ Audio context resumed on retry');
                                            } catch (e2) {
                                                console.log('âš ï¸ Audio resume retry also failed:', e2.message);
                                            }
                                        }, 500);
                                    }
                                }
                                
                                // Wait a moment for audio context to stabilize
                                await new Promise(resolve => setTimeout(resolve, 200));
                                
                                // Ensure drone note is running
                                if (!droneOscillator && audioContext.state === 'running') {
                                    console.log('ðŸ”„ Restarting drone note...');
                                    startDroneNote();
                                    if (typeof enhanceDroneForIOS === 'function') {
                                        setTimeout(() => enhanceDroneForIOS(), 100);
                                    }
                                }
                                
                                // Restart playback if we were playing
                                if (isPlaying.value) {
                                    // Small delay to ensure everything is ready
                                    setTimeout(() => {
                                        if (isSlave) {
                                            if (assignedNotes.value.length > 0) {
                                                console.log('ðŸ”„ Restarting slave playback after device wake...');
                                                startSlavePlayback();
                                            } else {
                                                console.log('âš ï¸ Slave: No notes assigned, waiting for preset...');
                                            }
                                        } else {
                                            // Master: restart generators
                                            if (masterAssignedNotes.value.length > 0) {
                                                console.log('ðŸ”„ Restarting master generators after device wake...');
                                                startAllGenerators();
                                            } else {
                                                // If no assigned notes, use all enabled notes
                                                const enabledNotes = noteData.filter(n => n.enabled);
                                                if (enabledNotes.length > 0) {
                                                    console.log('ðŸ”„ Master: Restarting with all enabled notes...');
                                                    startAllGenerators();
                                                }
                                            }
                                        }
                                    }, 300);
                                }
                            }
                        };
                        
                        // Listen for visibility changes (device wake/sleep)
                        document.addEventListener('visibilitychange', () => {
                            isPageVisible = document.visibilityState === 'visible';
                            if (!isPageVisible) {
                                stopIOSKeepAliveLoop();
                            } else if (isIOSDevice && isSlave && isPlaying.value) {
                                startIOSKeepAliveLoop();
                            }
                            if (isPageVisible) {
                                console.log('ðŸ“± Device woke up - starting auto-resume...');
                                // Perform comprehensive auto-resume
                                performAutoResume().catch(e => {
                                    console.error('Auto-resume error:', e);
                                    // Retry after a delay
                                    setTimeout(() => {
                                        performAutoResume().catch(e2 => {
                                            console.error('Auto-resume retry error:', e2);
                                        });
                                    }, 1000);
                                });
                            } else {
                                console.log('ðŸ“± Device went to sleep/standby');
                                // When going to sleep, ensure we preserve state
                                // The keep-alive interval will try to keep things active
                            }
                        });
                        
                        // Also listen for page focus (additional wake detection)
                        window.addEventListener('focus', () => {
                            if (document.visibilityState === 'visible' && isPlaying.value) {
                                console.log('ðŸ“± Page focused - checking if resume needed...');
                                // Small delay to avoid duplicate calls
                                setTimeout(() => {
                                    if (audioContext && (audioContext.state === 'suspended' || audioContext.state === 'interrupted')) {
                                        performAutoResume().catch(e => {
                                            console.error('Focus-based auto-resume error:', e);
                                        });
                                    }
                                }, 500);
                            }
                        });
                        
                        // Clean up wake lock on page unload
                        window.addEventListener('beforeunload', () => {
                            if (wakeLock) {
                                wakeLock.release();
                            }
                        });
                    }
                    
                    if (!isSlave) {
                        // Master-only: Wait for QRCode library to load, then generate QR code
                        const waitForQRCode = () => {
                            if (typeof QRCode !== 'undefined' || typeof window.QRCode !== 'undefined') {
                                scheduleQRCodeGeneration(null, 300);
                            } else {
                                setTimeout(waitForQRCode, 100);
                            }
                        };
                        waitForQRCode();
                        
                        // Regenerate QR code on window resize
                        const resizeHandler = () => {
                            scheduleQRCodeGeneration();
                        };
                        window.addEventListener('resize', resizeHandler);
                        
                        // Watch for controls menu opening to regenerate QR code
                        watch(showControls, (newVal) => {
                            if (newVal) {
                                scheduleQRCodeGeneration();
                            }
                        });
                        
                        // Watch for QR code visibility to generate in fullscreen
                        let qrCodeGenerated = false;
                        watch(showQRCode, (newVal) => {
                            if (newVal) {
                                qrCodeGenerated = false;
                                scheduleQRCodeGeneration(qrCanvasFullscreen.value, 200);
                            } else {
                                qrCodeGenerated = false;
                                if (qrCanvasFullscreen.value) {
                                    qrCanvasFullscreen.value.innerHTML = '';
                                }
                            }
                        });
                        
                        // Watch for iOS keep-alive conditions
                        watch(isPlaying, (playing) => {
                            if (!isIOSDevice || !isSlave) {
                                return;
                            }
                            if (playing && isPageVisible) {
                                startIOSKeepAliveLoop();
                                runIOSKeepAliveTick();
                            } else {
                                stopIOSKeepAliveLoop();
                            }
                        });
                        
                        // Watch for sound preset changes and send to slaves
                        watch(currentPresetName, (newPreset, oldPreset) => {
                            if (!isSlave && oldPreset !== undefined && newPreset !== oldPreset) {
                                console.log('ðŸŽµ Sound preset changed via watcher:', oldPreset, '->', newPreset);
                                if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                    console.log('  âœ“ WebSocket ready, sending preset update to slaves');
                                    sendPresetToSlaves();
                                } else {
                                    console.warn('  âš ï¸ WebSocket not ready, preset update will be sent when ready');
                                }
                            }
                        });
                        
                        // Watch for note changes and send to slaves
                        // Optimize: use lightweight watch on array length and enabled count instead of deep watch
                        watch(() => {
                            // Create a lightweight hash instead of mapping entire objects
                            return noteData.length + '|' + noteData.filter(n => n.enabled).length;
                        }, () => {
                            if (isPlaying.value && ws.value && ws.value.readyState === WebSocket.OPEN) {
                                sendPresetToSlaves();
                            }
                        });
                        
                        // Watch for reference pitch changes and update all note frequencies
                        watch(() => settings.referencePitch, (newPitch, oldPitch) => {
                            if (oldPitch !== undefined && newPitch !== oldPitch) {
                                console.log(`Reference pitch changed from ${oldPitch} Hz to ${newPitch} Hz - updating all note frequencies`);
                                
                                // Recalculate frequencies for all notes, preserving cents offset
                                noteData.forEach((note, idx) => {
                                    if (note.note) {
                                        // Get current cents offset before recalculating base frequency
                                        let centsOffset = note.centsOffset;
                                        if (centsOffset === undefined) {
                                            // Calculate current offset from current base frequency
                                            const currentBaseFreq = noteToFrequency(note.note);
                                            if (currentBaseFreq !== null && currentBaseFreq > 0 && note.freq > 0) {
                                                centsOffset = Math.round(1200 * Math.log2(note.freq / currentBaseFreq));
                                                // Round very small offsets to 0 (within 0.5 cents)
                                                if (Math.abs(centsOffset) < 0.5) {
                                                    centsOffset = 0;
                                                }
                                            } else {
                                                centsOffset = 0;
                                            }
                                            note.centsOffset = centsOffset;
                                        }
                                        
                                        // Calculate new base frequency with new reference pitch
                                        const newBaseFreq = noteToFrequency(note.note);
                                        if (newBaseFreq !== null) {
                                            // Apply preserved cents offset to new base frequency
                                            const centRatio = Math.pow(2, centsOffset / 1200);
                                            const newFreq = newBaseFreq * centRatio;
                                            note.freq = newFreq;
                                            console.log(`  Updated ${note.note}: ${newFreq.toFixed(2)} Hz (${centsOffset !== 0 ? (centsOffset > 0 ? '+' : '') + centsOffset + 'Â¢' : '0Â¢'})`);
                                        }
                                    }
                                });
                                
                                // Update master assigned notes frequencies if master is included
                                if (settings.masterIncluded && masterAssignedNotes.value.length > 0) {
                                    console.log(`  Updating ${masterAssignedNotes.value.length} master assigned notes frequencies`);
                                    masterAssignedNotes.value.forEach(note => {
                                        if (note.note) {
                                            const oldFreq = note.freq;
                                            const newFreq = noteToFrequency(note.note);
                                            if (newFreq !== null) {
                                                note.freq = newFreq;
                                                console.log(`    Updated master note ${note.note}: ${oldFreq.toFixed(2)} Hz -> ${newFreq.toFixed(2)} Hz`);
                                            }
                                        }
                                    });
                                    // Always update the assignedNotes copy if master flake is playing (same as slaves)
                                    if (!isSlave && assignedNotes.value.length > 0) {
                                        console.log('  Updating assignedNotes copy for master flake playback');
                                        assignedNotes.value.forEach((note) => {
                                            const masterNote = masterAssignedNotes.value.find(mn => mn.note === note.note);
                                            if (masterNote) {
                                                const oldFreq = note.freq;
                                                note.freq = masterNote.freq;
                                                console.log(`    Updated assignedNotes copy: ${note.note} = ${oldFreq.toFixed(2)} Hz -> ${note.freq.toFixed(2)} Hz`);
                                            }
                                        });
                                    }
                                }
                                
                                // Update all slave assigned notes
                                connectedSlaves.forEach(slave => {
                                    if (slave.assignedNotes && slave.assignedNotes.length > 0) {
                                        slave.assignedNotes.forEach(note => {
                                            if (note.note) {
                                                const newFreq = noteToFrequency(note.note);
                                                if (newFreq !== null) {
                                                    note.freq = newFreq;
                                                }
                                            }
                                        });
                                    }
                                });
                                
                                // Send updated preset to slaves
                                if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                    console.log('Sending updated frequencies to slaves...');
                                    sendPresetToSlaves();
                                }
                                
                                // Update frequencies of currently playing oscillators in real-time
                                if (isPlaying.value && !isSlave) {
                                    console.log('Updating frequencies of currently playing oscillators...');
                                    
                                    // Update master generators
                                    generatorOscillators.forEach((oscSet, generatorId) => {
                                        if (oscSet && oscSet.size > 0) {
                                            oscSet.forEach(osc => {
                                                if (osc && osc.noteName) {
                                                    // Recalculate frequency for this note with new reference pitch
                                                    const newFreq = noteToFrequency(osc.noteName);
                                                    if (newFreq !== null && osc.frequency) {
                                                        const oldFreq = osc.frequency.value;
                                                        osc.frequency.value = newFreq;
                                                        console.log(`  Generator ${generatorId}: Updated ${osc.noteName} ${oldFreq.toFixed(2)} Hz -> ${newFreq.toFixed(2)} Hz`);
                                                    }
                                                }
                                            });
                                        }
                                    });
                                    
                                    // Update master flake playback oscillators (if using slave playback logic)
                                    if (settings.masterIncluded && masterAssignedNotes.value.length > 0 && isNotePlaying.value) {
                                        // The master flake uses the same generatorOscillators[0] system, so it's already covered above
                                        console.log('  Master flake oscillators updated');
                                    }
                                    
                                    console.log('Frequencies updated. Currently playing notes now use new reference pitch.');
                                } else {
                                    console.log('Frequencies updated. Next notes will use new reference pitch.');
                                }
                            }
                        });
                        
                        // Watch for preset changes (excluding masterVolume to prevent conflicts)
                        // Master volume is handled separately with debouncing
                        let presetUpdateTimeout = null;
                        watch(() => [settings.noteLength, settings.pauseLength, settings.numGenerators, settings.masterIncluded], (newVal, oldVal) => {
                            // Debounce preset updates to prevent rapid changes
                            if (presetUpdateTimeout) {
                                clearTimeout(presetUpdateTimeout);
                            }
                            
                            presetUpdateTimeout = setTimeout(() => {
                                console.log('Settings changed, masterIncluded:', settings.masterIncluded);
                                if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                    console.log('Sending preset update to server...');
                                    sendPresetToSlaves();
                                    // If master inclusion changed and we're playing, restart
                                    if (isPlaying.value) {
                                        setTimeout(() => {
                                            if (isPlaying.value) {
                                                console.log('Restarting generators due to setting change...');
                                                startAllGenerators();
                                            }
                                        }, 100);
                                    }
                                } else {
                                    console.log('WebSocket not ready, cannot send preset update');
                                }
                            }, 200); // 200ms debounce for preset updates
                        });
                        
                        // Separate debounced watcher for master volume preset updates
                        let masterVolumePresetTimeout = null;
                        watch(() => settings.masterVolume, (volume) => {
                            // Debounce preset updates for volume separately
                            if (masterVolumePresetTimeout) {
                                clearTimeout(masterVolumePresetTimeout);
                            }
                            
                            masterVolumePresetTimeout = setTimeout(() => {
                                if (ws.value && ws.value.readyState === WebSocket.OPEN) {
                                    console.log('Sending master volume preset update to server...');
                                    sendPresetToSlaves();
                                }
                            }, 500); // Longer debounce for volume preset updates (500ms)
                        });
                        
                        // Watch for mute changes and update master gain with smooth ramping
                        if (!isSlave) {
                            watch(() => settings.masterMuted, (muted) => {
                                if (masterGain && audioContext) {
                                    const now = audioContext.currentTime;
                                    const targetVolume = muted ? 0 : settings.masterVolume / 100;
                                    
                                    // Get current gain, cancel scheduled changes, then re-read
                                    let currentGain = masterGain.gain.value;
                                    masterGain.gain.cancelScheduledValues(now);
                                    currentGain = masterGain.gain.value; // Re-read after cancellation
                                    
                                    // Use setTargetAtTime for smoother transitions
                                    // Time constant of 0.15 seconds matches volume knob and slave sliders for consistent feel
                                    const epsilon = 0.0001;
                                    const targetGainSafe = Math.max(targetVolume, epsilon);
                                    
                                    // Cancel scheduled changes and use setTargetAtTime for smooth transition
                                    masterGain.gain.cancelScheduledValues(now);
                                    masterGain.gain.setTargetAtTime(targetGainSafe, now, 0.15);
                                }
                            });
                            
                            // Update volume immediately while turning, but use setTargetAtTime for smooth transitions
                            watch(() => settings.masterVolume, (volume) => {
                                if (masterGain && audioContext && !settings.masterMuted) {
                                    const now = audioContext.currentTime;
                                    const targetVolume = volume / 100;
                                    
                                    // Cancel any scheduled changes to prevent conflicts
                                    masterGain.gain.cancelScheduledValues(now);
                                    
                                    // Use setTargetAtTime for smooth exponential approach
                                    // Time constant of 0.15 seconds matches slave volume sliders for consistent feel
                                    const epsilon = 0.0001;
                                    const targetGainSafe = Math.max(targetVolume, epsilon);
                                    
                                    masterGain.gain.setTargetAtTime(targetGainSafe, now, 0.15);
                                }
                            });
                        }
                        
                        // For slaves: monitor audio context state and keep it running
                        if (isSlave) {
                            setInterval(() => {
                                if (isPlaying.value && audioContext && audioContext.state === 'suspended') {
                                    console.log('âš ï¸ Audio context suspended during playback, attempting to resume...');
                                    console.log('isPlaying:', isPlaying.value, 'assignedNotes:', assignedNotes.value.length);
                                    // Try to resume with timeout
                                    const resumePromise = audioContext.resume();
                                    const timeoutPromise = new Promise((_, reject) => 
                                        setTimeout(() => reject(new Error('Resume timeout')), 1000)
                                    );
                                    Promise.race([resumePromise, timeoutPromise]).then(() => {
                                        console.log('âœ“ Audio context resumed successfully during playback');
                                    }).catch(e => {
                                        console.error('âœ— Failed to resume audio context during playback:', e.message);
                                        // If resume fails, try to restart playback
                                        console.log('Attempting to restart playback...');
                                        if (assignedNotes.value.length > 0) {
                                            startSlavePlayback();
                                        }
                                    });
                                }
                                // Also check if we're supposed to be playing but aren't
                                if (isPlaying.value && assignedNotes.value.length > 0 && generatorTimeouts.length === 0) {
                                    console.log('âš ï¸ Should be playing but no generators active, restarting...');
                                    startSlavePlayback();
                                }
                            }, 2000); // Check every 2 seconds
                        }
                        
                        // Load default preset on mount (only for master)
                        if (!isSlave) {
                            loadNotePreset('1 â€¢ Original Sine â€¢ G Minor Pentatonic â€¢ 440Hz');
                            // Ensure sound preset is set to Original Sine (simple sine wave)
                            currentPresetName.value = 'Original Sine';
                        }
                        
                        // Save default palette on first load if it doesn't exist
                        const palettes = JSON.parse(localStorage.getItem('soundmarbles-palettes') || '[]');
                        const hasDefault = palettes.some(p => p.name === 'Default');
                        if (!hasDefault) {
                            const defaultPalette = {
                                name: 'Default',
                                notes: noteData.map(n => ({
                                    note: n.note,
                                    freq: n.freq,
                                    color: n.color,
                                    volume: n.volume,
                                    enabled: n.enabled
                                }))
                            };
                            palettes.push(defaultPalette);
                            localStorage.setItem('soundmarbles-palettes', JSON.stringify(palettes));
                        }
                    }
                });
                
                return {
                    canvas, qrCanvas, qrCanvasFullscreen, showQRCode, isPlaying, showControls, settings, noteData,
                    togglePlayback, openMenu, closeMenu, toggleMenu, savePreset, loadPreset,
                    currentPaletteName, showPaletteEditor, showAdvancedSettings, newNoteName, newNoteFreq,
                    addNote, removeNote, createNewPalette, saveCurrentPalette, loadPalette,
                    calculateFrequency, updateNoteFrequency, adjustNoteFrequency, getCentsOffset, transposeAllNotes,
                    // Preset system
                    predefinedPresets, currentNotePreset, loadNotePreset, showPresetMenu, allPresets, selectPreset,
                    // Tutorial system
                    showTutorial, currentTutorialSection, tutorialSections, updateTutorialFade,
                    // Sound preset system
                    synthPresets, currentPresetName, loadSynthPresetByName,
                    // WebSocket and slave-related reactive variables
                    ws, wsConnected, wsReceivedWelcome, wsError, assignedNotes, isSlave, slaveStatus,
                    connectedSlaves, totalSlaves, masterAssignedNotes, masterCurrentlyPlayingNote, masterVolume, displaySlaves, updateSlaveVolume, getSlaveDisplayVolume, slaveName, slaveVolume, slaveCurrentlyPlayingNote, getPlayingNoteStyle, sendPresetToSlaves, distributeNotesToSlaves,
                    // Tap handler for iOS
                    handleTapToStart,
                    // Master included toggle
                    toggleMasterIncluded,
                    // Fullscreen control
                    isFullscreen, requestFullscreenMode, exitFullscreenMode,
                    // Sleep prevention tip
                    showSleepPreventionTip, isIOSDevice, openIOSSettings,
                    // Audio state for overlay
                    audioUnlocked: () => audioUnlocked,
                    audioContext: () => audioContext,
                    audioReady
                };
            }
        }).mount('#app');
    </script>
</body>
</html>